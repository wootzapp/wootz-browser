"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inAppWalletSendCalls = inAppWalletSendCalls;
exports.inAppWalletGetCallsStatus = inAppWalletGetCallsStatus;
const eth_getTransactionReceipt_js_1 = require("../../../../rpc/actions/eth_getTransactionReceipt.js");
const rpc_js_1 = require("../../../../rpc/rpc.js");
const send_and_confirm_transaction_js_1 = require("../../../../transaction/actions/send-and-confirm-transaction.js");
const send_batch_transaction_js_1 = require("../../../../transaction/actions/send-batch-transaction.js");
const random_js_1 = require("../../../../utils/random.js");
const bundlesToTransactions = new Map();
const MAX_BUNDLE_ENTRIES = 1000;
/**
 * @internal
 */
function setBundleId(bundleId, hashes) {
    if (bundlesToTransactions.size >= MAX_BUNDLE_ENTRIES) {
        const lru = bundlesToTransactions.keys().next().value;
        bundlesToTransactions.delete(lru);
    }
    bundlesToTransactions.set(bundleId, hashes);
}
/**
 * @internal
 */
async function inAppWalletSendCalls(args) {
    const { account, calls } = args;
    const hashes = [];
    const bundleId = (0, random_js_1.randomBytesHex)(65);
    bundlesToTransactions.set(bundleId, hashes);
    if (account.sendBatchTransaction) {
        const receipt = await (0, send_batch_transaction_js_1.sendBatchTransaction)({
            account,
            transactions: calls,
        });
        hashes.push(receipt.transactionHash);
        setBundleId(bundleId, hashes);
    }
    else {
        for (const tx of calls) {
            const receipt = await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
                account,
                transaction: tx,
            });
            hashes.push(receipt.transactionHash);
            bundlesToTransactions.set(bundleId, hashes);
        }
    }
    return bundleId;
}
/**
 * @internal
 */
async function inAppWalletGetCallsStatus(args) {
    const { wallet, client, bundleId } = args;
    const chain = wallet.getChain();
    if (!chain) {
        throw new Error("Failed to get calls status, no active chain found");
    }
    const bundle = bundlesToTransactions.get(bundleId);
    if (!bundle) {
        throw new Error("Failed to get calls status, unknown bundle id");
    }
    const request = (0, rpc_js_1.getRpcClient)({ client, chain });
    let status = "CONFIRMED";
    const receipts = await Promise.all(bundle.map((hash) => (0, eth_getTransactionReceipt_js_1.eth_getTransactionReceipt)(request, { hash })
        .then((receipt) => ({
        logs: receipt.logs.map((l) => ({
            address: l.address,
            data: l.data,
            topics: l.topics,
        })),
        status: receipt.status,
        blockHash: receipt.blockHash,
        blockNumber: receipt.blockNumber,
        gasUsed: receipt.gasUsed,
        transactionHash: receipt.transactionHash,
    }))
        .catch(() => {
        status = "PENDING";
        return null; // Return null if there's an error to filter out later
    })));
    return {
        status,
        receipts: receipts.filter((r) => r !== null), // ts 5.5 please come we need you
    };
}
//# sourceMappingURL=in-app-wallet-calls.js.map