import { useState } from "react";
import { polygon } from "../../../../../../../chains/chain-definitions/polygon.js";
import { useActiveWalletChain } from "../../../../../../core/hooks/wallets/useActiveWalletChain.js";
import { useDebouncedValue } from "../../../../hooks/useDebouncedValue.js";
import { NATIVE_TOKEN } from "../../nativeToken.js";
import { currencies, usdCurrency, } from "../fiat/currencies.js";
// handle states for token and chain selection
export function useToTokenSelectionStates(options) {
    const { payOptions, supportedDestinations } = options;
    // --------------------------------------------------------------------------
    // buy token amount ---------------------------------------------------------
    // NOTE - for transaction / direct payment modes, the token amount is set when the user tap continue
    const prefillBuy = payOptions?.prefillBuy;
    const activeChain = useActiveWalletChain();
    const initialTokenAmount = prefillBuy?.amount || "";
    const [tokenAmount, setTokenAmount] = useState(initialTokenAmount);
    const deferredTokenAmount = useDebouncedValue(tokenAmount, 300);
    // Destination chain and token selection -----------------------------------
    const [toChain, setToChain] = useState(
    // use prefill chain if available
    prefillBuy?.chain ||
        (payOptions.mode === "transaction" && payOptions.transaction?.chain) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo?.chain) ||
        // use active chain if its supported as destination
        supportedDestinations.find((x) => x.chain.id === activeChain?.id)
            ?.chain ||
        // default to the first chain in supportedDestinations, or polygon if nothing is found at all
        supportedDestinations[0]?.chain ||
        polygon);
    const [toToken, setToToken] = useState(prefillBuy?.token ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo.token) ||
        NATIVE_TOKEN);
    return {
        toChain,
        setToChain,
        toToken,
        setToToken,
        tokenAmount,
        setTokenAmount,
        deferredTokenAmount,
    };
}
export function useFromTokenSelectionStates(options) {
    const { payOptions, supportedSources } = options;
    // --------------------------------------------------------------------------
    const firstSupportedSource = supportedSources?.length
        ? supportedSources[0]
        : undefined;
    // Source token and chain selection ---------------------------------------------------
    const [fromChain_, setFromChain] = useState();
    // use prefill chain if available
    const fromChainDevSpecified = (payOptions.buyWithCrypto !== false &&
        payOptions.buyWithCrypto?.prefillSource?.chain) ||
        (payOptions.mode === "transaction" && payOptions.transaction?.chain) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo?.chain);
    const fromChainFromApi = firstSupportedSource?.chain
        ? firstSupportedSource.chain
        : undefined;
    const fromChain = fromChain_ || fromChainDevSpecified || fromChainFromApi || polygon;
    const [fromToken_, setFromToken] = useState();
    // use prefill token if available
    const fromTokenDevSpecified = (payOptions.buyWithCrypto !== false &&
        payOptions.buyWithCrypto?.prefillSource?.token) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo.token);
    // May be updated in the future
    const fromTokenFromApi = NATIVE_TOKEN;
    // supported tokens query in here
    const fromToken = fromToken_ || fromTokenDevSpecified || fromTokenFromApi || NATIVE_TOKEN;
    return {
        fromChain,
        setFromChain,
        fromToken,
        setFromToken,
    };
}
export function useFiatCurrencySelectionStates(options) {
    const { payOptions } = options;
    // --------------------------------------------------------------------------
    const devSpecifiedDefaultCurrency = payOptions.buyWithFiat !== false
        ? payOptions.buyWithFiat?.prefillSource?.currency
        : undefined;
    const defaultSelectedCurrencyShorthand = devSpecifiedDefaultCurrency || getDefaultCurrencyBasedOnLocation();
    const [selectedCurrency, setSelectedCurrency] = useState(currencies.find((x) => x.shorthand === defaultSelectedCurrencyShorthand) ||
        usdCurrency);
    return {
        selectedCurrency,
        setSelectedCurrency,
    };
}
function getDefaultCurrencyBasedOnLocation() {
    // if Intl is not supported - browser throws
    try {
        const timeZone = Intl.DateTimeFormat()
            .resolvedOptions()
            .timeZone.toLowerCase();
        // Europe/London -> GBP
        if (timeZone.includes("london")) {
            return "GBP";
        }
        // Europe/* -> EUR
        if (timeZone.includes("europe")) {
            return "EUR";
        }
        // Japan
        if (timeZone.includes("japan")) {
            return "JPY";
        }
        // canada
        if (timeZone.includes("canada")) {
            return "CAD";
        }
        return "USD";
    }
    catch {
        return "USD";
    }
}
//# sourceMappingURL=useUISelectionStates.js.map