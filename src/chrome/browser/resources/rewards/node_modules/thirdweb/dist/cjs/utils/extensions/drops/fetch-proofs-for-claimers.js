"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchProofsForClaimer = fetchProofsForClaimer;
const addresses_js_1 = require("../../../constants/addresses.js");
const MerkleTree_js_1 = require("../../../merkletree/MerkleTree.js");
const download_js_1 = require("../../../storage/download.js");
const convert_quantity_js_1 = require("./convert-quantity.js");
const hash_entry_js_1 = require("./hash-entry.js");
async function fetchProofsForClaimer(options) {
    const { contract, merkleTreeUri, claimer } = options;
    const hashEntryFn = options.hashEntry || hash_entry_js_1.hashEntry;
    // 2. download snapshot data
    const response = await (0, download_js_1.download)({
        client: contract.client,
        uri: merkleTreeUri,
    });
    const merkleInfo = await response.json();
    // 3. download shard data based off the user address
    const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();
    const uri = merkleInfo.baseUri.endsWith("/")
        ? merkleInfo.baseUri
        : `${merkleInfo.baseUri}/`;
    let shardData;
    try {
        const constructedShardUri = `${uri}${shardId}.json`;
        const shard = await (0, download_js_1.download)({
            client: contract.client,
            uri: constructedShardUri,
        });
        shardData = await shard.json();
    }
    catch {
        // if the file can't be fetched it means claimer not in merkle tree
        return null;
    }
    // 4. hash all the entries in that shard and construct the sub merkle tree
    const hashedEntries = await Promise.all(shardData.entries.map(async (entry) => {
        return hashEntryFn({
            entry,
            chain: contract.chain,
            client: contract.client,
            tokenDecimals: options.tokenDecimals,
        });
    }));
    // 5. get the proof for the claimer + the sub merkle tree root
    const tree = new MerkleTree_js_1.MerkleTree(hashedEntries);
    const entry = shardData.entries.find((i) => i.address.toLowerCase() === claimer.toLowerCase());
    if (!entry) {
        return null;
    }
    const proof = tree
        .getHexProof(await hashEntryFn({
        entry,
        chain: contract.chain,
        client: contract.client,
        tokenDecimals: options.tokenDecimals,
    }))
        .concat(shardData.proofs);
    // 6. return the proof and the entry data for the contract call
    const currencyAddress = (entry.currencyAddress || addresses_js_1.ZERO_ADDRESS);
    const currencyDecimals = await (async () => {
        if ((0, addresses_js_1.isNativeTokenAddress)(currencyAddress) ||
            currencyAddress === addresses_js_1.ZERO_ADDRESS) {
            return 18;
        }
        const [{ getContract }, { decimals: getDecimals }] = await Promise.all([
            Promise.resolve().then(() => require("../../../contract/contract.js")),
            Promise.resolve().then(() => require("../../../extensions/erc20/read/decimals.js")),
        ]);
        const currencyContract = getContract({
            address: currencyAddress,
            chain: contract.chain,
            client: contract.client,
        });
        return await getDecimals({ contract: currencyContract });
    })();
    return {
        proof,
        quantityLimitPerWallet: (0, convert_quantity_js_1.convertQuantity)({
            quantity: entry.maxClaimable || "unlimited",
            tokenDecimals: options.tokenDecimals,
        }),
        pricePerToken: (0, convert_quantity_js_1.convertQuantity)({
            quantity: entry.price || "unlimited",
            tokenDecimals: currencyDecimals,
        }),
        currency: currencyAddress,
    };
}
//# sourceMappingURL=fetch-proofs-for-claimers.js.map