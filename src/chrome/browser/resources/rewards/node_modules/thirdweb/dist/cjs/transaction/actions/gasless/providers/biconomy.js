"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareBiconomyTransaction = prepareBiconomyTransaction;
exports.relayBiconomyTransaction = relayBiconomyTransaction;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../../constants/addresses.js");
const contract_js_1 = require("../../../../contract/contract.js");
const is_hex_js_1 = require("../../../../utils/encoding/helpers/is-hex.js");
const keccak256_js_1 = require("../../../../utils/hashing/keccak256.js");
const json_js_1 = require("../../../../utils/json.js");
const read_contract_js_1 = require("../../../read-contract.js");
// we do not send multiple batches so this stays consistent
const BATCH_ID = 0n;
/**
 * @internal - only exported for testing
 */
async function prepareBiconomyTransaction({ account, serializableTransaction, transaction, gasless, }) {
    const forwarderContract = (0, contract_js_1.getContract)({
        address: gasless.relayerForwarderAddress,
        chain: transaction.chain,
        client: transaction.client,
    });
    // get the nonce
    const nonce = await (0, read_contract_js_1.readContract)({
        contract: forwarderContract,
        method: "function getNonce(address,uint256) view returns (uint256)",
        params: [account.address, BATCH_ID],
    });
    const deadline = Math.floor(Date.now() / 1000) + (gasless.deadlineSeconds ?? 3600);
    const request = {
        from: account.address,
        to: serializableTransaction.to,
        token: addresses_js_1.ADDRESS_ZERO,
        txGas: serializableTransaction.gas,
        tokenGasPrice: 0n,
        batchId: BATCH_ID,
        batchNonce: nonce,
        deadline: deadline,
        data: serializableTransaction.data,
    };
    if (!request.to) {
        throw new Error("Cannot send a transaction without a `to` address");
    }
    if (!request.txGas) {
        throw new Error("Cannot send a transaction without a `gas` value");
    }
    if (!request.data) {
        throw new Error("Cannot send a transaction without a `data` value");
    }
    // create the hash
    const message = (0, viem_1.encodeAbiParameters)([
        { type: "address" },
        { type: "address" },
        { type: "address" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" },
    ], [
        request.from,
        request.to,
        request.token,
        request.txGas,
        request.tokenGasPrice,
        request.batchId,
        request.batchNonce,
        (0, keccak256_js_1.keccak256)(request.data),
    ]);
    const signature = await account.signMessage({ message });
    return [request, signature];
}
/**
 * @internal
 */
async function relayBiconomyTransaction(options) {
    const [request, signature] = await prepareBiconomyTransaction(options);
    // send the transaction to the biconomy api
    const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
        method: "POST",
        body: (0, json_js_1.stringify)({
            apiId: options.gasless.apiId,
            params: [request, signature],
            from: request.from,
            to: request.to,
            gasLimit: request.txGas,
        }),
        headers: {
            "x-api-key": options.gasless.apiKey,
            "Content-Type": "application/json;charset=utf-8",
        },
    });
    if (!response.ok) {
        response.body?.cancel();
        throw new Error(`Failed to send transaction: ${await response.text()}`);
    }
    const json = await response.json();
    const transactionHash = json.txHash;
    if ((0, is_hex_js_1.isHex)(transactionHash)) {
        return {
            transactionHash: transactionHash,
            chain: options.transaction.chain,
            client: options.transaction.client,
        };
    }
    throw new Error(`Failed to send transaction: ${(0, json_js_1.stringify)(json)}`);
}
//# sourceMappingURL=biconomy.js.map