"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.privateKeyToAccount = privateKeyToAccount;
const secp256k1_1 = require("@noble/curves/secp256k1");
const utils_1 = require("viem/utils");
const utils_js_1 = require("../chains/utils.js");
const eth_sendRawTransaction_js_1 = require("../rpc/actions/eth_sendRawTransaction.js");
const rpc_js_1 = require("../rpc/rpc.js");
const sign_transaction_js_1 = require("../transaction/actions/sign-transaction.js");
const hex_js_1 = require("../utils/encoding/hex.js");
const sign_message_js_1 = require("../utils/signatures/sign-message.js");
const sign_typed_data_js_1 = require("../utils/signatures/sign-typed-data.js");
/**
 * Get an `Account` object from a private key.
 * @param options - The options for `privateKeyToAccount`
 * Refer to the type [`PrivateKeyToAccountOptions`](https://portal.thirdweb.com/references/typescript/v5/PrivateKeyToAccountOptions)
 * @returns The `Account` object that represents the private key
 * @example
 * ```ts
 * import { privateKeyToAccount } from "thirdweb/wallets"
 *
 * const wallet = privateKeyToAccount({
 *  client,
 *  privateKey: "...",
 * });
 * ```
 * @wallet
 */
function privateKeyToAccount(options) {
    const { client } = options;
    const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
    const publicKey = (0, hex_js_1.toHex)(secp256k1_1.secp256k1.getPublicKey(privateKey.slice(2), false));
    const address = (0, utils_1.publicKeyToAddress)(publicKey); // TODO: Implement publicKeyToAddress natively (will need checksumAddress downstream)
    const account = {
        address,
        sendTransaction: async (
        // TODO: figure out how we would pass our "chain" object in here?
        // maybe we *do* actually have to take in a tx object instead of the raw tx?
        tx) => {
            const rpcRequest = (0, rpc_js_1.getRpcClient)({
                client: client,
                chain: (0, utils_js_1.getCachedChain)(tx.chainId),
            });
            const signedTx = (0, sign_transaction_js_1.signTransaction)({
                transaction: tx,
                privateKey,
            });
            const transactionHash = await (0, eth_sendRawTransaction_js_1.eth_sendRawTransaction)(rpcRequest, signedTx);
            return {
                transactionHash,
            };
        },
        signMessage: async ({ message }) => {
            return (0, sign_message_js_1.signMessage)({
                message,
                privateKey,
            });
        },
        signTypedData: async (_typedData) => {
            return (0, sign_typed_data_js_1.signTypedData)({
                ..._typedData,
                privateKey,
            });
        },
        signTransaction: async (tx) => {
            return (0, sign_transaction_js_1.signTransaction)({
                transaction: tx,
                privateKey,
            });
        },
    };
    return account;
}
//# sourceMappingURL=private-key.js.map