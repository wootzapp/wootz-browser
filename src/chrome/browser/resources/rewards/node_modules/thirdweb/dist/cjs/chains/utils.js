"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineChain = defineChain;
exports.cacheChains = cacheChains;
exports.getCachedChain = getCachedChain;
exports.getCachedChainIfExists = getCachedChainIfExists;
exports.getRpcUrlForChain = getRpcUrlForChain;
exports.getChainSymbol = getChainSymbol;
exports.getChainDecimals = getChainDecimals;
exports.getChainNativeCurrencyName = getChainNativeCurrencyName;
exports.getChainMetadata = getChainMetadata;
exports.convertApiChainToChain = convertApiChainToChain;
const domains_js_1 = require("../utils/domains.js");
const fetch_js_1 = require("../utils/fetch.js");
const withCache_js_1 = require("../utils/promise/withCache.js");
const CUSTOM_CHAIN_MAP = new Map();
/**
 * Defines a chain with the given options.
 * @param options The options for the chain.
 * @returns The defined chain.
 * @example
 * Just pass the chain ID to connect to:
 * ```ts
 * const chain = defineChain(1);
 * ```
 * Or pass your own RPC or custom values:
 * ```ts
 * const chain = defineChain({
 *  id: 1,
 *  rpc: "https://my-rpc.com",
 *  nativeCurrency: {
 *    name: "Ether",
 *    symbol: "ETH",
 *    decimals: 18,
 *  },
 * });
 * ```
 * @chain
 */
function defineChain(options) {
    const RPC_URL = (0, domains_js_1.getThirdwebDomains)().rpc;
    if (typeof options === "number") {
        return {
            id: options,
            rpc: `https://${options}.${RPC_URL}`,
        };
    }
    if (isViemChain(options)) {
        return convertViemChain(options);
    }
    if (isLegacyChain(options)) {
        return convertLegacyChain(options);
    }
    // otherwise if it's not a viem chain, continue
    let rpc = options.rpc;
    if (!rpc) {
        rpc = `https://${options.id}.${RPC_URL}`;
    }
    const chain = { ...options, rpc };
    CUSTOM_CHAIN_MAP.set(options.id, chain);
    return chain;
}
/**
 * @internal
 */
function cacheChains(chains) {
    for (const chain of chains) {
        CUSTOM_CHAIN_MAP.set(chain.id, chain);
    }
}
/**
 * @internal
 */
function getCachedChain(id) {
    if (CUSTOM_CHAIN_MAP.has(id)) {
        return CUSTOM_CHAIN_MAP.get(id);
    }
    const RPC_URL = (0, domains_js_1.getThirdwebDomains)().rpc;
    const chain = {
        id: id,
        rpc: `https://${id}.${RPC_URL}`,
    };
    return chain;
}
/**
 * @internal
 */
function getCachedChainIfExists(id) {
    return CUSTOM_CHAIN_MAP.get(id);
}
function isLegacyChain(chain) {
    return "rpc" in chain && Array.isArray(chain.rpc) && "slug" in chain;
}
function convertLegacyChain(legacyChain) {
    const RPC_URL = (0, domains_js_1.getThirdwebDomains)().rpc;
    return {
        id: legacyChain.chainId,
        name: legacyChain.name,
        rpc: legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.${RPC_URL}`,
        blockExplorers: legacyChain?.explorers?.map((explorer) => ({
            name: explorer.name,
            url: explorer.url,
            apiUrl: explorer.url,
        })),
        nativeCurrency: {
            name: legacyChain.nativeCurrency.name,
            symbol: legacyChain.nativeCurrency.symbol,
            decimals: legacyChain.nativeCurrency.decimals,
        },
        faucets: legacyChain.faucets ? [...legacyChain.faucets] : undefined,
        icon: legacyChain.icon,
        testnet: legacyChain.testnet ? true : undefined,
    };
}
function isViemChain(chain) {
    return "rpcUrls" in chain && !("rpc" in chain);
}
function convertViemChain(viemChain) {
    const RPC_URL = (0, domains_js_1.getThirdwebDomains)().rpc;
    return {
        id: viemChain.id,
        name: viemChain.name,
        nativeCurrency: {
            name: viemChain.nativeCurrency.name,
            symbol: viemChain.nativeCurrency.symbol,
            decimals: viemChain.nativeCurrency.decimals,
        },
        rpc: viemChain.rpcUrls.default.http[0] ?? `https://${viemChain.id}.${RPC_URL}`,
        blockExplorers: viemChain?.blockExplorers
            ? Object.values(viemChain?.blockExplorers).map((explorer) => {
                return {
                    name: explorer.name,
                    url: explorer.url,
                    apiUrl: explorer.apiUrl,
                };
            })
            : [],
        testnet: viemChain.testnet ? true : undefined,
    };
}
/**
 * Retrieves the RPC URL for the specified chain.
 * If a custom RPC URL is defined in the options, it will be used.
 * Otherwise, a thirdweb RPC URL will be constructed using the chain ID and client ID.
 * @param options - The options object containing the chain and client information.
 * @returns The RPC URL for the specified chain.
 * @example
 * ```ts
 * import { getRpcUrlForChain } from "thirdweb/chains";
 * const rpcUrl = getRpcUrlForChain({ chain: 1, client });
 * console.log(rpcUrl); // "https://1.rpc.thirdweb.com/...
 * ```
 * @chain
 */
function getRpcUrlForChain(options) {
    const baseRpcUrl = (0, domains_js_1.getThirdwebDomains)().rpc;
    // if the chain is just a number, construct the RPC URL using the chain ID and client ID
    if (typeof options.chain === "number") {
        return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;
    }
    const { rpc } = options.chain;
    // add on the client ID to the RPC URL if it's a thirdweb URL
    if ((0, fetch_js_1.isThirdwebUrl)(rpc)) {
        const rpcUrl = new URL(options.chain.rpc.replace(domains_js_1.DEFAULT_RPC_URL, baseRpcUrl));
        rpcUrl.pathname = `/${options.client.clientId}`;
        return rpcUrl.toString();
    }
    return rpc;
}
/**
 * Retrieves the chain symbol from the provided chain.
 * @param chain - The chain.
 * @returns The chain symbol.
 * @internal
 */
async function getChainSymbol(chain) {
    if (!chain.nativeCurrency?.symbol) {
        return getChainMetadata(chain)
            .then((data) => data.nativeCurrency.symbol)
            .catch(() => {
            // if we fail to fetch the chain data, return "ETH" as a fallback
            return "ETH";
        });
    }
    // if we have a symbol, return it
    return chain.nativeCurrency.symbol;
}
/**
 * Retrieves the number of decimals for the native currency of a given chain.
 * If the chain is not recognized or the data cannot be fetched, it returns a fallback value of 18.
 * @param chain - The chain for which to retrieve the decimals.
 * @returns A promise that resolves to the number of decimals for the native currency of the chain.
 * @internal
 */
async function getChainDecimals(chain) {
    if (!chain.nativeCurrency?.decimals) {
        return getChainMetadata(chain)
            .then((data) => data.nativeCurrency.decimals)
            .catch(() => {
            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)
            return 18;
        });
    }
    // if we have decimals, return it
    return chain.nativeCurrency.decimals;
}
/**
 * Retrieves the name of the native currency for a given chain.
 * If the chain object does not have a native currency name, it attempts to fetch the chain data and retrieve the native currency name from there.
 * If fetching the chain data fails, it falls back to returning "ETH".
 * @param chain The chain object for which to retrieve the native currency name.
 * @returns A promise that resolves to the native currency name.
 * @internal
 */
async function getChainNativeCurrencyName(chain) {
    if (!chain.nativeCurrency?.name) {
        return getChainMetadata(chain)
            .then((data) => data.nativeCurrency.name)
            .catch(() => {
            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)
            return "ETH";
        });
    }
    // if we have a name, return it
    return chain.nativeCurrency.name;
}
/**
 * Retrieves chain data for a given chain.
 * @param chain - The chain object containing the chain ID.
 * @returns A Promise that resolves to the chain data.
 * @throws If there is an error fetching the chain data.
 * @example
 * ```ts
 * const chain = defineChain({ id: 1 });
 * const chainData = await getChainMetadata(chain);
 * console.log(chainData);
 * ```
 * @chain
 */
function getChainMetadata(chain) {
    const chainId = chain.id;
    return (0, withCache_js_1.withCache)(async () => {
        try {
            const res = await fetch(`https://api.thirdweb.com/v1/chains/${chainId}`);
            if (!res.ok) {
                res.body?.cancel();
                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
            }
            const response = (await res.json());
            if (response.error) {
                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
            }
            if (!response.data) {
                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
            }
            const data = response.data;
            return createChainMetadata(chain, data);
        }
        catch {
            return createChainMetadata(chain);
        }
    }, {
        cacheKey: `chain:${chainId}`,
        cacheTime: 5 * 60 * 1000, // 5 minutes
    });
}
/**
 * Convert `ApiChain` to `Chain` object
 * @internal
 */
function convertApiChainToChain(apiChain) {
    return {
        id: apiChain.chainId,
        name: apiChain.name,
        rpc: apiChain.rpc[0] || "",
        testnet: apiChain.testnet === true ? true : undefined,
        nativeCurrency: apiChain.nativeCurrency,
        blockExplorers: apiChain.explorers?.map((explorer) => {
            return {
                name: explorer.name,
                url: explorer.url,
                apiUrl: explorer.url,
            };
        }),
        faucets: apiChain.faucets ? [...apiChain.faucets] : undefined,
        icon: apiChain.icon,
    };
}
function createChainMetadata(chain, data) {
    const nativeCurrency = chain.nativeCurrency
        ? {
            ...data?.nativeCurrency,
            ...chain.nativeCurrency,
        }
        : data?.nativeCurrency;
    return {
        ...data,
        name: chain.name || data?.name || "",
        chainId: chain.id || data?.chainId || -1,
        rpc: chain.rpc ? [chain.rpc] : data?.rpc || [""],
        testnet: chain.testnet || data?.testnet || false,
        nativeCurrency: {
            name: nativeCurrency?.name || "",
            symbol: nativeCurrency?.symbol || "",
            decimals: nativeCurrency?.decimals || 18,
        },
        icon: chain.icon || data?.icon,
        chain: data?.chain || chain.name || "",
        shortName: data?.shortName || chain.name || "",
        slug: data?.slug || chain.name || "",
        explorers: chain.blockExplorers?.map((e) => ({
            name: e.name,
            url: e.url,
            standard: "EIP3091",
        })) || data?.explorers,
    };
}
//# sourceMappingURL=utils.js.map