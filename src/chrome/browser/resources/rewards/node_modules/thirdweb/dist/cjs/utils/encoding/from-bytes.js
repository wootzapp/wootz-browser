"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBytes = fromBytes;
exports.bytesToBigInt = bytesToBigInt;
exports.bytesToBool = bytesToBool;
exports.bytesToNumber = bytesToNumber;
exports.bytesToString = bytesToString;
const assert_size_js_1 = require("./helpers/assert-size.js");
const trim_js_1 = require("./helpers/trim.js");
const hex_js_1 = require("./hex.js");
/**
 * Converts a Uint8Array to the specified type.
 * @param bytes - The Uint8Array to convert.
 * @param toOrOpts - The target type or conversion options.
 * @returns The converted value of the specified type.
 * @example
 * ```ts
 * import { fromBytes } from "thirdweb/utils";
 * const bytes = new Uint8Array([1, 164]);
 * const number = fromBytes(bytes, "number");
 * console.log(number); // 420
 * ```
 * @utils
 */
function fromBytes(bytes, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    switch (opts.to) {
        case "number":
            return bytesToNumber(bytes, opts);
        case "bigint":
            return bytesToBigInt(bytes, opts);
        case "boolean":
            return bytesToBool(bytes, opts);
        case "string":
            return bytesToString(bytes, opts);
        default:
            return (0, hex_js_1.uint8ArrayToHex)(bytes, opts);
    }
}
/**
 * Converts a Uint8Array of bytes to a bigint.
 * @param bytes - The Uint8Array of bytes to convert.
 * @param opts - Optional parameters for the conversion.
 * @returns The converted bigint.
 * @example
 * ```ts
 * import { bytesToBigInt } from "thirdweb/utils";
 * const bytes = new Uint8Array([1, 164]);
 * const bigInt = bytesToBigInt(bytes);
 * console.log(bigInt); // 420n
 * ```
 * @utils
 */
function bytesToBigInt(bytes, opts = {}) {
    if (typeof opts.size !== "undefined") {
        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
    }
    const hex = (0, hex_js_1.uint8ArrayToHex)(bytes, opts);
    return (0, hex_js_1.hexToBigInt)(hex, opts);
}
/**
 * Converts a byte array to a boolean value.
 * @param bytes_ - The byte array to convert.
 * @param opts - Optional parameters for the conversion.
 * @returns The boolean value converted from the byte array.
 * @throws Error if the byte array is invalid or the boolean representation is invalid.
 * @example
 * ```ts
 * import { bytesToBool } from "thirdweb/utils";
 * const bytes = new Uint8Array([1]);
 * const bool = bytesToBool(bytes);
 * console.log(bool); // true
 * ```
 * @utils
 */
function bytesToBool(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== "undefined") {
        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
    }
    if (bytes.length > 1 || (bytes[0] && bytes[0] > 1)) {
        throw new Error(`Invalid boolean representation: ${bytes}`);
    }
    return Boolean(bytes[0]);
}
/**
 * Converts a Uint8Array of bytes to a number.
 * @param bytes - The Uint8Array of bytes to convert.
 * @param opts - Optional configuration options.
 * @returns The converted number.
 * @example
 * ```ts
 * import { bytesToNumber } from "thirdweb/utils";
 * const bytes = new Uint8Array([1, 164]);
 * const number = bytesToNumber(bytes);
 * console.log(number); // 420
 * ```
 * @utils
 */
function bytesToNumber(bytes, opts = {}) {
    if (typeof opts.size !== "undefined") {
        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
    }
    const hex = (0, hex_js_1.uint8ArrayToHex)(bytes, opts);
    return (0, hex_js_1.hexToNumber)(hex, opts);
}
/**
 * Converts an array of bytes to a string using UTF-8 encoding.
 * @param bytes_ - The array of bytes to convert.
 * @param opts - Optional parameters for the conversion.
 * @returns The resulting string.
 * @example
 * ```ts
 * import { bytesToString } from "thirdweb/utils";
 * const bytes = new Uint8Array([72, 101, 108, 108, 111]);
 * const string = bytesToString(bytes);
 * console.log(string); // "Hello"
 * ```
 * @utils
 */
function bytesToString(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== "undefined") {
        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
    }
    return new TextDecoder().decode(bytes);
}
//# sourceMappingURL=from-bytes.js.map