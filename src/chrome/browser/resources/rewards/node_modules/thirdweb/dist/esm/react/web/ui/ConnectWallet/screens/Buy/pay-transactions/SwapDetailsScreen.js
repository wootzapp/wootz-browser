import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { ExternalLinkIcon } from "@radix-ui/react-icons";
import { getCachedChain } from "../../../../../../../chains/utils.js";
import { shortenAddress } from "../../../../../../../utils/address.js";
import { fontSize, iconSize, spacing, } from "../../../../../../core/design-system/index.js";
import { useChainExplorers, useChainName, } from "../../../../../../core/hooks/others/useChainQuery.js";
import { useBuyWithCryptoStatus } from "../../../../../../core/hooks/pay/useBuyWithCryptoStatus.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Container, Line, ModalHeader } from "../../../../components/basic.js";
import { ButtonLink } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { formatSeconds } from "../swap/formatSeconds.js";
import { TokenInfoRow } from "./TokenInfoRow.js";
import { getBuyWithCryptoStatusMeta } from "./statusMeta.js";
export function SwapDetailsScreen(props) {
    const { status: initialStatus, client } = props;
    const statusQuery = useBuyWithCryptoStatus(initialStatus.source?.transactionHash
        ? {
            client: client,
            transactionHash: initialStatus.source.transactionHash,
        }
        : undefined);
    const status = (statusQuery.data?.status !== "NOT_FOUND" ? statusQuery.data : undefined) ||
        initialStatus;
    return (_jsxs(Container, { children: [_jsx(Container, { p: "lg", children: _jsx(ModalHeader, { title: "Transaction Details", onBack: props.onBack }) }), _jsx(Line, {}), _jsx(Container, { p: "lg", children: _jsx(SwapTxDetailsTable, { type: "status", status: status, client: client }) })] }));
}
export function SwapTxDetailsTable(props) {
    let uiData;
    let showStatusRow = true;
    let isTransfer = false;
    if (props.type === "status") {
        isTransfer = props.status.swapType === "TRANSFER";
        const status = props.status;
        if (props.hideStatusRow) {
            showStatusRow = false;
        }
        const isPartialSuccess = status.status === "COMPLETED" && status.subStatus === "PARTIAL_SUCCESS";
        uiData = {
            fromToken: {
                chainId: status.quote.fromToken.chainId,
                symbol: status.quote.fromToken.symbol || "",
                address: status.quote.fromToken.tokenAddress,
                amount: status.quote.fromAmount,
            },
            quotedToToken: {
                chainId: status.quote.toToken.chainId,
                symbol: status.quote.toToken.symbol || "",
                address: status.quote.toToken.tokenAddress,
                amount: status.quote.toAmount,
            },
            gotToken: status.destination
                ? {
                    chainId: status.destination.token.chainId,
                    symbol: status.destination.token.symbol || "",
                    address: status.destination.token.tokenAddress,
                    amount: status.destination.amount,
                }
                : undefined,
            statusMeta: getBuyWithCryptoStatusMeta(status),
            estimatedDuration: status.quote.estimated.durationSeconds || 0,
            isPartialSuccess,
            destinationTxHash: status.destination?.transactionHash,
            sourceTxHash: status.source?.transactionHash,
            fromAddress: status.fromAddress,
            toAddress: status.toAddress,
        };
    }
    else {
        const quote = props.quote;
        uiData = {
            fromToken: {
                chainId: quote.swapDetails.fromToken.chainId,
                symbol: quote.swapDetails.fromToken.symbol || "",
                address: quote.swapDetails.fromToken.tokenAddress,
                amount: quote.swapDetails.fromAmount,
            },
            quotedToToken: {
                chainId: quote.swapDetails.toToken.chainId,
                symbol: quote.swapDetails.toToken.symbol || "",
                address: quote.swapDetails.toToken.tokenAddress,
                amount: quote.swapDetails.toAmount,
            },
            isPartialSuccess: false,
            estimatedDuration: quote.swapDetails.estimated.durationSeconds || 0,
            fromAddress: quote.swapDetails.fromAddress,
            toAddress: quote.swapDetails.toAddress,
        };
    }
    const { client } = props;
    const { fromToken, quotedToToken: toToken, statusMeta, sourceTxHash, destinationTxHash, isPartialSuccess, gotToken, estimatedDuration, } = uiData;
    const fromChainId = fromToken.chainId;
    const toChainId = toToken.chainId;
    const fromChainName = useChainName(getCachedChain(fromChainId));
    const fromChainExplorers = useChainExplorers(getCachedChain(fromChainId));
    const toChainName = useChainName(getCachedChain(toChainId));
    const toChainExplorers = useChainExplorers(getCachedChain(toChainId));
    const lineSpacer = (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "md" }), _jsx(Line, {}), _jsx(Spacer, { y: "md" })] }));
    if (isTransfer) {
        return (_jsx("div", { children: fromChainExplorers.explorers?.[0]?.url && sourceTxHash && (_jsxs(ButtonLink, { fullWidth: true, variant: "outline", href: `${fromChainExplorers.explorers[0].url}/tx/${sourceTxHash}`, target: "_blank", gap: "xs", style: {
                    fontSize: fontSize.sm,
                    padding: spacing.sm,
                }, children: ["View on ", fromChainName.name, " Explorer", _jsx(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] })) }));
    }
    return (_jsxs("div", { children: [isPartialSuccess && gotToken ? (
            // Expected + Got
            _jsxs(_Fragment, { children: [_jsx(TokenInfoRow, { chainId: toToken.chainId, client: client, label: isPartialSuccess ? "Expected" : "Received", tokenAmount: toToken.amount, tokenSymbol: toToken.symbol || "", tokenAddress: toToken.address }), lineSpacer, _jsx(TokenInfoRow, { chainId: gotToken.chainId, client: client, label: "Got", tokenAmount: gotToken.amount, tokenSymbol: gotToken.symbol || "", tokenAddress: gotToken.address })] })) : (
            // Receive
            _jsx(TokenInfoRow, { chainId: toToken.chainId, client: client, label: "Receive", tokenAmount: toToken.amount, tokenSymbol: toToken.symbol || "", tokenAddress: toToken.address })), lineSpacer, _jsx(TokenInfoRow, { chainId: fromToken.chainId, client: client, label: "Pay", tokenAmount: fromToken.amount, tokenSymbol: fromToken.symbol || "", tokenAddress: fromToken.address }), lineSpacer, _jsxs(Container, { flex: "row", center: "y", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { children: " Time " }), _jsx(Container, { flex: "row", gap: "xs", center: "y", children: _jsxs(Text, { color: "primaryText", children: ["~", formatSeconds(estimatedDuration || 0)] }) })] }), statusMeta && showStatusRow && (_jsxs(_Fragment, { children: [lineSpacer, _jsxs(Container, { flex: "row", center: "y", style: {
                            justifyContent: "space-between",
                        }, children: [_jsx(Text, { children: "Status" }), _jsx(Container, { flex: "row", gap: "xs", center: "y", children: _jsx(Text, { color: statusMeta.color, children: statusMeta.status }) })] })] })), uiData.fromAddress.toLowerCase() !== uiData.toAddress.toLowerCase() && (_jsxs(_Fragment, { children: [lineSpacer, _jsxs(Container, { flex: "row", center: "y", style: {
                            justifyContent: "space-between",
                        }, children: [_jsx(Text, { children: "Send to" }), _jsx(Container, { flex: "row", gap: "xs", center: "y", children: _jsx(Text, { color: "primaryText", size: "sm", children: shortenAddress(uiData.toAddress) }) })] })] })), lineSpacer, fromChainExplorers.explorers?.[0]?.url && sourceTxHash && (_jsxs(ButtonLink, { fullWidth: true, variant: "outline", href: `${fromChainExplorers.explorers[0].url}/tx/${sourceTxHash}`, target: "_blank", gap: "xs", style: {
                    fontSize: fontSize.sm,
                    padding: spacing.sm,
                }, children: ["View on ", fromChainName.name, " Explorer", _jsx(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] })), destinationTxHash &&
                sourceTxHash !== destinationTxHash &&
                toChainExplorers?.explorers?.[0]?.url && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "sm" }), _jsxs(ButtonLink, { fullWidth: true, variant: "outline", href: `${toChainExplorers.explorers[0].url}/tx/${destinationTxHash}`, target: "_blank", gap: "xs", style: {
                            fontSize: fontSize.sm,
                            padding: spacing.sm,
                        }, children: ["View on ", toChainName.name, " Explorer", _jsx(ExternalLinkIcon, { width: iconSize.sm, height: iconSize.sm })] })] }))] }));
}
//# sourceMappingURL=SwapDetailsScreen.js.map