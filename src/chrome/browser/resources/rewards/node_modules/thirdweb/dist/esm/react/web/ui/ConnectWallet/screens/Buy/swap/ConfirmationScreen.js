import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { CrossCircledIcon } from "@radix-ui/react-icons";
import { useState } from "react";
import { trackPayEvent } from "../../../../../../../analytics/track.js";
import { sendTransaction } from "../../../../../../../transaction/actions/send-transaction.js";
import { waitForReceipt } from "../../../../../../../transaction/actions/wait-for-tx-receipt.js";
import { shortenAddress } from "../../../../../../../utils/address.js";
import { formatNumber } from "../../../../../../../utils/formatNumber.js";
import { useCustomTheme } from "../../../../../../core/design-system/CustomThemeProvider.js";
import { fontSize, iconSize, } from "../../../../../../core/design-system/index.js";
import { useChainName } from "../../../../../../core/hooks/others/useChainQuery.js";
import { useEnsName } from "../../../../../../core/utils/wallet.js";
import { Skeleton } from "../../../../components/Skeleton.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { StepBar } from "../../../../components/StepBar.js";
import { SwitchNetworkButton } from "../../../../components/SwitchNetwork.js";
import { Container, Line, ModalHeader } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { StyledDiv } from "../../../../design-system/elements.js";
import { PayTokenIcon } from "../PayTokenIcon.js";
import { Step } from "../Stepper.js";
import { formatSeconds } from "./formatSeconds.js";
import { addPendingTx } from "./pendingSwapTx.js";
/**
 * @internal
 */
export function SwapConfirmationScreen(props) {
    const isApprovalRequired = props.quote.approval !== undefined;
    const initialStep = isApprovalRequired ? "approval" : "swap";
    const [step, setStep] = useState(initialStep);
    const [status, setStatus] = useState("idle");
    const receiver = props.quote.swapDetails.toAddress;
    const sender = props.quote.swapDetails.fromAddress;
    const isDifferentRecipient = receiver.toLowerCase() !== sender.toLowerCase();
    const ensName = useEnsName({ client: props.client, address: receiver });
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: props.title, onBack: props.onBack }), props.isFiatFlow ? (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "lg" }), _jsx(StepBar, { steps: 2, currentStep: 2 }), _jsx(Spacer, { y: "sm" }), _jsxs(Text, { size: "xs", children: ["Step 2 of 2 - Converting ", props.fromTokenSymbol, " to", props.toTokenSymbol] }), _jsx(Spacer, { y: "md" })] })) : (_jsx(Spacer, { y: "lg" })), _jsx(ConfirmItem, { label: "Pay", children: _jsx(RenderTokenInfo, { chain: props.fromChain, amount: String(formatNumber(Number(props.fromAmount), 6)), symbol: props.fromTokenSymbol || "", token: props.fromToken, client: props.client }) }), !isDifferentRecipient && (_jsx(ConfirmItem, { label: "Receive", children: _jsx(RenderTokenInfo, { chain: props.toChain, amount: String(formatNumber(Number(props.toAmount), 6)), symbol: props.toTokenSymbol, token: props.toToken, client: props.client }) })), _jsx(ConfirmItem, { label: "Fees", children: _jsx(SwapFeesRightAligned, { quote: props.quote }) }), _jsx(ConfirmItem, { label: "Time", children: _jsxs(Text, { size: "sm", color: "primaryText", children: ["~", formatSeconds(props.quote.swapDetails.estimated.durationSeconds || 0)] }) }), isDifferentRecipient && (_jsx(ConfirmItem, { label: "Receiver", children: _jsx(Text, { color: "primaryText", size: "sm", children: ensName.data || shortenAddress(receiver) }) })), _jsx(Spacer, { y: "xl" }), isApprovalRequired && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "sm" }), _jsxs(Container, { gap: "sm", flex: "row", style: {
                            justifyContent: "space-between",
                        }, center: "y", color: "accentText", children: [_jsx(Step, { isDone: step === "swap", isActive: step === "approval", label: step === "approval" ? "Approve" : "Approved" }), _jsx(ConnectorLine, {}), _jsx(Step, { isDone: false, label: "Confirm", isActive: step === "swap" })] }), _jsx(Spacer, { y: "lg" })] })), status === "error" && (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "xs", center: "both", color: "danger", children: [_jsx(CrossCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: "danger", size: "sm", children: step === "approval" ? "Failed to Approve" : "Failed to Confirm" })] }), _jsx(Spacer, { y: "md" })] })), props.payer.chain.id !== props.fromChain.id ? (_jsx(SwitchNetworkButton, { fullWidth: true, variant: "accent", switchChain: async () => {
                    await props.payer.wallet.switchChain(props.fromChain);
                } })) : (_jsxs(Button, { variant: "accent", fullWidth: true, disabled: status === "pending", onClick: async () => {
                    if (step === "approval" && props.quote.approval) {
                        try {
                            setStatus("pending");
                            trackPayEvent({
                                event: "prompt_swap_approval",
                                client: props.client,
                                walletAddress: props.payer.account.address,
                                walletType: props.payer.wallet.id,
                                fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                fromAmount: props.quote.swapDetails.fromAmountWei,
                                toToken: props.quote.swapDetails.toToken.tokenAddress,
                                toAmount: props.quote.swapDetails.toAmountWei,
                                chainId: props.quote.swapDetails.fromToken.chainId,
                                dstChainId: props.quote.swapDetails.toToken.chainId,
                            });
                            const tx = await sendTransaction({
                                account: props.payer.account,
                                transaction: props.quote.approval,
                            });
                            await waitForReceipt({ ...tx, maxBlocksWaitTime: 50 });
                            // props.onQuoteFinalized(props.quote);
                            trackPayEvent({
                                event: "swap_approval_success",
                                client: props.client,
                                walletAddress: props.payer.account.address,
                                walletType: props.payer.wallet.id,
                                fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                fromAmount: props.quote.swapDetails.fromAmountWei,
                                toToken: props.quote.swapDetails.toToken.tokenAddress,
                                toAmount: props.quote.swapDetails.toAmountWei,
                                chainId: props.quote.swapDetails.fromToken.chainId,
                                dstChainId: props.quote.swapDetails.toToken.chainId,
                            });
                            setStep("swap");
                            setStatus("idle");
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                    if (step === "swap") {
                        setStatus("pending");
                        try {
                            let tx = props.quote.transactionRequest;
                            // Fix for inApp wallet
                            // Ideally - the pay server sends a non-legacy transaction to avoid this issue
                            if (props.payer.wallet.id === "inApp" ||
                                props.payer.wallet.id === "embedded") {
                                tx = {
                                    ...props.quote.transactionRequest,
                                    gasPrice: undefined,
                                };
                            }
                            trackPayEvent({
                                event: "prompt_swap_execution",
                                client: props.client,
                                walletAddress: props.payer.account.address,
                                walletType: props.payer.wallet.id,
                                fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                fromAmount: props.quote.swapDetails.fromAmountWei,
                                toToken: props.quote.swapDetails.toToken.tokenAddress,
                                toAmount: props.quote.swapDetails.toAmountWei,
                                chainId: props.quote.swapDetails.fromToken.chainId,
                                dstChainId: props.quote.swapDetails.toToken.chainId,
                            });
                            const _swapTx = await sendTransaction({
                                account: props.payer.account,
                                transaction: tx,
                            });
                            await waitForReceipt({ ..._swapTx, maxBlocksWaitTime: 50 });
                            trackPayEvent({
                                event: "swap_execution_success",
                                client: props.client,
                                walletAddress: props.payer.account.address,
                                walletType: props.payer.wallet.id,
                                fromToken: props.quote.swapDetails.fromToken.tokenAddress,
                                fromAmount: props.quote.swapDetails.fromAmountWei,
                                toToken: props.quote.swapDetails.toToken.tokenAddress,
                                toAmount: props.quote.swapDetails.toAmountWei,
                                chainId: props.quote.swapDetails.toToken.chainId,
                                dstChainId: props.quote.swapDetails.toToken.chainId,
                            });
                            // do not add pending tx if the swap is part of fiat flow
                            if (!props.isFiatFlow) {
                                addPendingTx({
                                    type: "swap",
                                    txHash: _swapTx.transactionHash,
                                });
                            }
                            props.setSwapTxHash(_swapTx.transactionHash);
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                }, gap: "xs", children: [step === "approval" &&
                        (status === "pending" ? "Approving" : "Approve"), step === "swap" && (status === "pending" ? "Confirming" : "Confirm"), status === "pending" && (_jsx(Spinner, { size: "sm", color: "accentButtonText" }))] }))] }));
}
export const ConnectorLine = /* @__PURE__ */ StyledDiv(() => {
    const theme = useCustomTheme();
    return {
        height: "4px",
        background: theme.colors.borderColor,
        flex: 1,
    };
});
function RenderTokenInfo(props) {
    const { name } = useChainName(props.chain);
    return (_jsxs(Container, { flex: "column", gap: "xxs", style: {
            alignItems: "flex-end",
        }, children: [_jsxs(Container, { flex: "row", center: "y", gap: "xs", children: [_jsxs(Text, { color: "primaryText", size: "sm", children: [props.amount, " ", props.symbol] }), _jsx(PayTokenIcon, { token: props.token, chain: props.chain, size: "xs", client: props.client })] }), name ? (_jsx(Text, { size: "xs", children: name })) : (_jsx(Skeleton, { width: "100px", height: fontSize.xs }))] }));
}
function ConfirmItem(props) {
    return (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "md", py: "md", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "sm", color: "secondaryText", children: props.label }), props.children] }), _jsx(Line, {})] }));
}
/**
 * @internal
 */
function SwapFeesRightAligned(props) {
    return (_jsx(Container, { flex: "column", gap: "xs", style: {
            alignItems: "flex-end",
        }, children: props.quote.processingFees.map((fee) => {
            const feeAmount = formatNumber(Number(fee.amount), 6);
            return (_jsxs(Container, { flex: "row", gap: "xxs", children: [_jsxs(Text, { color: "primaryText", size: "sm", children: [feeAmount === 0 ? "~" : "", feeAmount, " ", fee.token.symbol] }), _jsxs(Text, { color: "secondaryText", size: "sm", children: ["($", (fee.amountUSDCents / 100).toFixed(2), ")"] })] }, `${fee.token.chainId}_${fee.token.tokenAddress}_${feeAmount}`));
        }) }));
}
//# sourceMappingURL=ConfirmationScreen.js.map