"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainButton = void 0;
exports.NetworkSelectorContent = NetworkSelectorContent;
exports.useNetworkSwitcherModal = useNetworkSwitcherModal;
const jsx_runtime_1 = require("react/jsx-runtime");
const styled_1 = require("@emotion/styled");
const react_icons_1 = require("@radix-ui/react-icons");
const fuse_js_1 = require("fuse.js");
const react_1 = require("react");
const utils_js_1 = require("../../../../chains/utils.js");
const CustomThemeProvider_js_1 = require("../../../core/design-system/CustomThemeProvider.js");
const index_js_1 = require("../../../core/design-system/index.js");
const useChainQuery_js_1 = require("../../../core/hooks/others/useChainQuery.js");
const useActiveWalletChain_js_1 = require("../../../core/hooks/wallets/useActiveWalletChain.js");
const useSwitchActiveWalletChain_js_1 = require("../../../core/hooks/wallets/useSwitchActiveWalletChain.js");
const RootElementContext_js_1 = require("../../../core/providers/RootElementContext.js");
const ChainIcon_js_1 = require("../components/ChainIcon.js");
const Modal_js_1 = require("../components/Modal.js");
const Skeleton_js_1 = require("../components/Skeleton.js");
const Spacer_js_1 = require("../components/Spacer.js");
const Spinner_js_1 = require("../components/Spinner.js");
const basic_js_1 = require("../components/basic.js");
const buttons_js_1 = require("../components/buttons.js");
const formElements_js_1 = require("../components/formElements.js");
const modalElements_js_1 = require("../components/modalElements.js");
const text_js_1 = require("../components/text.js");
const elements_js_1 = require("../design-system/elements.js");
const useDebouncedValue_js_1 = require("../hooks/useDebouncedValue.js");
const useShowMore_js_1 = require("../hooks/useShowMore.js");
const getConnectLocale_js_1 = require("./locale/getConnectLocale.js");
/**
 * @internal
 */
function NetworkSelectorContent(props) {
    const locale = props.connectLocale.networkSelector;
    const [searchTerm, setSearchTerm] = (0, react_1.useState)("");
    const [selectedTab, setSelectedTab] = (0, react_1.useState)("all");
    const deferredSearchTerm = (0, useDebouncedValue_js_1.useDebouncedValue)(searchTerm, 300);
    const { onSwitch, onCustomClick } = props.networkSelector || {};
    // labels
    const othersLabel = locale.categoryLabel.others;
    const popularLabel = locale.categoryLabel.popular;
    const recentLabel = locale.categoryLabel.recentlyUsed;
    // create sections, chainToSectionMap and allChains
    const { chainSections, allChains, allChainsToSectionMap } = (0, react_1.useMemo)(() => {
        const chainSectionsValue = [];
        const allChainsValue = [];
        const allChainsToSectionMapValue = new Map();
        function addChain(c, section) {
            allChainsToSectionMapValue.set(c.id, section);
            allChainsValue.push(c);
        }
        // if new API is used
        if (props.networkSelector?.sections) {
            for (const s of props.networkSelector.sections) {
                const chainsToAdd = s.chains.filter((c) => !allChainsToSectionMapValue.has(c.id));
                if (chainsToAdd.length > 0) {
                    chainSectionsValue.push({
                        label: s.label,
                        chains: chainsToAdd,
                    });
                    for (const c of chainsToAdd) {
                        addChain(c, s.label);
                    }
                }
            }
        }
        // if old API is used
        else {
            const allChainsMap = new Map(props.chains.map((c) => [c.id, c]));
            // add all recent chains
            if (props.networkSelector?.recentChainIds &&
                props.networkSelector?.recentChainIds.length > 0) {
                const recentChains = props.networkSelector.recentChainIds
                    .map((id) => allChainsMap.get(id))
                    .filter((c) => c !== undefined);
                chainSectionsValue.push({
                    label: recentLabel,
                    chains: recentChains,
                });
                for (const c of recentChains) {
                    addChain(c, recentLabel);
                }
            }
            // then add all popular chains ( exclude already added chains )
            if (props.networkSelector?.popularChainIds &&
                props.networkSelector.popularChainIds.length > 0) {
                const popularChains = props.networkSelector.popularChainIds
                    .map((id) => allChainsMap.get(id))
                    .filter((c) => c !== undefined);
                const chainsToAdd = popularChains.filter((c) => !allChainsToSectionMapValue.has(c.id));
                if (chainsToAdd.length > 0) {
                    chainSectionsValue.push({
                        label: popularLabel,
                        chains: chainsToAdd,
                    });
                    for (const c of chainsToAdd) {
                        addChain(c, popularLabel);
                    }
                }
            }
        }
        // add all other chains ( exclude already added chains )
        const otherChainsToAdd = props.chains.filter((c) => !allChainsToSectionMapValue.has(c.id));
        if (otherChainsToAdd.length > 0) {
            chainSectionsValue.push({
                label: othersLabel,
                chains: otherChainsToAdd,
            });
            for (const c of otherChainsToAdd) {
                addChain(c, othersLabel);
            }
        }
        return {
            chainSections: chainSectionsValue,
            allChains: allChainsValue,
            allChainsToSectionMap: allChainsToSectionMapValue,
        };
    }, [
        props.networkSelector?.sections,
        props.networkSelector?.recentChainIds,
        props.networkSelector?.popularChainIds,
        props.chains,
        recentLabel,
        popularLabel,
        othersLabel,
    ]);
    // optimizing for dashboard - if we already have names - don't query - we already have the data we want
    const chainsHaveName = allChains.every((c) => !!c.name);
    const allChainsQuery = (0, useChainQuery_js_1.useChainsQuery)(chainsHaveName ? [] : allChains, 10);
    const isAllChainsQueryLoading = chainsHaveName
        ? false
        : allChainsQuery.some((q) => q.isLoading);
    const allChainsMetadata = chainsHaveName
        ? allChains
        : !isAllChainsQueryLoading
            ? allChainsQuery
                .filter((x) => !!x.data)
                .map((q) => (0, utils_js_1.convertApiChainToChain)(q.data))
            : [];
    // fuse instance for searching
    const fuse = (0, react_1.useMemo)(() => {
        return new fuse_js_1.default(allChainsMetadata, {
            threshold: 0.4,
            keys: [
                {
                    name: "name",
                    weight: 1,
                },
                {
                    name: "chainId",
                    weight: 1,
                },
            ],
        });
    }, [allChainsMetadata]);
    // chains filtered by search term
    const searchedChainSections = (0, react_1.useMemo)(() => {
        if (deferredSearchTerm === "") {
            return undefined;
        }
        const filteredChainSectionsValue = [];
        const filteredAllChains = fuse
            .search(deferredSearchTerm)
            .map((r) => r.item);
        for (const c of filteredAllChains) {
            const label = allChainsToSectionMap.get(c.id);
            if (!label) {
                return; // just a type guard, this never happens
            }
            const section = filteredChainSectionsValue.find((s) => s.label === label);
            if (section) {
                section.chains.push(c);
            }
            else {
                filteredChainSectionsValue.push({
                    label,
                    chains: [c],
                });
            }
        }
        return filteredChainSectionsValue;
    }, [deferredSearchTerm, fuse, allChainsToSectionMap]) || chainSections;
    const filteredChainSections = (0, react_1.useMemo)(() => {
        if (selectedTab === "all") {
            return searchedChainSections;
        }
        return searchedChainSections.map((section) => ({
            label: section.label,
            chains: section.chains.filter((c) => (selectedTab === "mainnet" && !c.testnet) ||
                (selectedTab === "testnet" && c.testnet)),
        }));
    }, [searchedChainSections, selectedTab]);
    const handleSwitch = (0, react_1.useCallback)((chain) => {
        if (onSwitch) {
            onSwitch(chain);
        }
        props.closeModal();
    }, [onSwitch, props]);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "lg", children: props.onBack ? ((0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: locale.title, onBack: props.onBack })) : ((0, jsx_runtime_1.jsx)(modalElements_js_1.ModalTitle, { children: locale.title })) }), props.showTabs !== false && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { px: "lg", children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xxs", children: [(0, jsx_runtime_1.jsx)(TabButton, { onClick: () => setSelectedTab("all"), "data-active": selectedTab === "all", children: locale.allNetworks }), (0, jsx_runtime_1.jsx)(TabButton, { onClick: () => setSelectedTab("mainnet"), "data-active": selectedTab === "mainnet", children: locale.mainnets }), (0, jsx_runtime_1.jsx)(TabButton, { onClick: () => setSelectedTab("testnet"), "data-active": selectedTab === "testnet", children: locale.testnets })] }) }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] })), props.showTabs === false && (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxs" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { px: "lg", children: (0, jsx_runtime_1.jsxs)("div", { style: {
                        display: "flex",
                        alignItems: "center",
                        position: "relative",
                    }, children: [(0, jsx_runtime_1.jsx)(StyledMagnifyingGlassIcon, { width: index_js_1.iconSize.md, height: index_js_1.iconSize.md }), (0, jsx_runtime_1.jsx)(formElements_js_1.Input, { style: {
                                padding: `${index_js_1.spacing.sm} ${index_js_1.spacing.md} ${index_js_1.spacing.sm} ${index_js_1.spacing.xxl}`,
                            }, tabIndex: -1, variant: "outline", value: searchTerm, onChange: (e) => {
                                setSearchTerm(e.target.value);
                            }, disabled: isAllChainsQueryLoading, placeholder: isAllChainsQueryLoading
                                ? "Loading chains..."
                                : locale.inputPlaceholder }), (deferredSearchTerm !== searchTerm || isAllChainsQueryLoading) && ((0, jsx_runtime_1.jsx)("div", { style: {
                                position: "absolute",
                                right: index_js_1.spacing.md,
                            }, children: (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "md", color: "accentText" }) }))] }) }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { px: "md", children: (0, jsx_runtime_1.jsx)(NetworkTabContent, { chainSections: filteredChainSections, onSwitch: handleSwitch, renderChain: props.networkSelector?.renderChain, connectLocale: props.connectLocale, client: props.client, close: props.closeModal }) }), onCustomClick && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(basic_js_1.Line, {}), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "lg", children: (0, jsx_runtime_1.jsx)(buttons_js_1.Button, { fullWidth: true, variant: "link", onClick: () => {
                                onCustomClick();
                                props.closeModal();
                            }, style: {
                                display: "flex",
                                fontSize: index_js_1.fontSize.sm,
                                boxShadow: "none",
                            }, children: locale.addCustomNetwork }) })] }))] }));
}
/**
 *
 * @internal
 */
const NetworkTabContent = (props) => {
    const { chainSections } = props;
    const noChainsToShow = chainSections.every((section) => section.chains.length === 0);
    return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { scrollY: true, animate: "fadein", style: {
            height: "330px",
            paddingBottom: index_js_1.spacing.lg,
        }, children: noChainsToShow ? ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "md", center: "both", color: "secondaryText", children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(react_icons_1.CrossCircledIcon, { width: index_js_1.iconSize.xl, height: index_js_1.iconSize.xl }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { children: " No Results " })] })) : (chainSections.map((section, idx) => {
            if (section.chains.length === 0) {
                return null;
            }
            return ((0, jsx_runtime_1.jsxs)(react_1.Fragment, { children: [idx !== 0 && (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(SectionLabel, { children: section.label }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xs" }), (0, jsx_runtime_1.jsx)(NetworkList, { chains: section.chains, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale })] }, section.label));
        })) }));
};
const NetworkList = /* @__PURE__ */ (0, react_1.memo)(function NetworkList(props) {
    // show 10 items first, when reaching the last item, show 10 more
    const { itemsToShow, lastItemRef } = (0, useShowMore_js_1.useShowMore)(10, 10);
    const switchChain = (0, useSwitchActiveWalletChain_js_1.useSwitchActiveWalletChain)();
    const activeChain = (0, useActiveWalletChain_js_1.useActiveWalletChain)();
    const [switchingChainId, setSwitchingChainId] = (0, react_1.useState)(-1);
    const [errorSwitchingChainId, setErrorSwitchingChainId] = (0, react_1.useState)(-1);
    const close = props.close;
    (0, react_1.useEffect)(() => {
        // if switching and switched successfully - close modal
        if (switchingChainId !== -1 && activeChain?.id === switchingChainId) {
            if (close) {
                close();
            }
        }
    }, [switchingChainId, close, activeChain?.id]);
    const handleSwitch = async (chain) => {
        setErrorSwitchingChainId(-1);
        setSwitchingChainId(chain.id);
        try {
            await switchChain(chain);
            props.onSwitch(chain);
        }
        catch (e) {
            setErrorSwitchingChainId(chain.id);
            console.error(e);
        }
        finally {
            setSwitchingChainId(-1);
        }
    };
    const RenderChain = props.renderChain;
    const chainsToShow = props.chains.slice(0, itemsToShow);
    return ((0, jsx_runtime_1.jsx)(NetworkListUl, { children: chainsToShow.map((chain, i) => {
            if (!chain) {
                return null;
            }
            const confirming = switchingChainId === chain.id;
            const switchingFailed = errorSwitchingChainId === chain.id;
            const isLast = i === chainsToShow.length - 1;
            return ((0, jsx_runtime_1.jsx)("li", { ref: isLast ? lastItemRef : undefined, children: RenderChain ? ((0, jsx_runtime_1.jsx)(RenderChain, { switchChain: () => {
                        handleSwitch(chain);
                    }, chain: chain, switching: switchingChainId === chain.id, switchFailed: errorSwitchingChainId === chain.id, close: props.close })) : ((0, jsx_runtime_1.jsx)(exports.ChainButton, { chain: chain, confirming: confirming, onClick: () => handleSwitch(chain), switchingFailed: switchingFailed, client: props.client, connectLocale: props.connectLocale })) }, chain.id));
        }) }));
});
exports.ChainButton = (0, react_1.memo)(function ChainButton(props) {
    const locale = props.connectLocale;
    const { chain, confirming, switchingFailed } = props;
    const activeChain = (0, useActiveWalletChain_js_1.useActiveWalletChain)();
    const chainNameQuery = (0, useChainQuery_js_1.useChainName)(chain);
    const chainIconQuery = (0, useChainQuery_js_1.useChainIconUrl)(chain);
    let chainName;
    if (chainNameQuery.name) {
        chainName = (0, jsx_runtime_1.jsxs)("span", { children: [chainNameQuery.name, " "] });
    }
    else {
        chainName = (0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { width: "150px", height: "20px" });
    }
    return ((0, jsx_runtime_1.jsxs)(NetworkButton, { "data-active": activeChain?.id === chain.id, onClick: props.onClick, children: [!chainIconQuery.isLoading ? ((0, jsx_runtime_1.jsx)(ChainIcon_js_1.ChainIcon, { chainIconUrl: chainIconQuery.url, size: index_js_1.iconSize.lg, active: activeChain?.id === chain.id, loading: "lazy", client: props.client })) : ((0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { width: `${index_js_1.iconSize.lg}px`, height: `${index_js_1.iconSize.lg}px` })), confirming || switchingFailed ? ((0, jsx_runtime_1.jsxs)("div", { style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: index_js_1.spacing.xs,
                }, children: [chainName, (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { animate: "fadein", flex: "row", gap: "xxs", center: "y", children: [confirming && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "accentText", children: locale.confirmInWallet }), (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "xs", color: "accentText" })] })), switchingFailed && ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { animate: "fadein", children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "danger", children: locale.networkSelector.failedToSwitch }) }))] })] })) : (chainName)] }));
});
const TabButton = /* @__PURE__ */ (() => styled_1.default.button((_) => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        all: "unset",
        fontSize: index_js_1.fontSize.sm,
        fontWeight: 500,
        color: theme.colors.secondaryText,
        cursor: "pointer",
        padding: `${index_js_1.spacing.sm} ${index_js_1.spacing.sm}`,
        WebkitTapHighlightColor: "transparent",
        borderRadius: index_js_1.radius.lg,
        transition: "background 0.2s ease, color 0.2s ease",
        "&[data-active='true']": {
            background: theme.colors.secondaryButtonBg,
            color: theme.colors.primaryText,
        },
    };
}))();
const SectionLabel = /* @__PURE__ */ (0, elements_js_1.StyledP)(() => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        fontSize: index_js_1.fontSize.sm,
        color: theme.colors.secondaryText,
        margin: 0,
        display: "block",
        padding: `0 ${index_js_1.spacing.xs}`,
    };
});
const NetworkListUl = /* @__PURE__ */ (0, elements_js_1.StyledUl)({
    padding: 0,
    margin: 0,
    listStyle: "none",
    display: "flex",
    flexDirection: "column",
    gap: index_js_1.spacing.xs,
    boxSizing: "border-box",
});
const NetworkButton = /* @__PURE__ */ (0, elements_js_1.StyledButton)((_) => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        all: "unset",
        display: "flex",
        width: "100%",
        boxSizing: "border-box",
        alignItems: "center",
        gap: index_js_1.spacing.md,
        padding: `${index_js_1.spacing.xs} ${index_js_1.spacing.sm}`,
        borderRadius: index_js_1.radius.md,
        cursor: "pointer",
        transition: "background 0.2s ease",
        color: theme.colors.primaryText,
        fontWeight: 500,
        fontSize: index_js_1.fontSize.md,
        "&:hover": {
            background: theme.colors.secondaryButtonBg,
        },
        [index_js_1.media.mobile]: {
            fontSize: index_js_1.fontSize.sm,
        },
    };
});
const StyledMagnifyingGlassIcon = /* @__PURE__ */ (0, styled_1.default)(react_icons_1.MagnifyingGlassIcon)((_) => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        color: theme.colors.secondaryText,
        position: "absolute",
        left: index_js_1.spacing.sm,
    };
});
/**
 * Hook to open the Wallet Network Switcher Modal that shows allows users to switch to different network.
 *
 * @example
 * ```tsx
 * import { createThirdwebClient } from "thirdweb";
 * import { useNetworkSwitcherModal } from "thirdweb/react";
 * import { base, ethereum, polygon, sepolia, arbitrum } from "thirdweb/chains";
 *
 * const client = createThirdwebClient({
 *  clientId: "<your_client_id>",
 * });
 *
 * function Example() {
 *   const networkSwitcher = useNetworkSwitcherModal();
 *
 *   function handleClick() {
 *      networkSwitcher.open({
 *        client,
 *        theme: 'light'
 *        sections: [
 *          { label: 'Recently used', chains: [arbitrum, polygon] },
 *          { label: 'Popular', chains: [base, ethereum, sepolia] },
 *        ]
 *     });
 *   }
 *
 *   return <button onClick={handleClick}> Switch Network </button>
 * }
 * ```
 * @wallet
 */
function useNetworkSwitcherModal() {
    const activeChain = (0, useActiveWalletChain_js_1.useActiveWalletChain)();
    const setRootEl = (0, react_1.useContext)(RootElementContext_js_1.SetRootElementContext);
    const closeModal = (0, react_1.useCallback)(() => {
        setRootEl(null);
    }, [setRootEl]);
    const openNetworkSwitcher = (0, react_1.useCallback)(async (props) => {
        if (!activeChain) {
            throw new Error("No active wallet found");
        }
        const locale = await (0, getConnectLocale_js_1.getConnectLocale)(props.locale || "en_US");
        setRootEl((0, jsx_runtime_1.jsx)(CustomThemeProvider_js_1.CustomThemeProvider, { theme: props.theme, children: (0, jsx_runtime_1.jsx)(Modal_js_1.Modal, { size: "compact", open: true, setOpen: (value) => {
                    if (!value) {
                        closeModal();
                    }
                }, style: {
                    paddingBottom: props.onCustomClick ? index_js_1.spacing.md : "0px",
                }, children: (0, jsx_runtime_1.jsx)(NetworkSelectorContent, { client: props.client, closeModal: closeModal, chains: [activeChain], connectLocale: locale, networkSelector: {
                        onCustomClick: props.onCustomClick,
                        onSwitch: props.onSwitch,
                        renderChain: props.renderChain,
                        sections: props.sections,
                    } }) }) }));
    }, [setRootEl, closeModal, activeChain]);
    return {
        open: openNetworkSwitcher,
        close: closeModal,
    };
}
//# sourceMappingURL=NetworkSelector.js.map