"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareDeterministicDeployTransaction = prepareDeterministicDeployTransaction;
const prepare_transaction_js_1 = require("../../transaction/prepare-transaction.js");
const compute_published_contract_deploy_info_js_1 = require("../../utils/any-evm/compute-published-contract-deploy-info.js");
const create_2_factory_js_1 = require("./utils/create-2-factory.js");
/**
 * Deploy a contract deterministically - will maintain the same address across chains.
 * This is meant to be used with published contracts configured with the 'direct deploy' method.
 * Under the hood, this uses a keyless transaction with a common create2 factory.
 * @param options - the options to deploy the contract
 * @returns - the transaction to deploy the contract
 * @extension DEPLOY
 * @example
 * ```ts
 * import { prepareDeterministicDeployTransaction } from "thirdweb/deploys";
 * import { sepolia } from "thirdweb/chains";
 *
 * const tx = prepareDeterministicDeployTransaction({
 *  client,
 *  chain: sepolia,
 *  contractId: "AccountFactory",
 *  constructorParams: [123],
 * });
 * ```
 */
function prepareDeterministicDeployTransaction(options) {
    const { client, chain } = options;
    return (0, prepare_transaction_js_1.prepareTransaction)({
        client,
        chain,
        to: () => (0, create_2_factory_js_1.computeCreate2FactoryAddress)({
            client,
            chain,
        }),
        data: async () => {
            const infraContractInfo = await (0, compute_published_contract_deploy_info_js_1.computeDeploymentInfoFromContractId)(options);
            return infraContractInfo.initBytecodeWithsalt;
        },
    });
}
//# sourceMappingURL=deploy-deterministic.js.map