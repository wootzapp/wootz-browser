import { getCachedChain } from "../../chains/utils.js";
import { getContract } from "../../contract/contract.js";
import { approve } from "../../extensions/erc20/write/approve.js";
import { getClientFetch } from "../../utils/fetch.js";
import { getPayBuyWithCryptoTransferEndpoint } from "../utils/definitions.js";
/**
 * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.
 * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.
 *
 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
 * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)
 * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer
 * @example
 *
 * ```ts
 * import { getBuyWithCryptoTransfer } from "thirdweb/pay";
 *
 * const transfer = await getBuyWithCryptoTransfer({
 *  client,
 *  fromAddress: "0x...", // wallet address
 *  toAddress: "0x...", // recipient address - likely to be your wallet
 *  chainId: 10, // chain id of the token
 *  tokenAddress: "0x...", // address of the token
 *  amount: "10", // amount of token to transfer
 *  purchaseData: {  // any metadata for you to attribute this purchase
 *    "customerId": "yourId"
 *  }
 * });
 * ```
 * @buyCrypto
 */
export async function getBuyWithCryptoTransfer(params) {
    try {
        const clientFetch = getClientFetch(params.client);
        const response = await clientFetch(getPayBuyWithCryptoTransferEndpoint(), {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                fromAddress: params.fromAddress,
                toAddress: params.toAddress,
                chainId: params.chainId,
                tokenAddress: params.tokenAddress,
                amount: params.amount,
                purchaseData: params.purchaseData,
            }),
        });
        if (!response.ok) {
            const errorObj = await response.json();
            if (errorObj && "error" in errorObj) {
                throw errorObj;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = (await response.json()).result;
        const transfer = {
            transactionRequest: {
                chain: getCachedChain(data.transactionRequest.chainId),
                client: params.client,
                data: data.transactionRequest.data,
                to: data.transactionRequest.to,
                value: BigInt(data.transactionRequest.value),
                gas: BigInt(data.transactionRequest.gasLimit),
            },
            approval: data.approval
                ? approve({
                    contract: getContract({
                        client: params.client,
                        address: data.approval.tokenAddress,
                        chain: getCachedChain(data.approval.chainId),
                    }),
                    spender: data.approval.spenderAddress,
                    amountWei: BigInt(data.approval.amountWei),
                })
                : undefined,
            fromAddress: data.fromAddress,
            toAddress: data.toAddress,
            paymentToken: data.paymentToken,
            processingFee: data.processingFee,
            estimatedGasCostUSDCents: data.estimatedGasCostUSDCents,
            client: params.client,
        };
        return transfer;
    }
    catch (error) {
        console.error("Error getting buy with crypto transfer", error);
        throw error;
    }
}
//# sourceMappingURL=getTransfer.js.map