"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostOnRampSwap = PostOnRampSwap;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const getPostOnRampQuote_js_1 = require("../../../../../../../pay/buyWithFiat/getPostOnRampQuote.js");
const index_js_1 = require("../../../../../../core/design-system/index.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const text_js_1 = require("../../../../components/text.js");
const AccentFailIcon_js_1 = require("../../../icons/AccentFailIcon.js");
const SwapFlow_js_1 = require("../swap/SwapFlow.js");
function PostOnRampSwap(props) {
    const [lockedOnRampQuote, setLockedOnRampQuote] = (0, react_1.useState)(undefined);
    const postOnRampQuoteQuery = (0, react_query_1.useQuery)({
        queryKey: ["getPostOnRampQuote", props.buyWithFiatStatus],
        queryFn: async () => {
            return await (0, getPostOnRampQuote_js_1.getPostOnRampQuote)({
                client: props.client,
                buyWithFiatStatus: props.buyWithFiatStatus,
            });
        },
        // stop fetching if a quote is already locked
        enabled: !lockedOnRampQuote,
        refetchOnWindowFocus: false,
    });
    (0, react_1.useEffect)(() => {
        if (postOnRampQuoteQuery.data &&
            !lockedOnRampQuote &&
            !postOnRampQuoteQuery.isRefetching) {
            setLockedOnRampQuote(postOnRampQuoteQuery.data);
        }
    }, [
        postOnRampQuoteQuery.data,
        lockedOnRampQuote,
        postOnRampQuoteQuery.isRefetching,
    ]);
    if (postOnRampQuoteQuery.isError) {
        return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { fullHeight: true, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "lg", children: (0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { style: {
                        minHeight: "300px",
                    }, flex: "column", center: "both", p: "lg", children: [(0, jsx_runtime_1.jsx)(AccentFailIcon_js_1.AccentFailIcon, { size: index_js_1.iconSize["3xl"] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "primaryText", children: "Failed to get a price quote" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(buttons_js_1.Button, { fullWidth: true, variant: "primary", onClick: () => {
                                postOnRampQuoteQuery.refetch();
                            }, children: "Try Again" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxl" })] }));
    }
    if (!lockedOnRampQuote) {
        return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { fullHeight: true, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "lg", children: (0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { style: {
                        minHeight: "300px",
                    }, flex: "column", center: "both", children: [(0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "xxl", color: "accentText" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "primaryText", children: "Getting price quote" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xxl" })] }));
    }
    return ((0, jsx_runtime_1.jsx)(SwapFlow_js_1.SwapFlow, { title: props.title, payer: props.payer, buyWithCryptoQuote: lockedOnRampQuote, client: props.client, onBack: props.onBack, isFiatFlow: true, onDone: props.onDone, onTryAgain: () => {
            setLockedOnRampQuote(undefined);
            postOnRampQuoteQuery.refetch();
        }, transactionMode: props.transactionMode, isEmbed: props.isEmbed, onSuccess: props.onSuccess }));
}
//# sourceMappingURL=PostOnRampSwap.js.map