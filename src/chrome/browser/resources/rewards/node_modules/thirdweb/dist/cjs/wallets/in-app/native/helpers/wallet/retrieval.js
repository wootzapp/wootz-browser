"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExistingUserAccount = getExistingUserAccount;
exports.getAccountAddressFromShares = getAccountAddressFromShares;
exports.setUpShareForNewDevice = setUpShareForNewDevice;
const hex_js_1 = require("../../../../../utils/encoding/hex.js");
const private_key_js_1 = require("../../../../private-key.js");
const fetchers_js_1 = require("../api/fetchers.js");
const constants_js_1 = require("../constants.js");
const local_js_1 = require("../storage/local.js");
const creation_js_1 = require("./creation.js");
const encryption_js_1 = require("./encryption.js");
/**
 * For users on a known device and logged in.
 * Will throw if called on a new device // user not logged in
 */
async function getExistingUserAccount(args) {
    const { client } = args;
    const { authShare, deviceShare } = await getShares({
        client,
        authShare: { toRetrieve: true },
        deviceShare: { toRetrieve: true },
        recoveryShare: { toRetrieve: false },
    });
    return getAccountFromShares({
        client,
        shares: [authShare, deviceShare],
    });
}
async function getWalletPrivateKeyFromShares(shares) {
    const sss = await Promise.resolve().then(() => require("./sss.js"));
    let privateKeyHex = sss.secrets.combine(shares, 0);
    if (!(0, hex_js_1.isHex)(privateKeyHex)) {
        privateKeyHex = `0x${privateKeyHex}`;
    }
    const prefixPrivateKey = (0, hex_js_1.hexToString)(privateKeyHex);
    if (!prefixPrivateKey.startsWith("thirdweb_")) {
        throw new Error("Invalid private key reconstructed from shares");
    }
    const privateKey = prefixPrivateKey.replace("thirdweb_", "");
    return privateKey;
}
async function getAccountFromShares(args) {
    const { client, shares } = args;
    return (0, private_key_js_1.privateKeyToAccount)({
        client,
        privateKey: await getWalletPrivateKeyFromShares(shares),
    });
}
/**
 *
 * @param deviceShare - retrieves the current share associated with the user's device.
 * @returns The requested shares
 * @throws if attempting to get deviceShare when it's not present
 */
async function getShares({ client, authShare, deviceShare, recoveryShare, }) {
    const queryParams = {};
    if (authShare.toRetrieve) {
        queryParams.getEncryptedAuthShare = true;
    }
    else {
        queryParams.getEncryptedAuthShare = false;
    }
    if (recoveryShare.toRetrieve) {
        queryParams.getEncryptedRecoveryShare = true;
        if (!recoveryShare.recoveryCode) {
            // purposely using a vague name to prevent people from inspecting url from figuring out what it does
            // so as to not cause huge debates on the technicality of the custodial // non-custodial
            queryParams.useSealedSecret = true;
        }
        else {
            queryParams.useSealedSecret = false;
        }
    }
    else {
        queryParams.getEncryptedRecoveryShare = false;
        queryParams.useSealedSecret = false;
    }
    const getShareUrl = new URL(constants_js_1.ROUTE_GET_USER_SHARES);
    for (const queryKey of Object.keys(queryParams)) {
        getShareUrl.searchParams.append(queryKey, queryParams[queryKey]?.toString() || "");
    }
    const userShares = await (0, fetchers_js_1.getUserShares)(client, getShareUrl);
    const { authShare: _authShare, maybeEncryptedRecoveryShares } = userShares;
    let recoverShareToReturn;
    if (recoveryShare.toRetrieve) {
        if (!maybeEncryptedRecoveryShares?.length) {
            throw new Error("Missing recovery share.");
        }
        for (const maybeEncryptedRecoveryShare of maybeEncryptedRecoveryShares) {
            try {
                if (recoveryShare.recoveryCode) {
                    // for client encrypted share, we attempt to decrypt them
                    recoverShareToReturn = await (0, encryption_js_1.decryptShareWeb)(maybeEncryptedRecoveryShare || "", recoveryShare.recoveryCode || "");
                }
                else {
                    recoverShareToReturn = maybeEncryptedRecoveryShare;
                }
                // if we get here, decryption was successful, so we stop trying
                break;
            }
            catch { }
        }
        if (!recoverShareToReturn) {
            throw new Error("Invalid recovery code.");
        }
    }
    let deviceShareToReturn;
    try {
        deviceShareToReturn = deviceShare.toRetrieve
            ? (await (0, local_js_1.getDeviceShare)(client.clientId)).deviceShare
            : undefined;
    }
    catch {
        throw new Error(constants_js_1.DEVICE_SHARE_MISSING_MESSAGE);
    }
    // The any typecast here to overcome typescript limitation
    // see: https://github.com/microsoft/TypeScript/issues/22735
    // see: https://github.com/microsoft/TypeScript/issues/22735
    return {
        // biome-ignore lint/suspicious/noExplicitAny: TODO check the links above
        authShare: authShare.toRetrieve ? (_authShare || "") : undefined,
        // biome-ignore lint/suspicious/noExplicitAny: TODO check the links above
        deviceShare: deviceShareToReturn,
        // biome-ignore lint/suspicious/noExplicitAny: TODO check the links above
        recoveryShare: recoverShareToReturn,
    };
}
async function getAccountAddressFromShares(args) {
    const wallet = await getAccountFromShares(args);
    return wallet.address;
}
async function setUpShareForNewDevice({ recoveryCode, client, }) {
    const { recoveryShare, authShare } = await getShares({
        client,
        authShare: { toRetrieve: true },
        recoveryShare: { toRetrieve: true, recoveryCode },
        deviceShare: { toRetrieve: false },
    });
    // instead of recreating a new share, just save the recovery one as the new device share
    const deviceShare = recoveryShare;
    const walletAddress = await getAccountAddressFromShares({
        client,
        shares: [recoveryShare, authShare],
    });
    const maybeDeviceShare = await (0, creation_js_1.storeShares)({
        client,
        walletAddress,
        deviceShare,
    });
    if (!maybeDeviceShare?.deviceShareStored) {
        throw new Error(constants_js_1.DEVICE_SHARE_MISSING_MESSAGE);
    }
    return {
        walletAddress,
        deviceShareStored: maybeDeviceShare?.deviceShareStored,
        isIframeStorageEnabled: false,
    };
}
//# sourceMappingURL=retrieval.js.map