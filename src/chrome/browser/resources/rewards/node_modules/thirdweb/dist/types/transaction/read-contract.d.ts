import { type Abi, type AbiFunction, type AbiParameter, type AbiParametersToPrimitiveTypes, type ExtractAbiFunctionNames } from "abitype";
import { type TransactionRequest } from "viem";
import type { ThirdwebContract } from "../contract/contract.js";
import type { PrepareTransactionOptions } from "./prepare-transaction.js";
import type { BaseTransactionOptions, ParamsOption, ParseMethod } from "./types.js";
import { type PreparedMethod } from "../utils/abi/prepare-method.js";
export type ReadContractResult<outputs extends readonly AbiParameter[]> = outputs extends {
    length: 0;
} ? never : outputs extends {
    length: 1;
} ? AbiParametersToPrimitiveTypes<outputs>[0] : AbiParametersToPrimitiveTypes<outputs>;
export type ReadContractOptions<TAbi extends Abi = [], TMethod extends AbiFunction | string | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>) = TAbi extends {
    length: 0;
} ? AbiFunction | string : ExtractAbiFunctionNames<TAbi>, TPreparedMethod extends PreparedMethod<ParseMethod<TAbi, TMethod>> = PreparedMethod<ParseMethod<TAbi, TMethod>>> = BaseTransactionOptions<Omit<TransactionRequest, "from" | "to" | "data" | "value" | "accessList" | "gas" | "gasPrice" | "maxFeePerGas" | "maxPriorityFeePerGas" | "nonce"> & {
    method: TMethod | TPreparedMethod;
    from?: string;
} & ParamsOption<TPreparedMethod[1]> & Omit<PrepareTransactionOptions, "to" | "data" | "chain" | "client">, TAbi>;
/**
 * ### Reads state from a deployed smart contract.
 *
 * You can use raw read calls or read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) to read from a contract.
 *
 * @param options - The transaction options.
 * @returns A promise that resolves with the result of the read call.
 * @transaction
 * @example
 *
 * ### Using a contract read extension
 *
 * ```ts
 * import { getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 * import { getOwnedNFTs } form "thirdweb/extensions/erc721";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract(getOwnedNFTs, { contract, owner: address });
 * ```
 *
 * ### Using a raw contract call
 *
 * ```ts
 * import { getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: "function tokenURI(uint256 tokenId) returns (string)"}),
 *   params: [1n],
 * });
 * ```
 *
 * ### Using `resolveMethod`
 * ```ts
 * import { getContract, resolveMethod } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: resolveMethod("tokenURI"),
 *   params: [1n],
 * });
 * ```
 */
export declare function readContract<const TAbi extends Abi, const TMethod extends TAbi extends {
    length: 0;
} ? AbiFunction | `function ${string}` | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>) : ExtractAbiFunctionNames<TAbi>, const TPreparedMethod extends PreparedMethod<ParseMethod<TAbi, TMethod>> = PreparedMethod<ParseMethod<TAbi, TMethod>>>(options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>): Promise<ReadContractResult<TPreparedMethod[2]>>;
//# sourceMappingURL=read-contract.d.ts.map