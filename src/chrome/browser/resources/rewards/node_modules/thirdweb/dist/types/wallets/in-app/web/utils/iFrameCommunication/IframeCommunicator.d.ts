type IFrameCommunicatorProps = {
    link: string;
    baseUrl: string;
    iframeId: string;
    container?: HTMLElement;
    onIframeInitialize?: () => void;
};
/**
 * @internal
 */
export declare class IframeCommunicator<T extends {
    [key: string]: any;
}> {
    private iframe;
    private POLLING_INTERVAL_SECONDS;
    private iframeBaseUrl;
    /**
     * @internal
     */
    constructor({ link, baseUrl, iframeId, container, onIframeInitialize, }: IFrameCommunicatorProps);
    protected onIframeLoadedInitVariables(): Promise<Record<string, any>>;
    /**
     * @internal
     */
    onIframeLoadHandler(iframe: HTMLIFrameElement, onIframeInitialize?: () => void): () => Promise<void>;
    /**
     * @internal
     */
    call<ReturnData>({ procedureName, params, showIframe, }: {
        procedureName: keyof T;
        params: T[keyof T];
        showIframe?: boolean;
    }): Promise<ReturnData>;
    /**
     * This has to be called by any iframe that will be removed from the DOM.
     * Use to make sure that we reset the global loaded state of the particular iframe.src
     * @internal
     */
    destroy(): void;
}
export {};
//# sourceMappingURL=IframeCommunicator.d.ts.map