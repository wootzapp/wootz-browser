"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultWalletConnectRequestHandlers = exports.clearWalletConnectClientCache = void 0;
exports.createWalletConnectClient = createWalletConnectClient;
exports.createWalletConnectSession = createWalletConnectSession;
exports.getActiveWalletConnectSessions = getActiveWalletConnectSessions;
exports.disconnectWalletConnectSession = disconnectWalletConnectSession;
const sign_client_1 = require("@walletconnect/sign-client");
const defaultDappMetadata_js_1 = require("../../utils/defaultDappMetadata.js");
const constants_js_1 = require("../constants.js");
const send_raw_transaction_js_1 = require("./request-handlers/send-raw-transaction.js");
const send_transaction_js_1 = require("./request-handlers/send-transaction.js");
const sign_transaction_js_1 = require("./request-handlers/sign-transaction.js");
const sign_typed_data_js_1 = require("./request-handlers/sign-typed-data.js");
const sign_js_1 = require("./request-handlers/sign.js");
const switch_chain_js_1 = require("./request-handlers/switch-chain.js");
const session_store_js_1 = require("./session-store.js");
let walletConnectClientCache = new WeakMap();
/*
 * @internal
 */
const clearWalletConnectClientCache = () => {
    walletConnectClientCache = new WeakMap();
};
exports.clearWalletConnectClientCache = clearWalletConnectClientCache;
/**
 * Default request handlers for WalletConnect requests.
 */
exports.DefaultWalletConnectRequestHandlers = {
    personal_sign: sign_js_1.handleSignRequest,
    eth_sign: sign_js_1.handleSignRequest,
    eth_signTypedData: sign_typed_data_js_1.handleSignTypedDataRequest,
    eth_signTypedData_v4: sign_typed_data_js_1.handleSignTypedDataRequest,
    eth_signTransaction: sign_transaction_js_1.handleSignTransactionRequest,
    eth_sendTransaction: send_transaction_js_1.handleSendTransactionRequest,
    eth_sendRawTransaction: send_raw_transaction_js_1.handleSendRawTransactionRequest,
    wallet_addEthereumChain: (_) => {
        throw new Error("Unsupported request method: wallet_addEthereumChain");
    },
    wallet_switchEthereumChain: switch_chain_js_1.handleSwitchChain,
};
/**
 * Creates a new WalletConnect client for interacting with another application.
 * @param options - The options to use to create the WalletConnect client.
 *
 * @returns The WalletConnect client. Use this client to connect to a WalletConnect URI with {@link createWalletConnectSession}.
 * @example
 * ```ts
 * import { createWalletConnectClient } from "thirdweb/wallets";
 *
 * const client = await createWalletConnectClient({
 *   wallet: wallet,
 *   client: client,
 * });
 * ```
 * Pass custom handlers:
 * ```ts
 * import { createWalletConnectClient } from "thirdweb/wallets";
 *
 * const client = await createWalletConnectClient({
 *   wallet: wallet,
 *   client: client,
 *   requestHandlers: {
 *     eth_signTransaction: ({ account, chainId, params }) => {
 *       // handle transaction signing
 *     },
 *   },
 * });
 * ```
 * Pass connect and disconnect callbacks:
 * ```ts
 * import { createWalletConnectClient } from "thirdweb/wallets";
 *
 * const client = await createWalletConnectClient({
 *   wallet: wallet,
 *   client: client,
 *   onConnect: (session) => {
 *     console.log("Connected to WalletConnect", session);
 *   },
 *   onDisconnect: (session) => {
 *     console.log("Disconnected from WalletConnect", session);
 *   },
 * });
 * ```
 * @wallet
 */
async function createWalletConnectClient(options) {
    const { wallet, requestHandlers, chains, onConnect, onDisconnect, client: thirdwebClient, } = options;
    if (walletConnectClientCache.has(thirdwebClient)) {
        return walletConnectClientCache.get(thirdwebClient);
    }
    (0, session_store_js_1.initializeSessionStore)({ clientId: options.client.clientId });
    const defaults = (0, defaultDappMetadata_js_1.getDefaultAppMetadata)();
    const walletConnectClient = await sign_client_1.SignClient.init({
        projectId: options.projectId ?? constants_js_1.DEFAULT_PROJECT_ID,
        metadata: {
            name: options.appMetadata?.name ?? defaults.name,
            url: options.appMetadata?.url ?? defaults.url,
            description: options.appMetadata?.description ?? defaults.description,
            icons: [options.appMetadata?.logoUrl ?? defaults.logoUrl],
        },
    });
    walletConnectClient.on("session_proposal", async (event) => {
        const { onSessionProposal } = await Promise.resolve().then(() => require("./session-proposal.js"));
        await onSessionProposal({
            wallet,
            walletConnectClient,
            event,
            chains,
            onConnect,
        }).catch((error) => {
            if (options.onError) {
                options.onError(error);
            }
            else {
                throw error;
            }
        });
    });
    walletConnectClient.on("session_request", async (event) => {
        const { fulfillRequest } = await Promise.resolve().then(() => require("./session-request.js"));
        await fulfillRequest({
            wallet,
            walletConnectClient,
            event,
            handlers: requestHandlers,
            thirdwebClient,
        }).catch((error) => {
            if (options.onError) {
                options.onError(error);
            }
            else {
                throw error;
            }
        });
    });
    walletConnectClient.on("session_event", async (_event) => {
        // TODO (accountsChanged, chainChanged)
    });
    walletConnectClient.on("session_ping", (_event) => {
        // TODO
    });
    walletConnectClient.on("session_delete", async (event) => {
        await disconnectWalletConnectSession({
            session: { topic: event.topic },
            walletConnectClient,
        }).catch((error) => {
            if (options.onError) {
                options.onError(error);
            }
            else {
                throw error;
            }
        });
    });
    // Disconnects can come from the user or the connected app, so we inject the callback to ensure its always triggered
    const _disconnect = walletConnectClient.disconnect;
    walletConnectClient.disconnect = async (args) => {
        const result = await _disconnect(args).catch(() => {
            // no-op if already disconnected
        });
        if (onDisconnect) {
            disconnectHook({ topic: args.topic, onDisconnect });
        }
        return result;
    };
    walletConnectClientCache.set(options.client, walletConnectClient);
    return walletConnectClient;
}
/**
 * Initiates a new WalletConnect session for interacting with another application.
 * @param options - The options to use to create the WalletConnect session.
 * @example
 * ```ts
 * import { createWalletConnectClient, createWalletConnectSession } from "thirdweb/wallets";
 *
 * const client = await createWalletConnectClient({
 *   wallet: wallet,
 *   client: client,
 * });
 *
 * const session = await createWalletConnectSession({
 *   walletConnectClient: client,
 *   uri: "wc:...",
 * });
 * ```
 * @wallet
 */
function createWalletConnectSession(options) {
    const { uri, walletConnectClient } = options;
    walletConnectClient.core.pairing.pair({ uri });
}
/**
 * Retrieves all active WalletConnect sessions.
 * @returns All active WalletConnect sessions.
 * @example
 * ```ts
 * import { getActiveWalletConnectSessions } from "thirdweb/wallets";
 *
 * const sessions = await getActiveWalletConnectSessions();
 * ```
 * @wallet
 */
async function getActiveWalletConnectSessions() {
    return (0, session_store_js_1.getSessions)();
}
/**
 * Disconnects a WalletConnect session.
 * @param options - The options to use to disconnect the WalletConnect session.
 * @example
 * ```ts
 * import { disconnectWalletConnectSession } from "thirdweb/wallets";
 *
 * await disconnectWalletConnectSession({
 *   session: mySession,
 *   walletConnectClient: wcClient,
 * });
 * ```
 * @wallet
 */
async function disconnectWalletConnectSession(options) {
    (0, session_store_js_1.removeSession)(options.session);
    try {
        await options.walletConnectClient.disconnect({
            topic: options.session.topic,
            reason: {
                code: 6000,
                message: "Disconnected",
            },
        });
    }
    catch {
        // ignore, the session doesn't exist already
    }
}
/**
 * @internal
 */
async function disconnectHook(options) {
    const { topic, onDisconnect } = options;
    const sessions = await (0, session_store_js_1.getSessions)();
    onDisconnect(sessions.find((s) => s.topic === topic) ?? {
        topic,
    });
}
//# sourceMappingURL=index.js.map