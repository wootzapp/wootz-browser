"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useToTokenSelectionStates = useToTokenSelectionStates;
exports.useFromTokenSelectionStates = useFromTokenSelectionStates;
exports.useFiatCurrencySelectionStates = useFiatCurrencySelectionStates;
const react_1 = require("react");
const polygon_js_1 = require("../../../../../../../chains/chain-definitions/polygon.js");
const useActiveWalletChain_js_1 = require("../../../../../../core/hooks/wallets/useActiveWalletChain.js");
const useDebouncedValue_js_1 = require("../../../../hooks/useDebouncedValue.js");
const nativeToken_js_1 = require("../../nativeToken.js");
const currencies_js_1 = require("../fiat/currencies.js");
// handle states for token and chain selection
function useToTokenSelectionStates(options) {
    const { payOptions, supportedDestinations } = options;
    // --------------------------------------------------------------------------
    // buy token amount ---------------------------------------------------------
    // NOTE - for transaction / direct payment modes, the token amount is set when the user tap continue
    const prefillBuy = payOptions?.prefillBuy;
    const activeChain = (0, useActiveWalletChain_js_1.useActiveWalletChain)();
    const initialTokenAmount = prefillBuy?.amount || "";
    const [tokenAmount, setTokenAmount] = (0, react_1.useState)(initialTokenAmount);
    const deferredTokenAmount = (0, useDebouncedValue_js_1.useDebouncedValue)(tokenAmount, 300);
    // Destination chain and token selection -----------------------------------
    const [toChain, setToChain] = (0, react_1.useState)(
    // use prefill chain if available
    prefillBuy?.chain ||
        (payOptions.mode === "transaction" && payOptions.transaction?.chain) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo?.chain) ||
        // use active chain if its supported as destination
        supportedDestinations.find((x) => x.chain.id === activeChain?.id)
            ?.chain ||
        // default to the first chain in supportedDestinations, or polygon if nothing is found at all
        supportedDestinations[0]?.chain ||
        polygon_js_1.polygon);
    const [toToken, setToToken] = (0, react_1.useState)(prefillBuy?.token ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo.token) ||
        nativeToken_js_1.NATIVE_TOKEN);
    return {
        toChain,
        setToChain,
        toToken,
        setToToken,
        tokenAmount,
        setTokenAmount,
        deferredTokenAmount,
    };
}
function useFromTokenSelectionStates(options) {
    const { payOptions, supportedSources } = options;
    // --------------------------------------------------------------------------
    const firstSupportedSource = supportedSources?.length
        ? supportedSources[0]
        : undefined;
    // Source token and chain selection ---------------------------------------------------
    const [fromChain_, setFromChain] = (0, react_1.useState)();
    // use prefill chain if available
    const fromChainDevSpecified = (payOptions.buyWithCrypto !== false &&
        payOptions.buyWithCrypto?.prefillSource?.chain) ||
        (payOptions.mode === "transaction" && payOptions.transaction?.chain) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo?.chain);
    const fromChainFromApi = firstSupportedSource?.chain
        ? firstSupportedSource.chain
        : undefined;
    const fromChain = fromChain_ || fromChainDevSpecified || fromChainFromApi || polygon_js_1.polygon;
    const [fromToken_, setFromToken] = (0, react_1.useState)();
    // use prefill token if available
    const fromTokenDevSpecified = (payOptions.buyWithCrypto !== false &&
        payOptions.buyWithCrypto?.prefillSource?.token) ||
        (payOptions.mode === "direct_payment" && payOptions.paymentInfo.token);
    // May be updated in the future
    const fromTokenFromApi = nativeToken_js_1.NATIVE_TOKEN;
    // supported tokens query in here
    const fromToken = fromToken_ || fromTokenDevSpecified || fromTokenFromApi || nativeToken_js_1.NATIVE_TOKEN;
    return {
        fromChain,
        setFromChain,
        fromToken,
        setFromToken,
    };
}
function useFiatCurrencySelectionStates(options) {
    const { payOptions } = options;
    // --------------------------------------------------------------------------
    const devSpecifiedDefaultCurrency = payOptions.buyWithFiat !== false
        ? payOptions.buyWithFiat?.prefillSource?.currency
        : undefined;
    const defaultSelectedCurrencyShorthand = devSpecifiedDefaultCurrency || getDefaultCurrencyBasedOnLocation();
    const [selectedCurrency, setSelectedCurrency] = (0, react_1.useState)(currencies_js_1.currencies.find((x) => x.shorthand === defaultSelectedCurrencyShorthand) ||
        currencies_js_1.usdCurrency);
    return {
        selectedCurrency,
        setSelectedCurrency,
    };
}
function getDefaultCurrencyBasedOnLocation() {
    // if Intl is not supported - browser throws
    try {
        const timeZone = Intl.DateTimeFormat()
            .resolvedOptions()
            .timeZone.toLowerCase();
        // Europe/London -> GBP
        if (timeZone.includes("london")) {
            return "GBP";
        }
        // Europe/* -> EUR
        if (timeZone.includes("europe")) {
            return "EUR";
        }
        // Japan
        if (timeZone.includes("japan")) {
            return "JPY";
        }
        // canada
        if (timeZone.includes("canada")) {
            return "CAD";
        }
        return "USD";
    }
    catch {
        return "USD";
    }
}
//# sourceMappingURL=useUISelectionStates.js.map