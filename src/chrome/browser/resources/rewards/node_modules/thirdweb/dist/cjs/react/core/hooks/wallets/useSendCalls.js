"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSendCalls = useSendCalls;
const react_query_1 = require("@tanstack/react-query");
const send_calls_js_1 = require("../../../../wallets/eip5792/send-calls.js");
const wait_for_bundle_js_1 = require("../../../../wallets/eip5792/wait-for-bundle.js");
const invalidateWalletBalance_js_1 = require("../../providers/invalidateWalletBalance.js");
const useActiveWallet_js_1 = require("./useActiveWallet.js");
/**
 * A hook to send [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) calls to a wallet.
 * This hook works with all Thirdweb wallets (in-app and smart) and certain injected wallets that already support EIP-5792.
 * Transactions will be bundled and sponsored when those capabilities are supported, otherwise they will be sent as individual transactions.
 *
 * When calls are sent, all contracts that are interacted with will have their corresponding reads revalidated via React Query.
 *
 * @note This hook is dependent on the wallet's support for EIP-5792 and could fail.
 * @note The mutatuon function will use your currently connected wallet by default, but you can pass it a specific wallet to use if you'd like.
 *
 * @returns A React Query mutatuon object to interact with {@link sendCalls}
 * @throws an error if the wallet does not support EIP-5792.
 * @returns The ID of the bundle of the calls.
 *
 * @beta
 * @example
 * ```tsx
 * import { useSendCalls } from "thirdweb/react";
 *
 * const sendTx1 = approve({
      contract: USDT_CONTRACT,
      amount: 100,
      spender: "0x33d9B8BEfE81027E2C859EDc84F5636cbb202Ed6",
    });
 * const sendTx2 = approve({
      contract: USDT_CONTRACT,
      amount: 100,
      spender: "0x2a4f24F935Eb178e3e7BA9B53A5Ee6d8407C0709",
    });
 * const { mutate: sendCalls, data: bundleId } = useSendCalls({ client });
 * await sendCalls({
 *   wallet,
 *   client,
 *   calls: [sendTx1, sendTx2],
 * });
 * ```
 * Await the bundle's full confirmation:
 * ```tsx
 * const { mutate: sendCalls, data: bundleId } = useSendCalls({ client, waitForResult: true });
 * await sendCalls({
 *   wallet,
 *   client,
 *   calls: [sendTx1, sendTx2],
 * });
 * ```
 * Sponsor transactions with a paymaster:
 * ```ts
 * const { mutate: sendCalls, data: bundleId } = useSendCalls();
 * await sendCalls({
 *   client,
 *   calls: [sendTx1, sendTx2],
 *   capabilities: {
 *     paymasterService: {
 *       url: `https://${CHAIN.id}.bundler.thirdweb.com/${client.clientId}`
 *     }
 *   }
 * });
 * ```
 *
 * @note We recommend proxying any paymaster calls via an API route you setup and control.
 * @extension EIP5792
 */
function useSendCalls({ client, waitForResult = true, }) {
    const activeWallet = (0, useActiveWallet_js_1.useActiveWallet)();
    const queryClient = (0, react_query_1.useQueryClient)();
    return (0, react_query_1.useMutation)({
        mutationFn: async (options) => {
            const { wallet = activeWallet } = options;
            const chain = wallet?.getChain();
            if (!wallet || !chain) {
                throw new Error("Failed to send transactions, no connected wallet found.");
            }
            const callsPromise = (0, send_calls_js_1.sendCalls)({ ...options, wallet });
            if (!waitForResult) {
                return callsPromise;
            }
            const result = await (0, wait_for_bundle_js_1.waitForBundle)({
                bundleId: await callsPromise,
                wallet,
                client,
                chain,
            });
            return result;
        },
        onSettled: async (_result, _error, variables) => {
            // Attempt to invalidate any reads related to the sent transactions
            const chain = activeWallet?.getChain();
            if (!_result || !activeWallet || !chain) {
                return;
            }
            if (typeof _result === "string") {
                await (0, wait_for_bundle_js_1.waitForBundle)({
                    bundleId: _result,
                    wallet: activeWallet,
                    client,
                    chain,
                }).catch((error) => {
                    console.error("Failed to confirm sent bundle and invalidate queries", _result, error);
                    return undefined;
                });
            }
            for (const call of variables.calls) {
                queryClient.invalidateQueries({
                    queryKey: [
                        "readContract",
                        call.__contract?.chain.id,
                        call.__contract?.address,
                    ],
                });
            }
            (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient, chain.id);
        },
    });
}
//# sourceMappingURL=useSendCalls.js.map