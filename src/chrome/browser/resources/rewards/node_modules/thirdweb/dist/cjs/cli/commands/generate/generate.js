"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = generate;
exports.isValidChainIdAndContractAddress = isValidChainIdAndContractAddress;
const abitype_1 = require("abitype");
const utils_js_1 = require("../../../chains/utils.js");
const client_js_1 = require("../../../client/client.js");
const resolve_abi_js_1 = require("../../../contract/actions/resolve-abi.js");
const contract_js_1 = require("../../../contract/contract.js");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const prepare_method_js_1 = require("../../../utils/abi/prepare-method.js");
const utils_js_2 = require("./utils.js");
const client = (0, client_js_1.createThirdwebClient)({ clientId: "test" });
async function generate(input) {
    const [chainId, contractAddress] = input.split("/");
    if (!chainId || !contractAddress) {
        throw new Error("Invalid chainId and contractAddress");
    }
    const contract = (0, contract_js_1.getContract)({
        client,
        chain: (0, utils_js_1.getCachedChain)(Number.parseInt(chainId)),
        address: contractAddress,
    });
    const abi = await (0, resolve_abi_js_1.resolveAbiFromContractApi)(contract);
    if (!abi) {
        throw new Error("No ABI found for contract");
    }
    const generated = await generateFromAbi(abi);
    // find the root of the project
    const root = await (0, utils_js_2.packageDirectory)();
    if (!root) {
        throw new Error("No root found");
    }
    // create the chain directory
    const hasSource = (0, node_fs_1.existsSync)((0, node_path_1.join)(root, "src"));
    const path = hasSource ? "src/thirdweb" : "thirdweb";
    const chainDirPath = (0, node_path_1.join)(root, path, chainId);
    await (0, promises_1.mkdir)(chainDirPath, { recursive: true });
    await (0, promises_1.writeFile)((0, node_path_1.join)(chainDirPath, `${contractAddress.toLowerCase()}.ts`), generated);
}
function isValidChainIdAndContractAddress(chainIdPlusContract) {
    if (typeof chainIdPlusContract !== "string") {
        return false;
    }
    const [chainId, contractAddress] = chainIdPlusContract.split("/");
    if (!chainId || !contractAddress) {
        return false;
    }
    return true;
}
async function generateFromAbi(abi) {
    // turn any human readable abi into a proper abi object
    // biome-ignore lint/style/noParameterAssign: TODO: fix later
    abi = abi.map((x) => (typeof x === "string" ? (0, abitype_1.parseAbiItem)(x) : x));
    const events = abi.filter((x) => x.type === "event");
    const functions = abi.filter((x) => x.type === "function");
    const overloadedReads = new Set();
    const overloadedWrites = new Set();
    // split functions into read and write
    const readFunctions = [];
    const writeFunctions = [];
    for (const f of functions) {
        if (f.stateMutability === "view" || f.stateMutability === "pure") {
            if (overloadedReads.has(f.name)) {
                continue;
            }
            readFunctions.push(f);
            overloadedReads.add(f.name);
        }
        else {
            if (overloadedWrites.has(f.name)) {
                continue;
            }
            writeFunctions.push(f);
            overloadedWrites.add(f.name);
        }
    }
    // creat the file body
    let body = `import {
  prepareEvent,
  prepareContractCall,
  readContract,
  type BaseTransactionOptions,
  type AbiParameterToPrimitiveType,
} from "thirdweb";\n\n`;
    if (events.length) {
        body += `/**
* Contract events
*/\n\n`;
        // process every event
        await Promise.all(events.map(async (e) => {
            body += `${generateEvent(e)}\n\n`;
        }));
    }
    if (readFunctions.length) {
        body += `/**
* Contract read functions
*/\n\n`;
        // process every read function
        await Promise.all(readFunctions.map(async (f) => {
            body += `${generateReadFunction(f)}\n\n`;
        }));
    }
    if (writeFunctions.length) {
        body += `/**
* Contract write functions
*/\n\n`;
        // process every write function
        await Promise.all(writeFunctions.map(async (f) => {
            body += `${generateWriteFunction(f)}\n\n`;
        }));
    }
    const prettified = await prettifyCode(body, {
        parser: "babel-ts",
    });
    return prettified;
}
function generateWriteFunction(f) {
    return `${f.inputs.length > 0
        ? `/**
 * Represents the parameters for the "${f.name}" function.
 */
export type ${uppercaseFirstLetter(f.name)}Params = {
  ${f.inputs
            .map((x, i) => `${removeLeadingUnderscore(x.name || `arg_${i}`)}: AbiParameterToPrimitiveType<${JSON.stringify(x)}>`)
            .join("\n")}
};`
        : ""}

/**
 * Calls the "${f.name}" function on the contract.
 * @param options - The options for the "${f.name}" function.
 * @returns A prepared transaction object.
 * @example
 * \`\`\`
 * import { ${f.name} } from "TODO";
 *
 * const transaction = ${f.name}(${f.inputs.length > 0
        ? `{\n * ${f.inputs
            .map((x, i) => ` ${removeLeadingUnderscore(x.name || `arg_${i}`)}: ...,`)
            .join("\n * ")}\n * }`
        : ""});
 *
 * // Send the transaction
 * ...
 *
 * \`\`\`
 */
export function ${f.name}(
  options: BaseTransactionOptions${f.inputs.length > 0 ? `<${uppercaseFirstLetter(f.name)}Params>` : ""}
) {
  return prepareContractCall({
    contract: options.contract,
    method: ${JSON.stringify((0, prepare_method_js_1.prepareMethod)(f), null, 2)},
    params: [${f.inputs
        .map((x, i) => `options.${removeLeadingUnderscore(x.name || `arg_${i}`)}`)
        .join(", ")}]
  });
};
`;
}
function generateReadFunction(f) {
    return `${f.inputs.length > 0
        ? `/**
 * Represents the parameters for the "${f.name}" function.
 */
export type ${uppercaseFirstLetter(f.name)}Params = {
  ${f.inputs
            .map((x, i) => `${removeLeadingUnderscore(x.name || `arg_${i}`)}: AbiParameterToPrimitiveType<${JSON.stringify(x)}>`)
            .join("\n")}
};`
        : ""}

/**
 * Calls the "${f.name}" function on the contract.
 * @param options - The options for the ${f.name} function.
 * @returns The parsed result of the function call.
 * @example
 * \`\`\`
 * import { ${f.name} } from "TODO";
 *
 * const result = await ${f.name}(${f.inputs.length > 0
        ? `{\n * ${f.inputs
            .map((x, i) => ` ${removeLeadingUnderscore(x.name || `arg_${i}`)}: ...,`)
            .join("\n * ")}\n * }`
        : ""});
 *
 * \`\`\`
 */
export async function ${f.name}(
  options: BaseTransactionOptions${f.inputs.length > 0 ? `<${uppercaseFirstLetter(f.name)}Params>` : ""}
) {
  return readContract({
    contract: options.contract,
    method: ${JSON.stringify((0, prepare_method_js_1.prepareMethod)(f), null, 2)},
    params: [${f.inputs
        .map((x, i) => `options.${removeLeadingUnderscore(x.name || `arg_${i}`)}`)
        .join(", ")}]
  });
};
`;
}
function generateEvent(e) {
    const indexedInputs = e.inputs.filter((x) => x.indexed);
    return `${indexedInputs.length > 0
        ? `/**
 * Represents the filters for the "${e.name}" event.
 */
export type ${uppercaseFirstLetter(e.name)}EventFilters = Partial<{
  ${indexedInputs
            .map((x) => `${x.name}: AbiParameterToPrimitiveType<${JSON.stringify(x)}>`)
            .join("\n")}
}>;`
        : ""}

/**
 * Creates an event object for the ${e.name} event.${indexedInputs.length > 0
        ? "\n * @param filters - Optional filters to apply to the event."
        : ""}
 * @returns The prepared event object.
 * @example
 * \`\`\`
 * import { getContractEvents } from "thirdweb";
 * import { ${eventNameToPreparedEventName(e.name)} } from "TODO";
 *
 * const events = await getContractEvents({
 * contract,
 * events: [
 *  ${eventNameToPreparedEventName(e.name)}(${indexedInputs.length > 0
        ? `{\n * ${indexedInputs
            .map((x) => ` ${x.name}: ...,`)
            .join("\n * ")}\n * }`
        : ""})
 * ],
 * });
 * \`\`\`
 */
export function ${eventNameToPreparedEventName(e.name)}(${indexedInputs.length > 0
        ? `filters: ${uppercaseFirstLetter(e.name)}EventFilters = {}`
        : ""}) {
  return prepareEvent({
    signature: "${(0, abitype_1.formatAbiItem)(e)}",${indexedInputs.length > 0 ? "\n    filters," : ""}
  });
};
  `;
}
// helpers
function uppercaseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
function removeLeadingUnderscore(str = "") {
    return str.replace(/^_/, "");
}
function lowercaseFirstLetter(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
function eventNameToPreparedEventName(name) {
    return `${lowercaseFirstLetter(name)}Event`;
}
const printedPrettierWarning = false;
async function prettifyCode(code, options) {
    try {
        const { format } = await Promise.resolve().then(() => require("prettier/standalone.js"));
        return await format(code, options);
    }
    catch {
        if (!printedPrettierWarning) {
            console.info("Prettier not found, skipping code formatting.");
        }
    }
    return code;
}
//# sourceMappingURL=generate.js.map