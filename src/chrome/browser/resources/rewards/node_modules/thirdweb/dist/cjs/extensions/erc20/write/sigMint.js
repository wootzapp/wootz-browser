"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mintWithSignature = mintWithSignature;
exports.generateMintSignature = generateMintSignature;
const addresses_js_1 = require("../../../constants/addresses.js");
const date_js_1 = require("../../../utils/date.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const random_js_1 = require("../../../utils/random.js");
const name_js_1 = require("../../common/read/name.js");
const mintWithSignature_js_1 = require("../__generated__/ISignatureMintERC20/write/mintWithSignature.js");
/**
 * Mints a new ERC20 token with the given minter signature
 * @param options - The transaction options.
 * @extension ERC20
 * @example
 * ```ts
 * import { mintWithSignature, generateMintSignature } from "thirdweb/extensions/erc20";
 * import { sendTransaction } from "thirdweb";
 *
 * const { payload, signature } = await generateMintSignature(...)
 *
 * const transaction = mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 *
 * await sendTransaction({ transaction, account });
 * ```
 * @extension ERC20
 * @returns A promise that resolves to the transaction result.
 */
function mintWithSignature(options) {
    const value = (0, addresses_js_1.isNativeTokenAddress)(options.payload.currency)
        ? options.payload.price
        : 0n;
    const erc20Value = !(0, addresses_js_1.isNativeTokenAddress)(options.payload.currency) &&
        options.payload.price > 0n
        ? {
            amountWei: options.payload.price,
            tokenAddress: options.payload.currency,
        }
        : undefined;
    return (0, mintWithSignature_js_1.mintWithSignature)({
        ...options,
        overrides: {
            value,
            erc20Value,
        },
    });
}
/**
 * Generates the payload and signature for minting an ERC20 token.
 * @param options - The options for the minting process.
 * @example
 * ```ts
 * import { mintWithSignature, generateMintSignature } from "thirdweb/extensions/erc20";
 *
 * const { payload, signature } = await generateMintSignature({
 *   account,
 *   contract,
 *   mintRequest: {
 *     to: "0x...",
 *     quantity: "10",
 *   },
 * });
 *
 * const transaction = mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 * await sendTransaction({ transaction, account });
 * ```
 * @extension ERC20
 * @returns A promise that resolves to the payload and signature.
 */
async function generateMintSignature(options) {
    const { mintRequest, account, contract } = options;
    const currency = mintRequest.currency || addresses_js_1.NATIVE_TOKEN_ADDRESS;
    const [price, quantity, uid, tokenName] = await Promise.all([
        // price per token in wei
        (async () => {
            // if priceInWei is provided, use it
            if ("priceInWei" in mintRequest && mintRequest.priceInWei) {
                return mintRequest.priceInWei;
            }
            // if price is provided, convert it to wei
            if ("price" in mintRequest && mintRequest.price) {
                const { convertErc20Amount } = await Promise.resolve().then(() => require("../../../utils/extensions/convert-erc20-amount.js"));
                return await convertErc20Amount({
                    amount: mintRequest.price,
                    client: contract.client,
                    chain: contract.chain,
                    erc20Address: currency,
                });
            }
            // if neither price nor priceInWei is provided, default to 0
            return 0n;
        })(),
        // quantity in wei
        (async () => {
            // if the quantity is already passed in wei, use it
            if ("quantityWei" in mintRequest) {
                return mintRequest.quantityWei;
            }
            // otherwise convert the quantity to wei using the contract's OWN decimals
            const { convertErc20Amount } = await Promise.resolve().then(() => require("../../../utils/extensions/convert-erc20-amount.js"));
            return await convertErc20Amount({
                amount: mintRequest.quantity,
                client: contract.client,
                chain: contract.chain,
                erc20Address: contract.address,
            });
        })(),
        (() => {
            if (mintRequest.uid) {
                return (0, hex_js_1.isHex)(mintRequest.uid)
                    ? mintRequest.uid
                    : (0, hex_js_1.stringToHex)(mintRequest.uid, { size: 32 });
            }
            return (0, random_js_1.randomBytesHex)();
        })(),
        // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.
        // it uses the token name in the domain separator
        (0, name_js_1.name)({
            contract,
        }),
    ]);
    const startTime = mintRequest.validityStartTimestamp || new Date(0);
    const endTime = mintRequest.validityEndTimestamp || (0, date_js_1.tenYearsFromNow)();
    const payload = {
        price,
        quantity,
        uid,
        currency,
        to: mintRequest.to,
        primarySaleRecipient: mintRequest.primarySaleRecipient || account.address,
        validityStartTimestamp: (0, date_js_1.dateToSeconds)(startTime),
        validityEndTimestamp: (0, date_js_1.dateToSeconds)(endTime),
    };
    const signature = await account.signTypedData({
        domain: {
            name: tokenName,
            version: "1",
            chainId: contract.chain.id,
            verifyingContract: contract.address,
        },
        types: { MintRequest: MintRequest20 },
        primaryType: "MintRequest",
        message: payload,
    });
    return { payload, signature };
}
const MintRequest20 = [
    { name: "to", type: "address" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "quantity", type: "uint256" },
    { name: "price", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
];
//# sourceMappingURL=sigMint.js.map