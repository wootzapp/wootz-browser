import { hexToString, isHex, } from "../../../../../utils/encoding/hex.js";
import { privateKeyToAccount } from "../../../../private-key.js";
import { getUserShares } from "../api/fetchers.js";
import { DEVICE_SHARE_MISSING_MESSAGE, ROUTE_GET_USER_SHARES, } from "../constants.js";
import { getDeviceShare } from "../storage/local.js";
import { storeShares } from "./creation.js";
import { decryptShareWeb } from "./encryption.js";
/**
 * For users on a known device and logged in.
 * Will throw if called on a new device // user not logged in
 */
export async function getExistingUserAccount(args) {
    const { client } = args;
    const { authShare, deviceShare } = await getShares({
        client,
        authShare: { toRetrieve: true },
        deviceShare: { toRetrieve: true },
        recoveryShare: { toRetrieve: false },
    });
    return getAccountFromShares({
        client,
        shares: [authShare, deviceShare],
    });
}
async function getWalletPrivateKeyFromShares(shares) {
    const { secrets } = await import("./sss.js");
    let privateKeyHex = secrets.combine(shares, 0);
    if (!isHex(privateKeyHex)) {
        privateKeyHex = `0x${privateKeyHex}`;
    }
    const prefixPrivateKey = hexToString(privateKeyHex);
    if (!prefixPrivateKey.startsWith("thirdweb_")) {
        throw new Error("Invalid private key reconstructed from shares");
    }
    const privateKey = prefixPrivateKey.replace("thirdweb_", "");
    return privateKey;
}
async function getAccountFromShares(args) {
    const { client, shares } = args;
    return privateKeyToAccount({
        client,
        privateKey: await getWalletPrivateKeyFromShares(shares),
    });
}
/**
 *
 * @param deviceShare - retrieves the current share associated with the user's device.
 * @returns The requested shares
 * @throws if attempting to get deviceShare when it's not present
 */
async function getShares({ client, authShare, deviceShare, recoveryShare, }) {
    const queryParams = {};
    if (authShare.toRetrieve) {
        queryParams.getEncryptedAuthShare = true;
    }
    else {
        queryParams.getEncryptedAuthShare = false;
    }
    if (recoveryShare.toRetrieve) {
        queryParams.getEncryptedRecoveryShare = true;
        if (!recoveryShare.recoveryCode) {
            // purposely using a vague name to prevent people from inspecting url from figuring out what it does
            // so as to not cause huge debates on the technicality of the custodial // non-custodial
            queryParams.useSealedSecret = true;
        }
        else {
            queryParams.useSealedSecret = false;
        }
    }
    else {
        queryParams.getEncryptedRecoveryShare = false;
        queryParams.useSealedSecret = false;
    }
    const getShareUrl = new URL(ROUTE_GET_USER_SHARES);
    for (const queryKey of Object.keys(queryParams)) {
        getShareUrl.searchParams.append(queryKey, queryParams[queryKey]?.toString() || "");
    }
    const userShares = await getUserShares(client, getShareUrl);
    const { authShare: _authShare, maybeEncryptedRecoveryShares } = userShares;
    let recoverShareToReturn;
    if (recoveryShare.toRetrieve) {
        if (!maybeEncryptedRecoveryShares?.length) {
            throw new Error("Missing recovery share.");
        }
        for (const maybeEncryptedRecoveryShare of maybeEncryptedRecoveryShares) {
            try {
                if (recoveryShare.recoveryCode) {
                    // for client encrypted share, we attempt to decrypt them
                    recoverShareToReturn = await decryptShareWeb(maybeEncryptedRecoveryShare || "", recoveryShare.recoveryCode || "");
                }
                else {
                    recoverShareToReturn = maybeEncryptedRecoveryShare;
                }
                // if we get here, decryption was successful, so we stop trying
                break;
            }
            catch { }
        }
        if (!recoverShareToReturn) {
            throw new Error("Invalid recovery code.");
        }
    }
    let deviceShareToReturn;
    try {
        deviceShareToReturn = deviceShare.toRetrieve
            ? (await getDeviceShare(client.clientId)).deviceShare
            : undefined;
    }
    catch {
        throw new Error(DEVICE_SHARE_MISSING_MESSAGE);
    }
    // The any typecast here to overcome typescript limitation
    // see: https://github.com/microsoft/TypeScript/issues/22735
    // see: https://github.com/microsoft/TypeScript/issues/22735
    return {
        // biome-ignore lint/suspicious/noExplicitAny: TODO check the links above
        authShare: authShare.toRetrieve ? (_authShare || "") : undefined,
        // biome-ignore lint/suspicious/noExplicitAny: TODO check the links above
        deviceShare: deviceShareToReturn,
        // biome-ignore lint/suspicious/noExplicitAny: TODO check the links above
        recoveryShare: recoverShareToReturn,
    };
}
async function getAccountAddressFromShares(args) {
    const wallet = await getAccountFromShares(args);
    return wallet.address;
}
export async function setUpShareForNewDevice({ recoveryCode, client, }) {
    const { recoveryShare, authShare } = await getShares({
        client,
        authShare: { toRetrieve: true },
        recoveryShare: { toRetrieve: true, recoveryCode },
        deviceShare: { toRetrieve: false },
    });
    // instead of recreating a new share, just save the recovery one as the new device share
    const deviceShare = recoveryShare;
    const walletAddress = await getAccountAddressFromShares({
        client,
        shares: [recoveryShare, authShare],
    });
    const maybeDeviceShare = await storeShares({
        client,
        walletAddress,
        deviceShare,
    });
    if (!maybeDeviceShare?.deviceShareStored) {
        throw new Error(DEVICE_SHARE_MISSING_MESSAGE);
    }
    return {
        walletAddress,
        deviceShareStored: maybeDeviceShare?.deviceShareStored,
        isIframeStorageEnabled: false,
    };
}
//# sourceMappingURL=retrieval.js.map