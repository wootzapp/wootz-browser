"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simulateTransaction = simulateTransaction;
const viem_1 = require("viem");
const eth_call_js_1 = require("../../rpc/actions/eth_call.js");
const rpc_js_1 = require("../../rpc/rpc.js");
const resolve_promised_value_js_1 = require("../../utils/promise/resolve-promised-value.js");
const extract_error_js_1 = require("../extract-error.js");
const encode_js_1 = require("./encode.js");
/**
 * Simulates the execution of a transaction.
 * @param options - The options for simulating the transaction.
 * @returns A promise that resolves to the result of the simulation.
 * @transaction
 * @example
 * ```ts
 * import { simulateTransaction } from "thirdweb";
 * const result = await simulateTransaction({
 *  transaction,
 * });
 * ```
 */
async function simulateTransaction(options) {
    const [data, to, accessList, value] = await Promise.all([
        (0, encode_js_1.encode)(options.transaction),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.to),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.accessList),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(options.transaction.value),
    ]);
    // from is:
    // 1. the user specified from address
    // 2. the passed in account address
    // 3. the passed in wallet's account address
    const from = options.from ?? options.account?.address ?? undefined;
    const serializedTx = (0, viem_1.formatTransactionRequest)({
        data,
        from,
        to,
        value,
        accessList,
    });
    const rpcRequest = (0, rpc_js_1.getRpcClient)(options.transaction);
    try {
        const result = await (0, eth_call_js_1.eth_call)(rpcRequest, serializedTx);
        if (!options.transaction.__preparedMethod) {
            return result;
        }
        const prepared = await options.transaction.__preparedMethod();
        const decoded = (0, viem_1.decodeAbiParameters)(prepared[2], result);
        if (Array.isArray(decoded) && decoded.length === 1) {
            return decoded[0];
        }
        return decoded;
    }
    catch (error) {
        throw await (0, extract_error_js_1.extractError)({
            error,
            contract: options.transaction.__contract,
        });
    }
}
//# sourceMappingURL=simulate.js.map