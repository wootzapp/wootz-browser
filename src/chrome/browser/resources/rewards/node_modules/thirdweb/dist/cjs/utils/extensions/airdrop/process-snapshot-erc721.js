"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSnapshotERC721 = processSnapshotERC721;
const MerkleTree_js_1 = require("../../../merkletree/MerkleTree.js");
const upload_js_1 = require("../../../storage/upload.js");
const hash_entry_erc721_js_1 = require("./hash-entry-erc721.js");
async function processSnapshotERC721(options) {
    const shardNybbles = options.shardNybbles || 2;
    // 2. shard them into a map where the key is the first n digits of the address
    const shards = {};
    for (const snapshotEntry of options.snapshot) {
        const shard = snapshotEntry.recipient
            .slice(2, 2 + shardNybbles)
            .toLowerCase();
        if (shards[shard] === undefined) {
            shards[shard] = [];
        }
        // biome-ignore lint/style/noNonNullAssertion: we know it's defined
        shards[shard].push(snapshotEntry);
    }
    // 3. create the merkle subtrees for each shard
    const subTrees = await Promise.all(Object.entries(shards).map(async ([shard, entries]) => [
        shard,
        new MerkleTree_js_1.MerkleTree(await Promise.all(entries.map(async (entry) => {
            return (0, hash_entry_erc721_js_1.hashEntryERC721)({
                entry,
            });
        }))).getHexRoot(),
    ]));
    // 4. create the master merkle tree from all the subtrees
    const roots = Object.fromEntries(subTrees);
    const tree = new MerkleTree_js_1.MerkleTree(Object.values(roots));
    // 5. upload all the shards with filename <shardId>.json to easily retrieve
    const shardsToUpload = [];
    for (const [shardId, entries] of Object.entries(shards)) {
        const data = {
            // biome-ignore lint/style/noNonNullAssertion: we know this is in bounds
            proofs: tree.getHexProof(roots[shardId]),
            entries,
        };
        shardsToUpload.push({
            data: JSON.stringify(data),
            name: `${shardId}.json`,
        });
    }
    let uris = await (0, upload_js_1.upload)({
        client: options.client,
        files: shardsToUpload,
    });
    // in the case of just 1 shard -> upload returns a string, not an array
    if (!Array.isArray(uris)) {
        uris = [uris];
    }
    if (uris.length === 0) {
        throw new Error("No URIs returned from uploading merkle tree shards");
    }
    // biome-ignore lint/style/noNonNullAssertion: throws above if no URIs
    const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
    // 6. Also upload the original entries for retrieving all entries
    const originalEntriesUri = await (0, upload_js_1.upload)({
        client: options.client,
        files: [JSON.stringify(options.snapshot)],
    });
    // 7. assmeble the final sharded merkle tree info
    const shardedMerkleInfo = {
        merkleRoot: tree.getHexRoot(),
        baseUri,
        originalEntriesUri,
        shardNybbles,
        tokenDecimals: 0,
        isShardedMerkleTree: true,
    };
    // 8. upload the final sharded merkle tree info
    const finalUri = await (0, upload_js_1.upload)({
        client: options.client,
        files: [shardedMerkleInfo],
    });
    return {
        shardedMerkleInfo,
        uri: finalUri,
    };
}
//# sourceMappingURL=process-snapshot-erc721.js.map