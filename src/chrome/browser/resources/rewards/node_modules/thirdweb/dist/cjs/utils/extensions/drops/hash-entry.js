"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashEntry = hashEntry;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../constants/addresses.js");
const keccak256_js_1 = require("../../hashing/keccak256.js");
const convert_quantity_js_1 = require("./convert-quantity.js");
async function hashEntry(options) {
    const currencyAddress = options.entry.currencyAddress || addresses_js_1.ADDRESS_ZERO;
    const currencyDecimals = await (async () => {
        if ((0, addresses_js_1.isNativeTokenAddress)(currencyAddress) ||
            currencyAddress === addresses_js_1.ADDRESS_ZERO) {
            return 18;
        }
        const [{ getContract }, { decimals: getDecimals }] = await Promise.all([
            Promise.resolve().then(() => require("../../../contract/contract.js")),
            Promise.resolve().then(() => require("../../../extensions/erc20/read/decimals.js")),
        ]);
        const currencyContract = getContract({
            address: currencyAddress,
            chain: options.chain,
            client: options.client,
        });
        return await getDecimals({ contract: currencyContract });
    })();
    return (0, keccak256_js_1.keccak256)((0, viem_1.encodePacked)(["address", "uint256", "uint256", "address"], [
        options.entry.address,
        (0, convert_quantity_js_1.convertQuantity)({
            quantity: options.entry.maxClaimable || "unlimited",
            tokenDecimals: options.tokenDecimals,
        }),
        (0, convert_quantity_js_1.convertQuantity)({
            quantity: options.entry.price || "unlimited",
            tokenDecimals: currencyDecimals,
        }),
        currencyAddress,
    ]));
}
//# sourceMappingURL=hash-entry.js.map