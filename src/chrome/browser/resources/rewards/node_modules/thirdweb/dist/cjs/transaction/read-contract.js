"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readContract = readContract;
const abitype_1 = require("abitype");
const viem_1 = require("viem");
const utils_js_1 = require("./utils.js");
const eth_call_js_1 = require("../rpc/actions/eth_call.js");
const rpc_js_1 = require("../rpc/rpc.js");
const encodeAbiParameters_js_1 = require("../utils/abi/encodeAbiParameters.js");
const prepare_method_js_1 = require("../utils/abi/prepare-method.js");
/**
 * ### Reads state from a deployed smart contract.
 *
 * You can use raw read calls or read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) to read from a contract.
 *
 * @param options - The transaction options.
 * @returns A promise that resolves with the result of the read call.
 * @transaction
 * @example
 *
 * ### Using a contract read extension
 *
 * ```ts
 * import { getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 * import { getOwnedNFTs } form "thirdweb/extensions/erc721";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract(getOwnedNFTs, { contract, owner: address });
 * ```
 *
 * ### Using a raw contract call
 *
 * ```ts
 * import { getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: "function tokenURI(uint256 tokenId) returns (string)"}),
 *   params: [1n],
 * });
 * ```
 *
 * ### Using `resolveMethod`
 * ```ts
 * import { getContract, resolveMethod } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 * import { useReadContract } from "thirdweb/react";
 *
 * const contract = getContract({
 *   client,
 *   address: "0x...",
 *   chain: sepolia,
 * });
 *
 * const { data, isLoading } = useReadContract({
 *   contract,
 *   method: resolveMethod("tokenURI"),
 *   params: [1n],
 * });
 * ```
 */
async function readContract(options) {
    const { contract, method, params } = options;
    const resolvePreparedMethod = async () => {
        if (Array.isArray(method)) {
            return method;
        }
        if ((0, utils_js_1.isAbiFunction)(method)) {
            return (0, prepare_method_js_1.prepareMethod)(method);
        }
        if (typeof method === "function") {
            return (0, prepare_method_js_1.prepareMethod)(
            // @ts-expect-error - we're sure it's a function
            (await method(contract)));
        }
        // if the method starts with the string `function ` we always will want to try to parse it
        if (typeof method === "string" && method.startsWith("function ")) {
            // @ts-expect-error - method *is* string in this case
            const abiItem = (0, abitype_1.parseAbiItem)(method);
            if (abiItem.type === "function") {
                return (0, prepare_method_js_1.prepareMethod)(abiItem);
            }
            throw new Error(`"method" passed is not of type "function"`);
        }
        // check if we have a "abi" on the contract
        if (contract.abi && contract.abi?.length > 0) {
            // extract the abiFunction from it
            const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
            // if we were able to find it -> return it
            if (abiFunction) {
                return (0, prepare_method_js_1.prepareMethod)(abiFunction);
            }
        }
        throw new Error(`Could not resolve method "${method}".`);
    };
    // resolve in parallel
    const [resolvedPreparedMethod, resolvedParams] = await Promise.all([
        resolvePreparedMethod(),
        typeof params === "function" ? params() : params,
    ]);
    let encodedData;
    // if we have no inputs, we know it's just the signature
    if (resolvedPreparedMethod[1].length === 0) {
        encodedData = resolvedPreparedMethod[0];
    }
    else {
        // we do a "manual" concat here to avoid the overhead of the "concatHex" function
        // we can do this because we know the specific formats of the values
        encodedData = (resolvedPreparedMethod[0] +
            (0, encodeAbiParameters_js_1.encodeAbiParameters)(resolvedPreparedMethod[1], 
            // @ts-expect-error - TODO: fix this type issue
            resolvedParams).slice(2));
    }
    const rpcRequest = (0, rpc_js_1.getRpcClient)({
        chain: contract.chain,
        client: contract.client,
    });
    const result = await (0, eth_call_js_1.eth_call)(rpcRequest, {
        data: encodedData,
        to: contract.address,
        from: options.from,
    });
    // use the prepared method to decode the result
    const decoded = (0, viem_1.decodeAbiParameters)(resolvedPreparedMethod[2], result);
    if (Array.isArray(decoded) && decoded.length === 1) {
        return decoded[0];
    }
    return decoded;
}
//# sourceMappingURL=read-contract.js.map