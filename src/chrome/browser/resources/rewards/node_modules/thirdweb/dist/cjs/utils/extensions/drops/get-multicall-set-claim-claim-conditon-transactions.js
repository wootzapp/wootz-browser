"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMulticallSetClaimConditionTransactions = getMulticallSetClaimConditionTransactions;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../constants/addresses.js");
const upload_js_1 = require("../../../storage/upload.js");
const date_js_1 = require("../../date.js");
const hex_js_1 = require("../../encoding/hex.js");
const convert_erc20_amount_js_1 = require("../convert-erc20-amount.js");
const process_override_list_js_1 = require("./process-override-list.js");
async function getMulticallSetClaimConditionTransactions(options) {
    const merkleInfos = {};
    const phases = await Promise.all(options.phases.map(async (phase) => {
        // allowlist
        let merkleRoot = phase.merkleRootHash || (0, hex_js_1.toHex)("", { size: 32 });
        if (phase.overrideList) {
            const { shardedMerkleInfo, uri } = await (0, process_override_list_js_1.processOverrideList)({
                overrides: phase.overrideList,
                client: options.contract.client,
                chain: options.contract.chain,
                tokenDecimals: options.tokenDecimals,
            });
            merkleInfos[shardedMerkleInfo.merkleRoot] = uri;
            merkleRoot = shardedMerkleInfo.merkleRoot;
        }
        // metadata
        let metadata = "";
        if (phase.metadata && typeof phase.metadata === "string") {
            metadata = phase.metadata;
        }
        else if (phase.metadata && typeof phase.metadata === "object") {
            metadata = await (0, upload_js_1.upload)({
                client: options.contract.client,
                files: [phase.metadata],
            });
        }
        return {
            startTimestamp: (0, date_js_1.dateToSeconds)(phase.startTime ?? new Date(0)),
            currency: phase.currencyAddress || addresses_js_1.NATIVE_TOKEN_ADDRESS,
            pricePerToken: await (0, convert_erc20_amount_js_1.convertErc20Amount)({
                chain: options.contract.chain,
                client: options.contract.client,
                erc20Address: phase.currencyAddress || addresses_js_1.NATIVE_TOKEN_ADDRESS,
                amount: phase.price?.toString() ?? "0",
            }),
            maxClaimableSupply: phase.maxClaimableSupply ?? viem_1.maxUint256,
            quantityLimitPerWallet: phase.maxClaimablePerWallet ?? viem_1.maxUint256,
            merkleRoot,
            metadata,
            supplyClaimed: 0n,
        };
    }));
    const encodedTransactions = [];
    // if we have new merkle roots, we need to upload them to the contract metadata
    if (Object.keys(merkleInfos).length > 0) {
        const [{ getContractMetadata }, { encodeSetContractURI }] = await Promise.all([
            Promise.resolve().then(() => require("../../../extensions/common/read/getContractMetadata.js")),
            Promise.resolve().then(() => require("../../../extensions/common/__generated__/IContractMetadata/write/setContractURI.js")),
        ]);
        const metadata = await getContractMetadata({
            contract: options.contract,
        });
        // keep the old merkle roots from other tokenIds
        for (const key of Object.keys(metadata.merkle || {})) {
            merkleInfos[key] = metadata.merkle[key];
        }
        const mergedMetadata = {
            ...metadata,
            merkle: merkleInfos,
        };
        const uri = await (0, upload_js_1.upload)({
            client: options.contract.client,
            files: [mergedMetadata],
        });
        const encodedSetContractURI = encodeSetContractURI({
            uri,
        });
        encodedTransactions.push(encodedSetContractURI);
    }
    const sortedPhases = phases.sort((a, b) => Number(a.startTimestamp - b.startTimestamp));
    let encodedSetClaimConditions;
    if (options.tokenId !== undefined) {
        // 1155
        const { encodeSetClaimConditions } = await Promise.resolve().then(() => require("../../../extensions/erc1155/__generated__/IDrop1155/write/setClaimConditions.js"));
        encodedSetClaimConditions = encodeSetClaimConditions({
            tokenId: options.tokenId,
            phases: sortedPhases,
            resetClaimEligibility: options.resetClaimEligibility || false,
        });
    }
    else {
        // 721
        const { encodeSetClaimConditions } = await Promise.resolve().then(() => require("../../../extensions/erc721/__generated__/IDrop/write/setClaimConditions.js"));
        encodedSetClaimConditions = encodeSetClaimConditions({
            phases: sortedPhases,
            resetClaimEligibility: options.resetClaimEligibility || false,
        });
    }
    encodedTransactions.push(encodedSetClaimConditions);
    return encodedTransactions;
}
//# sourceMappingURL=get-multicall-set-claim-claim-conditon-transactions.js.map