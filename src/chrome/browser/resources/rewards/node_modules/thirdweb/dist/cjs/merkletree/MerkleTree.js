"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTree = void 0;
// ADAPTED FROM https://github.com/merkletreejs/merkletreejs
const hex_js_1 = require("../utils/encoding/hex.js");
const to_bytes_js_1 = require("../utils/encoding/to-bytes.js");
const keccak256_js_1 = require("../utils/hashing/keccak256.js");
const uint8_array_js_1 = require("../utils/uint8-array.js");
/**
 * Class reprensenting a Merkle Tree
 * @namespace MerkleTree
 */
class MerkleTree {
    constructor(leaves) {
        Object.defineProperty(this, "leaves", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "layers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.leaves = leaves.map((el) => el instanceof Uint8Array ? el : (0, to_bytes_js_1.hexToBytes)(el));
        this.leaves = this.leaves.sort(uint8_array_js_1.compareUint8Arrays);
        this.createHashes(this.leaves);
    }
    getHexRoot() {
        return (0, hex_js_1.uint8ArrayToHex)(this.getRoot());
    }
    getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item) => (0, hex_js_1.uint8ArrayToHex)(item.data));
    }
    // private below
    createHashes(nodes) {
        this.layers = [nodes];
        while (nodes.length > 1) {
            const layerIndex = this.layers.length;
            this.layers.push([]);
            const layerLimit = nodes.length;
            for (let i = 0; i < nodes.length; i += 2) {
                if (i >= layerLimit) {
                    // biome-ignore lint/style/noNonNullAssertion: in bounds
                    this.layers[layerIndex].push(...nodes.slice(layerLimit));
                    break;
                }
                if (i + 1 === nodes.length) {
                    if (nodes.length % 2 === 1) {
                        // push copy of hash and continue iteration
                        // biome-ignore lint/style/noNonNullAssertion: in bounds
                        this.layers[layerIndex].push(nodes[i]);
                        continue;
                    }
                }
                // biome-ignore lint/style/noNonNullAssertion: in bounds
                const left = nodes[i];
                // biome-ignore lint/style/noNonNullAssertion: in bounds
                const right = i + 1 === nodes.length ? left : nodes[i + 1];
                const combined = [left, right];
                combined.sort(uint8_array_js_1.compareUint8Arrays);
                const hash = (0, keccak256_js_1.keccak256)((0, uint8_array_js_1.concatUint8Arrays)(combined), "bytes");
                // biome-ignore lint/style/noNonNullAssertion: in bounds
                this.layers[layerIndex].push(hash);
            }
            // biome-ignore lint/style/noParameterAssign: part of the functionality
            // biome-ignore lint/style/noNonNullAssertion: in bounds
            nodes = this.layers[layerIndex];
        }
    }
    getRoot() {
        if (this.layers.length === 0) {
            return new Uint8Array();
        }
        // biome-ignore lint/style/noNonNullAssertion: in bounds
        return this.layers[this.layers.length - 1][0] || new Uint8Array();
    }
    getProof(leaf, index) {
        if (typeof leaf === "undefined") {
            throw new Error("leaf is required");
        }
        // biome-ignore lint/style/noParameterAssign: part of the functionality
        leaf = leaf instanceof Uint8Array ? leaf : (0, to_bytes_js_1.hexToBytes)(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
            // biome-ignore lint/style/noParameterAssign: part of the functionality
            index = -1;
            for (let i = 0; i < this.leaves.length; i++) {
                // biome-ignore lint/style/noNonNullAssertion: within bounds
                if ((0, uint8_array_js_1.areUint8ArraysEqual)(leaf, this.leaves[i])) {
                    // biome-ignore lint/style/noParameterAssign: part of the functionality
                    index = i;
                }
            }
        }
        // @ts-expect-error - issue from original code
        if (index <= -1) {
            return [];
        }
        for (let i = 0; i < this.layers.length; i++) {
            // biome-ignore lint/style/noNonNullAssertion: in bounds
            const layer = this.layers[i];
            // @ts-expect-error - issue from original code
            const isRightNode = index % 2;
            const pairIndex = isRightNode
                ? // @ts-expect-error - issue from original code
                    index - 1
                : // Proof Generation for Non-Bitcoin Trees
                    // @ts-expect-error - issue from original code
                    index + 1;
            if (pairIndex < layer.length) {
                proof.push({
                    position: isRightNode ? "left" : "right",
                    data: layer[pairIndex],
                });
            }
            // set index to parent index
            // @ts-expect-error - issue from original code
            // biome-ignore lint/style/noParameterAssign: part of the functionality
            index = (index / 2) | 0;
        }
        // @ts-expect-error - issue from original code
        return proof;
    }
}
exports.MerkleTree = MerkleTree;
//# sourceMappingURL=MerkleTree.js.map