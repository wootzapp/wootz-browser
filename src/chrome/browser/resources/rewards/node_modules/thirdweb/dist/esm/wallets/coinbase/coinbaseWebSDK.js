import { getTypesForEIP712Domain, serializeTypedData, validateTypedData, } from "viem";
import { getValidPublicRPCUrl } from "../utils/chains.js";
import { normalizeChainId } from "../utils/normalizeChainId.js";
import { getCachedChain, getChainMetadata } from "../../chains/utils.js";
import { getAddress } from "../../utils/address.js";
import { numberToHex, stringToHex, uint8ArrayToHex, } from "../../utils/encoding/hex.js";
import { parseTypedData } from "../../utils/signatures/helpers/parseTypedData.js";
import { COINBASE } from "../constants.js";
import { getDefaultAppMetadata } from "../utils/defaultDappMetadata.js";
import { showCoinbasePopup } from "./utils.js";
// Need to keep the provider around because it keeps a single popup window connection behind the scenes
// this should be ok since all the creation options are provided at build time
let _provider;
/**
 * @internal
 */
export async function getCoinbaseWebProvider(options) {
    if (!_provider) {
        let CoinbaseWalletSDK = (await import("@coinbase/wallet-sdk"))
            .default;
        // Workaround for Vite dev import errors
        // https://github.com/vitejs/vite/issues/7112
        if (typeof CoinbaseWalletSDK !== "function" &&
            typeof CoinbaseWalletSDK.default === "function") {
            CoinbaseWalletSDK = CoinbaseWalletSDK.default;
        }
        // @ts-expect-error This import error is not visible to TypeScript
        const client = new CoinbaseWalletSDK({
            appName: options?.appMetadata?.name || getDefaultAppMetadata().name,
            appChainIds: options?.chains
                ? options.chains.map((c) => c.id)
                : undefined,
            appLogoUrl: options?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,
        });
        const provider = client.makeWeb3Provider(options?.walletConfig);
        _provider = provider;
        return provider;
    }
    return _provider;
}
/**
 * Checks if the provided wallet is a Coinbase SDK wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is a Coinbase SDK wallet, false otherwise.
 */
export function isCoinbaseSDKWallet(wallet) {
    return wallet.id === COINBASE;
}
/**
 * @internal
 */
export async function coinbaseSDKWalletGetCapabilities(args) {
    const { wallet } = args;
    const account = wallet.getAccount();
    if (!account) {
        return {
            message: `Can't get capabilities, no account connected for wallet: ${wallet.id}`,
        };
    }
    const config = wallet.getConfig();
    const provider = await getCoinbaseWebProvider(config);
    try {
        return (await provider.request({
            method: "wallet_getCapabilities",
            params: [account.address],
        }));
    }
    catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
            return {
                message: `${wallet.id} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`,
            };
        }
        throw error;
    }
}
/**
 * @internal
 */
export async function coinbaseSDKWalletSendCalls(args) {
    const { wallet, params } = args;
    const config = wallet.getConfig();
    const provider = await getCoinbaseWebProvider(config);
    try {
        return (await provider.request({
            method: "wallet_sendCalls",
            params,
        }));
    }
    catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
            throw new Error(`${wallet.id} does not support wallet_sendCalls, reach out to them directly to request EIP-5792 support.`);
        }
        throw error;
    }
}
/**
 * @internal
 */
export async function coinbaseSDKWalletShowCallsStatus(args) {
    const { wallet, bundleId } = args;
    const provider = await getCoinbaseWebProvider(wallet.getConfig());
    try {
        return await provider.request({
            method: "wallet_showCallsStatus",
            params: [bundleId],
        });
    }
    catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
            throw new Error(`${wallet.id} does not support wallet_showCallsStatus, reach out to them directly to request EIP-5792 support.`);
        }
        throw error;
    }
}
/**
 * @internal
 */
export async function coinbaseSDKWalletGetCallsStatus(args) {
    const { wallet, bundleId } = args;
    const config = wallet.getConfig();
    const provider = await getCoinbaseWebProvider(config);
    return provider.request({
        method: "wallet_getCallsStatus",
        params: [bundleId],
    });
}
function createAccount(provider, _address) {
    const address = getAddress(_address);
    const account = {
        address,
        async sendTransaction(tx) {
            const transactionHash = (await provider.request({
                method: "eth_sendTransaction",
                params: [
                    {
                        accessList: tx.accessList,
                        value: tx.value ? numberToHex(tx.value) : undefined,
                        gas: tx.gas ? numberToHex(tx.gas) : undefined,
                        from: this.address,
                        to: tx.to,
                        data: tx.data,
                    },
                ],
            }));
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            if (!account.address) {
                throw new Error("Provider not setup");
            }
            const messageToSign = (() => {
                if (typeof message === "string") {
                    return stringToHex(message);
                }
                if (message.raw instanceof Uint8Array) {
                    return uint8ArrayToHex(message.raw);
                }
                return message.raw;
            })();
            return await provider.request({
                method: "personal_sign",
                params: [messageToSign, account.address],
            });
        },
        async signTypedData(_typedData) {
            if (!account.address) {
                throw new Error("Provider not setup");
            }
            const typedData = parseTypedData(_typedData);
            const { domain, message, primaryType } = typedData;
            const types = {
                EIP712Domain: getTypesForEIP712Domain({ domain }),
                ...typedData.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            validateTypedData({ domain, message, primaryType, types });
            const stringifiedData = serializeTypedData({
                domain: domain ?? {},
                message,
                primaryType,
                types,
            });
            return await provider.request({
                method: "eth_signTypedData_v4",
                params: [account.address, stringifiedData],
            });
        },
        onTransactionRequested: async () => {
            // make sure to show the coinbase popup BEFORE doing any transaction preprocessing
            // otherwise the popup might get blocked in safari
            await showCoinbasePopup(provider);
        },
    };
    return account;
}
function onConnect(address, chain, provider, emitter) {
    const account = createAccount(provider, address);
    async function disconnect() {
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
        await provider.disconnect();
    }
    async function onDisconnect() {
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts[0]) {
            const newAccount = createAccount(provider, getAddress(accounts[0]));
            emitter.emit("accountChanged", newAccount);
            emitter.emit("accountsChanged", accounts);
        }
        else {
            onDisconnect();
        }
    }
    function onChainChanged(newChainId) {
        const newChain = getCachedChain(normalizeChainId(newChainId));
        emitter.emit("chainChanged", newChain);
    }
    // subscribe to events
    provider.on("accountsChanged", onAccountsChanged);
    provider.on("chainChanged", onChainChanged);
    provider.on("disconnect", onDisconnect);
    return [
        account,
        chain,
        onDisconnect,
        (newChain) => switchChainCoinbaseWalletSDK(provider, newChain),
    ];
}
/**
 * @internal
 */
export async function connectCoinbaseWalletSDK(options, emitter, provider) {
    const accounts = (await provider.request({
        method: "eth_requestAccounts",
    }));
    if (!accounts[0]) {
        throw new Error("No accounts found");
    }
    const address = getAddress(accounts[0]);
    const connectedChainId = (await provider.request({
        method: "eth_chainId",
    }));
    const chainId = normalizeChainId(connectedChainId);
    let chain = options.chain && options.chain.id === chainId
        ? options.chain
        : getCachedChain(chainId);
    // Switch to chain if provided
    if (connectedChainId &&
        options?.chain &&
        connectedChainId !== options?.chain.id) {
        await switchChainCoinbaseWalletSDK(provider, options.chain);
        chain = options.chain;
    }
    return onConnect(address, chain, provider, emitter);
}
/**
 * @internal
 */
export async function autoConnectCoinbaseWalletSDK(options, emitter, provider) {
    // connected accounts
    const addresses = (await provider.request({
        method: "eth_accounts",
    }));
    const address = addresses[0];
    if (!address) {
        throw new Error("No accounts found");
    }
    const connectedChainId = (await provider.request({
        method: "eth_chainId",
    }));
    const chainId = normalizeChainId(connectedChainId);
    const chain = options.chain && options.chain.id === chainId
        ? options.chain
        : getCachedChain(chainId);
    return onConnect(address, chain, provider, emitter);
}
async function switchChainCoinbaseWalletSDK(provider, chain) {
    const chainIdHex = numberToHex(chain.id);
    try {
        await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: chainIdHex }],
        });
    }
    catch (error) {
        const apiChain = await getChainMetadata(chain);
        // Indicates chain is not added to provider
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
        if (error?.code === 4902) {
            // try to add the chain
            await provider.request({
                method: "wallet_addEthereumChain",
                params: [
                    {
                        chainId: chainIdHex,
                        chainName: apiChain.name,
                        nativeCurrency: apiChain.nativeCurrency,
                        rpcUrls: getValidPublicRPCUrl(apiChain), // no client id on purpose here
                        blockExplorerUrls: apiChain.explorers?.map((x) => x.url) || [],
                    },
                ],
            });
        }
    }
}
//# sourceMappingURL=coinbaseWebSDK.js.map