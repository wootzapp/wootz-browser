"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrDeployInfraForPublishedContract = getOrDeployInfraForPublishedContract;
exports.deployCloneFactory = deployCloneFactory;
exports.deployImplementation = deployImplementation;
exports.getOrDeployInfraContract = getOrDeployInfraContract;
const send_and_confirm_transaction_js_1 = require("../../../transaction/actions/send-and-confirm-transaction.js");
const isZkSyncChain_js_1 = require("../../../utils/any-evm/zksync/isZkSyncChain.js");
const contract_js_1 = require("../../contract.js");
const publisher_js_1 = require("../publisher.js");
const zkDeployCreate2Factory_js_1 = require("../zksync/zkDeployCreate2Factory.js");
const zkDeployDeterministic_js_1 = require("../zksync/zkDeployDeterministic.js");
const clone_factory_js_1 = require("./clone-factory.js");
const create_2_factory_js_1 = require("./create-2-factory.js");
const infra_js_1 = require("./infra.js");
/**
 * @internal
 */
async function getOrDeployInfraForPublishedContract(args) {
    const { chain, client, account, contractId, constructorParams, publisher, version, } = args;
    if ((0, isZkSyncChain_js_1.isZkSyncChain)(chain)) {
        const cloneFactoryContract = await (0, zkDeployCreate2Factory_js_1.zkDeployCreate2Factory)({
            chain,
            client,
            account,
        });
        const { compilerMetadata } = await (0, publisher_js_1.fetchPublishedContractMetadata)({
            client,
            contractId: `${contractId}_ZkSync`, // different contract id for zkSync
            publisher,
            version,
        });
        const implementationContract = await (0, zkDeployDeterministic_js_1.zkDeployContractDeterministic)({
            chain,
            client,
            account,
            abi: compilerMetadata.abi,
            bytecode: compilerMetadata.bytecode,
            params: constructorParams,
        });
        return {
            cloneFactoryContract: (0, contract_js_1.getContract)({
                address: cloneFactoryContract,
                chain,
                client,
            }),
            implementationContract: (0, contract_js_1.getContract)({
                address: implementationContract,
                chain,
                client,
            }),
        };
    }
    let [cloneFactoryContract, implementationContract] = await Promise.all([
        (0, clone_factory_js_1.getDeployedCloneFactoryContract)({
            chain,
            client,
        }),
        (0, infra_js_1.getDeployedInfraContract)({
            chain,
            client,
            contractId,
            constructorParams,
            publisher,
            version,
        }),
    ]);
    if (!implementationContract || !cloneFactoryContract) {
        // deploy the infra and implementation contracts if not found
        cloneFactoryContract = await deployCloneFactory({
            client,
            chain,
            account,
        });
        implementationContract = await deployImplementation({
            client,
            chain,
            account,
            contractId,
            constructorParams,
            publisher,
            version,
        });
    }
    return { cloneFactoryContract, implementationContract };
}
/**
 * @internal
 * @returns the deployed clone factory contract
 */
async function deployCloneFactory(options) {
    // create2 factory
    const create2Factory = await (0, create_2_factory_js_1.getDeployedCreate2Factory)(options);
    if (!create2Factory) {
        await (0, create_2_factory_js_1.deployCreate2Factory)(options);
    }
    // Forwarder
    const forwarder = await getOrDeployInfraContract({
        ...options,
        contractId: "Forwarder",
        constructorParams: [],
    });
    // clone factory
    return getOrDeployInfraContract({
        ...options,
        contractId: "TWCloneFactory",
        constructorParams: [forwarder.address],
    });
}
/**
 * @internal
 * @returns the deployed infra contract
 */
async function deployImplementation(options) {
    return getOrDeployInfraContract({
        ...options,
        contractId: options.contractId,
        constructorParams: options.constructorParams || [],
        publisher: options.publisher,
        version: options.version,
    });
}
/**
 * Convenience function to get or deploy an infra contract
 * @internal
 */
async function getOrDeployInfraContract(options) {
    const infraContract = await (0, infra_js_1.getDeployedInfraContract)(options);
    if (infraContract) {
        return infraContract;
    }
    const transaction = (0, infra_js_1.prepareInfraContractDeployTransaction)(options);
    await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
        transaction,
        account: options.account,
    });
    const deployedInfraContract = await (0, infra_js_1.getDeployedInfraContract)(options);
    if (!deployedInfraContract) {
        throw new Error(`Failed to deploy ${options.contractId}`);
    }
    return deployedInfraContract;
}
//# sourceMappingURL=bootstrap.js.map