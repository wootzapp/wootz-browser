import { parseAbiItem, } from "abitype";
import { encodeAbiParameters } from "../utils/abi/encodeAbiParameters.js";
import { prepareMethod, } from "../utils/abi/prepare-method.js";
import { resolvePromisedValue } from "../utils/promise/resolve-promised-value.js";
import { prepareTransaction, } from "./prepare-transaction.js";
import { isAbiFunction } from "./utils.js";
/**
 * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.
 * @param options - The options for preparing the contract call.
 * @returns A promise that resolves to the prepared transaction.
 * @transaction
 * @example
 *
 * ### Usage with a human-readable method signature:
 *
 * ```ts
 * import { prepareContractCall } from "thirdweb";
 *
 * const transaction = prepareContractCall({
 *  contract,
 *  method: "function transfer(address to, uint256 value)",
 *  params: [to, value],
 * });
 * ```
 *
 * ### Usage with explicit gas price and/or value:
 *
 * ```ts
 * import { prepareContractCall } from "thirdweb";
 * import { toWei } from "thirdweb/utils";
 *
 * const transaction = prepareContractCall({
 *  contract,
 *  method: "function transfer(address to, uint256 value)",
 *  params: [to, value],
 *  maxFeePerGas: 30n,
 *  maxPriorityFeePerGas: 1n,
 *  value: toWei("0.01"),
 * });
 * ```
 *
 * ### Usage with a JSON ABI function object:
 *
 * ```ts
 * import { prepareContractCall } from "thirdweb";
 *
 * const transaction = prepareContractCall({
 *  contract,
 *  method: {
 *    name: "transfer",
 *    type: "function",
 *    inputs: [
 *      { name: "to", type: "address" },
 *      { name: "value", type: "uint256" },
 *    ],
 *    outputs: [],
 *    stateMutability: "payable"
 *   },
 *  params: [to, value],
 * });
 * ```
 *
 * ### Usage with the ABI defined on the contract:
 *
 * ```ts
 * import { getContract, prepareContractCall } from "thirdweb";
 * const contract = getContract({
 *  ..., // chain, address, client
 *  abi: [...] // ABI with a "transfer" method
 * });
 * const transaction = prepareContractCall({
 *  contract,
 *  method: "transfer", // <- this gets inferred from the contract
 *  params: [to, value],
 * });
 * ```
 *
 * ### Passing extra call data to the transaction
 * ```ts
 * import { getContract, prepareContractCall } from "thirdweb";
 * const contract = getContract({
 *   ..., // chain, address, client
 * });
 *
 * const transaction = prepareContractCall({
 *   contract,
 *   method: "function transfer(address to, uint256 value)",
 *   params: [...],
 *   // The extra call data MUST be encoded to hex before passing
 *   extraCallData: "0x......."
 * });
 * ```
 */
export function prepareContractCall(options) {
    const { contract, method, params, ...rest } = options;
    const preparedMethodPromise = () => (async () => {
        if (Array.isArray(method)) {
            return method;
        }
        if (isAbiFunction(method)) {
            return prepareMethod(method);
        }
        if (typeof method === "function") {
            return prepareMethod(
            // @ts-expect-error - method *is* function in this case
            (await method(contract)));
        }
        // if the method starts with the string `function ` we always will want to try to parse it
        if (typeof method === "string" && method.startsWith("function ")) {
            // @ts-expect-error - method *is* string in this case
            const abiItem = parseAbiItem(method);
            if (abiItem.type === "function") {
                return prepareMethod(abiItem);
            }
            throw new Error(`"method" passed is not of type "function"`);
        }
        // check if we have a "abi" on the contract
        if (contract.abi && contract.abi?.length > 0) {
            // extract the abiFunction from it
            const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
            // if we were able to find it -> return it
            if (abiFunction) {
                return prepareMethod(abiFunction);
            }
        }
        throw new Error(`Could not resolve method "${method}".`);
    })();
    return prepareTransaction({
        ...rest,
        // these always inferred from the contract
        to: contract.address,
        chain: contract.chain,
        client: contract.client,
        data: async () => {
            let preparedM;
            if (Array.isArray(method)) {
                preparedM = method;
            }
            else {
                preparedM = await preparedMethodPromise();
            }
            if (preparedM[1].length === 0) {
                // just return the fn sig directly -> no params
                return preparedM[0];
            }
            // we do a "manual" concat here to avoid the overhead of the "concatHex" function
            // we can do this because we know the specific formats of the values
            return (preparedM[0] +
                encodeAbiParameters(preparedM[1], 
                // @ts-expect-error - TODO: fix this type issue
                await resolvePromisedValue(params ?? [])).slice(2));
        },
    }, {
        preparedMethod: preparedMethodPromise,
        contract: contract,
    });
}
//# sourceMappingURL=prepare-contract-call.js.map