"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForBundle = waitForBundle;
const watchBlockNumber_js_1 = require("../../rpc/watchBlockNumber.js");
const get_calls_status_js_1 = require("./get-calls-status.js");
const DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;
const map = new Map();
/**
 * Waits for the [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) bundle to be confirmed.
 *
 * @note This function is dependent on the wallet's support for EIP-5792 and could fail.
 *
 * @param options - The options for waiting for the bundle.
 * By default, the max wait time is 100 blocks.
 * @returns A promise that resolves with the final {@link getCallsStatus} result.
 * @throws an error if the wallet does not support EIP-5792.
 * @beta
 * @example
 * ```ts
 * import { waitForBundle } from "thirdweb/wallets/eip5792";
 * const result = await waitForBundle({
 *   client,
 *   chain,
 *   wallet,
 *   bundleId: "0x123...",
 * });
 * ```
 * @extension EIP5792
 */
function waitForBundle(options) {
    const { bundleId, chain, wallet, client } = options;
    const chainId = chain.id;
    const key = `${chainId}:calls_${bundleId}`;
    const maxBlocksWaitTime = options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;
    if (map.has(key)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return map.get(key);
    }
    const promise = new Promise((resolve, reject) => {
        // start at -1 because the first block doesn't count
        let blocksWaited = -1;
        const unwatch = (0, watchBlockNumber_js_1.watchBlockNumber)({
            client: client,
            chain: chain,
            onNewBlockNumber: async () => {
                blocksWaited++;
                if (blocksWaited >= maxBlocksWaitTime) {
                    unwatch();
                    reject(new Error(`Bundle not confirmed after ${maxBlocksWaitTime} blocks`));
                    return;
                }
                try {
                    const result = await (0, get_calls_status_js_1.getCallsStatus)({
                        wallet,
                        client,
                        bundleId,
                    });
                    if (result.status === "CONFIRMED") {
                        // stop the polling
                        unwatch();
                        // resolve the top level promise with the result
                        resolve(result);
                    }
                }
                catch {
                    // noop, we'll try again on the next blocks
                }
            },
        });
        // remove the promise from the map when it's done (one way or the other)
    }).finally(() => {
        map.delete(key);
    });
    map.set(key, promise);
    return promise;
}
//# sourceMappingURL=wait-for-bundle.js.map