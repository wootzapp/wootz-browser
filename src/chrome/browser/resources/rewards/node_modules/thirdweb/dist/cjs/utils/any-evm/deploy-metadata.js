"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchDeployMetadata = fetchDeployMetadata;
const compiler_metadata_js_1 = require("../../contract/actions/compiler-metadata.js");
const download_js_1 = require("../../storage/download.js");
/**
 * Fetches the deployment metadata.
 * @param options - The options for fetching the deploy metadata.
 * @returns An object containing the compiler metadata and extended metadata.
 * @internal
 */
async function fetchDeployMetadata(options) {
    const [compilerMetadata, extendedMetadata] = await Promise.all([
        fetchCompilerMetadata(options),
        fetchExtendedMetadata(options).catch(() => undefined),
    ]);
    return { compilerMetadata, extendedMetadata };
}
// helpers
/**
 * Fetches the published metadata.
 * @param options - The options for fetching the published metadata.
 * @internal
 */
async function fetchExtendedMetadata(options) {
    return (0, download_js_1.download)({
        uri: options.uri,
        client: options.client,
    }).then((r) => r.json());
}
async function fetchCompilerMetadata(options) {
    const rawMeta = await (0, download_js_1.download)({
        uri: options.uri,
        client: options.client,
    }).then((r) => r.json());
    // TODO: proper handling of different compiler metadata types
    const metadataUri = rawMeta.compilers?.zksolc?.length > 0 && rawMeta.name.endsWith("_ZkSync")
        ? rawMeta.compilers.zksolc[0].metadataUri
        : rawMeta.metadataUri;
    const bytecodeUri = rawMeta.compilers?.zksolc?.length > 0 && rawMeta.name.endsWith("_ZkSync")
        ? rawMeta.compilers.zksolc[0].bytecodeUri
        : rawMeta.bytecodeUri;
    const [deployBytecode, parsedMeta] = await Promise.all([
        (0, download_js_1.download)({ uri: bytecodeUri, client: options.client }).then((res) => res.text()),
        fetchAndParseCompilerMetadata({
            client: options.client,
            uri: metadataUri,
        }),
    ]);
    return {
        ...rawMeta,
        ...parsedMeta,
        bytecode: deployBytecode,
    };
}
const CONTRACT_METADATA_TIMEOUT_SEC = 2 * 1000;
async function fetchAndParseCompilerMetadata(options) {
    // short timeout to avoid hanging on unpinned contract metadata CIDs
    const metadata = await (await (0, download_js_1.download)({
        ...options,
        requestTimeoutMs: CONTRACT_METADATA_TIMEOUT_SEC,
    })).json();
    if (!metadata || !metadata.output) {
        throw new Error(`Could not resolve metadata for contract at ${options.uri}`);
    }
    return (0, compiler_metadata_js_1.formatCompilerMetadata)(metadata);
}
//# sourceMappingURL=deploy-metadata.js.map