"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUpdateTokenURISupported = void 0;
exports.updateTokenURI = updateTokenURI;
const upload_js_1 = require("../../../storage/upload.js");
const setTokenURI_js_1 = require("../../erc1155/__generated__/INFTMetadata/write/setTokenURI.js");
var setTokenURI_js_2 = require("../../erc1155/__generated__/INFTMetadata/write/setTokenURI.js");
Object.defineProperty(exports, "isUpdateTokenURISupported", { enumerable: true, get: function () { return setTokenURI_js_2.isSetTokenURISupported; } });
/**
 * This function is an abstracted layer of the [`setTokenURI` extension](https://portal.thirdweb.com/references/typescript/v5/erc1155/setTokenURI),
 * which means it uses `setTokenURI` under the hood.
 * While the `setTokenURI` method only takes in a uri string, this extension takes in a user-friendly [`NFTInput`](https://portal.thirdweb.com/references/typescript/v5/NFTInput),
 * upload that content to IPFS and pass the IPFS URI (of said `NFTInput`) to the underlying `setTokenURI` method.
 *
 * This extension does not validate the NFTInput so make sure you are passing the proper content that you want to update.
 *
 * @extension ERC1155
 * @returns the prepared transaction from `setTokenURI`
 * @example
 * ```ts
 * import { updateTokenURI } from "thirdweb/extensions/erc1155";
 *
 * const transaction = updateTokenURI({
 *   tokenId: 0n,
 *   nft: {
 *     name: "new name",
 *     description: "new description",
 *     image: "https://image-host.com/new-image.png",
 *   },
 * });
 * ```
 */
function updateTokenURI(options) {
    const { contract } = options;
    return (0, setTokenURI_js_1.setTokenURI)({
        contract,
        asyncParams: async () => getUpdateTokenParams(options),
    });
}
async function getUpdateTokenParams(options) {
    const { tokenId, newMetadata } = options;
    const batch = [
        // image URI resolution
        (async () => {
            if (!newMetadata.image) {
                return "";
            }
            if (typeof newMetadata.image === "string") {
                return newMetadata.image;
            }
            return await (0, upload_js_1.upload)({
                client: options.contract.client,
                files: [newMetadata.image],
            });
        })(),
        // animation URI resolution
        (async () => {
            if (!newMetadata.animation_url) {
                return "";
            }
            if (typeof newMetadata.animation_url === "string") {
                return newMetadata.animation_url;
            }
            return await (0, upload_js_1.upload)({
                client: options.contract.client,
                files: [newMetadata.animation_url],
            });
        })(),
    ];
    const [imageURI, animationURI] = await Promise.all(batch);
    if (newMetadata.image && imageURI) {
        newMetadata.image = imageURI;
    }
    if (newMetadata.animation_url && animationURI) {
        newMetadata.animation_url = animationURI;
    }
    const uri = await (0, upload_js_1.upload)({
        client: options.contract.client,
        files: [newMetadata],
    });
    return { tokenId, uri };
}
//# sourceMappingURL=updateTokenURI.js.map