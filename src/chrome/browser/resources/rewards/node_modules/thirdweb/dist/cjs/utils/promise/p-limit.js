"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pLimit = pLimit;
// source code of yocto-queue + modified to add types
// https://github.com/sindresorhus/yocto-queue
class Node {
    constructor(value) {
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "next", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.value = value;
    }
}
class Queue {
    constructor() {
        Object.defineProperty(this, "head", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.clear();
        this.size = 0;
    }
    enqueue(value) {
        const node = new Node(value);
        if (this.head) {
            if (this.tail) {
                this.tail.next = node;
            }
            this.tail = node;
        }
        else {
            this.head = node;
            this.tail = node;
        }
        this.size++;
    }
    dequeue() {
        const current = this.head;
        if (!current) {
            return;
        }
        this.head = this.head?.next;
        this.size--;
        return current.value;
    }
    clear() {
        this.head = undefined;
        this.tail = undefined;
        this.size = 0;
    }
    *[Symbol.iterator]() {
        let current = this.head;
        while (current) {
            yield current.value;
            current = current.next;
        }
    }
}
// source code of p-limit - https://github.com/sindresorhus/p-limit/ + modified to add types
const AsyncResource = {
    bind(fn, _type, thisArg) {
        return fn.bind(thisArg);
    },
};
/**
 * Run multiple promise-returning & async functions with limited concurrency.
 * @param concurrency
 * @internal
 */
function pLimit(concurrency) {
    if (!((Number.isInteger(concurrency) ||
        concurrency === Number.POSITIVE_INFINITY) &&
        concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
    }
    const queue = new Queue();
    let activeCount = 0;
    const next = () => {
        activeCount--;
        if (queue.size > 0) {
            const fn = queue.dequeue();
            if (fn) {
                fn();
            }
        }
    };
    const run = async (function_, resolve, arguments_) => {
        activeCount++;
        // @ts-ignore
        const result = (async () => function_(...arguments_))();
        resolve(result);
        try {
            await result;
        }
        catch { }
        next();
    };
    const enqueue = (function_, resolve, arguments_) => {
        queue.enqueue(AsyncResource.bind(run.bind(undefined, function_, resolve, arguments_)));
        (async () => {
            // This function needs to wait until the next microtask before comparing
            // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
            // when the run function is dequeued and called. The comparison in the if-statement
            // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
            await Promise.resolve();
            if (activeCount < concurrency && queue.size > 0) {
                const fn = queue.dequeue();
                if (fn) {
                    fn();
                }
            }
        })();
    };
    const generator = (function_, ...arguments_) => new Promise((resolve) => {
        enqueue(function_, resolve, arguments_);
    });
    Object.defineProperties(generator, {
        activeCount: {
            get: () => activeCount,
        },
        pendingCount: {
            get: () => queue.size,
        },
        clearQueue: {
            value() {
                queue.clear();
            },
        },
    });
    return generator;
}
//# sourceMappingURL=p-limit.js.map