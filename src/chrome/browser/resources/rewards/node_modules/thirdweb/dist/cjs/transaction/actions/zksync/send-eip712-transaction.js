"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendEip712Transaction = sendEip712Transaction;
exports.signEip712Transaction = signEip712Transaction;
exports.populateEip712Transaction = populateEip712Transaction;
const viem_1 = require("viem");
const eth_sendRawTransaction_js_1 = require("../../../rpc/actions/eth_sendRawTransaction.js");
const rpc_js_1 = require("../../../rpc/rpc.js");
const bigint_js_1 = require("../../../utils/bigint.js");
const concat_hex_js_1 = require("../../../utils/encoding/helpers/concat-hex.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const resolve_promised_value_js_1 = require("../../../utils/promise/resolve-promised-value.js");
const encode_js_1 = require("../encode.js");
const to_serializable_transaction_js_1 = require("../to-serializable-transaction.js");
const getEip721Domain_js_1 = require("./getEip721Domain.js");
/**
 * Sends a transaction using the provided wallet.
 * @param options - The options for sending the transaction.
 * @returns A promise that resolves to the transaction hash.
 * @throws An error if the wallet is not connected.
 * @transaction
 * @example
 * ```ts
 * import { sendTransaction } from "thirdweb";
 *
 * const { transactionHash } = await sendTransaction({
 *  account,
 *  transaction
 * });
 * ```
 */
async function sendEip712Transaction(options) {
    const { account, transaction } = options;
    const eip712Transaction = await populateEip712Transaction(options);
    const hash = await signEip712Transaction({
        account,
        eip712Transaction,
        chainId: transaction.chain.id,
    });
    const rpc = (0, rpc_js_1.getRpcClient)(transaction);
    const result = await (0, eth_sendRawTransaction_js_1.eth_sendRawTransaction)(rpc, hash);
    return {
        transactionHash: result,
        chain: transaction.chain,
        client: transaction.client,
    };
}
async function signEip712Transaction(options) {
    const { account, eip712Transaction, chainId } = options;
    // EIP712 signing of the serialized tx
    const eip712Domain = (0, getEip721Domain_js_1.getEip712Domain)(eip712Transaction);
    const customSignature = await account.signTypedData({
        // biome-ignore lint/suspicious/noExplicitAny: TODO type properly
        ...eip712Domain,
    });
    return serializeTransactionEIP712({
        ...eip712Transaction,
        chainId,
        customSignature,
    });
}
async function populateEip712Transaction(options) {
    const { account, transaction } = options;
    let [data, to, value, gas, maxFeePerGas, maxPriorityFeePerGas, gasPerPubdata,] = await Promise.all([
        (0, encode_js_1.encode)(transaction),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.to),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.value),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.gas),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.maxFeePerGas),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.maxPriorityFeePerGas),
        (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.eip712).then((eip712) => eip712?.gasPerPubdata),
    ]);
    if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {
        // fetch fees and gas
        const rpc = (0, rpc_js_1.getRpcClient)(transaction);
        const result = (await rpc({
            // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types
            method: "zks_estimateFee",
            params: [
                {
                    from: account.address,
                    to,
                    data,
                    value: value ? (0, hex_js_1.numberToHex)(value) : undefined,
                    // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types
                },
            ],
        }));
        gas = (0, bigint_js_1.toBigInt)(result.gas_limit);
        const baseFee = (0, bigint_js_1.toBigInt)(result.max_fee_per_gas);
        maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion
        maxPriorityFeePerGas = (0, bigint_js_1.toBigInt)(result.max_priority_fee_per_gas) || 1n;
        gasPerPubdata = (0, bigint_js_1.toBigInt)(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;
    }
    // serialize the transaction (with fees, gas, nonce)
    const serializableTransaction = await (0, to_serializable_transaction_js_1.toSerializableTransaction)({
        transaction: {
            ...transaction,
            gas,
            maxFeePerGas,
            maxPriorityFeePerGas,
        },
        from: account.address,
    });
    return {
        ...serializableTransaction,
        ...transaction.eip712,
        gasPerPubdata,
        from: account.address,
    };
}
function serializeTransactionEIP712(transaction) {
    const { chainId, gas, nonce, to, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data, } = transaction;
    const serializedTransaction = [
        nonce ? (0, hex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, hex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, hex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, hex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, hex_js_1.toHex)(value) : "0x",
        data ?? "0x0",
        (0, hex_js_1.toHex)(chainId),
        (0, hex_js_1.toHex)(""),
        (0, hex_js_1.toHex)(""),
        (0, hex_js_1.toHex)(chainId),
        from ?? "0x",
        gasPerPubdata ? (0, hex_js_1.toHex)(gasPerPubdata) : (0, hex_js_1.toHex)(getEip721Domain_js_1.gasPerPubdataDefault),
        factoryDeps ?? [],
        customSignature ?? "0x", // EIP712 signature
        paymaster && paymasterInput ? [paymaster, paymasterInput] : [],
    ];
    // @ts-ignore - TODO: fix types
    return (0, concat_hex_js_1.concatHex)(["0x71", (0, viem_1.toRlp)(serializedTransaction)]);
}
//# sourceMappingURL=send-eip712-transaction.js.map