"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPaymasterAndData = getPaymasterAndData;
const hex_js_1 = require("../../../utils/encoding/hex.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const constants_js_1 = require("./constants.js");
const utils_js_1 = require("./utils.js");
/**
 * Get paymaster and data details for a user operation.
 * @param args - The userOp and options
 * @returns - The paymaster and data details for the user operation.
 * @example
 * ```ts
 * import { getPaymasterAndData } from "thirdweb/wallets/smart";
 *
 * const userOp = createUnsignedUserOp(...);
 *
 * const paymasterAndData = await getPaymasterAndData({
 *  userOp,
 *  client,
 *  chain,
 * });
 * ```
 * @walletUtils
 */
async function getPaymasterAndData(args) {
    const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;
    if (paymasterOverride) {
        return paymasterOverride(userOp);
    }
    const headers = {
        "Content-Type": "application/json",
    };
    const entrypoint = entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6;
    const entrypointVersion = (0, constants_js_1.getEntryPointVersion)(entrypoint);
    const paymasterVersion = entrypointVersion === "v0.6" ? "v1" : "v2";
    const paymasterUrl = (0, constants_js_1.getDefaultBundlerUrl)(chain, paymasterVersion);
    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.
    const fetchWithHeaders = (0, fetch_js_1.getClientFetch)(client);
    const response = await fetchWithHeaders(paymasterUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "pm_sponsorUserOperation",
            params: [(0, utils_js_1.hexlifyUserOp)(userOp), entrypoint],
        }),
    });
    const res = await response.json();
    if (!response.ok) {
        const error = res.error || response.statusText;
        const code = res.code || "UNKNOWN";
        throw new Error(`Paymaster error: ${error}
Status: ${response.status}
Code: ${code}`);
    }
    if (constants_js_1.DEBUG) {
        console.debug("Paymaster result:", res);
    }
    if (res.result) {
        // some paymasters return a string, some return an object with more data
        if (typeof res.result === "string") {
            return {
                paymasterAndData: res.result,
            };
        }
        return {
            paymasterAndData: res.result.paymasterAndData,
            verificationGasLimit: res.result.verificationGasLimit
                ? (0, hex_js_1.hexToBigInt)(res.result.verificationGasLimit)
                : undefined,
            preVerificationGas: res.result.preVerificationGas
                ? (0, hex_js_1.hexToBigInt)(res.result.preVerificationGas)
                : undefined,
            callGasLimit: res.result.callGasLimit
                ? (0, hex_js_1.hexToBigInt)(res.result.callGasLimit)
                : undefined,
            paymaster: res.result.paymaster,
            paymasterData: res.result.paymasterData,
            paymasterVerificationGasLimit: res.result.paymasterVerificationGasLimit
                ? (0, hex_js_1.hexToBigInt)(res.result.paymasterVerificationGasLimit)
                : undefined,
            paymasterPostOpGasLimit: res.result.paymasterPostOpGasLimit
                ? (0, hex_js_1.hexToBigInt)(res.result.paymasterPostOpGasLimit)
                : undefined,
        };
    }
    const error = res.error?.message || res.error || response.statusText || "unknown error";
    throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);
}
//# sourceMappingURL=paymaster.js.map