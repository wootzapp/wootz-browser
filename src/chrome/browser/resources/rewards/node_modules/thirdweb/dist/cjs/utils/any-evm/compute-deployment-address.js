"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeDeploymentAddress = computeDeploymentAddress;
const viem_1 = require("viem");
const prefix_js_1 = require("../bytecode/prefix.js");
const keccak256_js_1 = require("../hashing/keccak256.js");
const get_salt_hash_js_1 = require("./get-salt-hash.js");
const keccak_id_js_1 = require("./keccak-id.js");
/**
 * Computes the deployment address for a contract based on the given options.
 * @param options - The options for computing the deployment address.
 * @returns The computed deployment address.
 * @example
 * ```ts
 * import { computeDeploymentAddress } from "thirdweb/utils";
 * const deploymentAddress = computeDeploymentAddress({
 *  bytecode,
 *  encodedArgs,
 *  create2FactoryAddress,
 *  salt,
 * });
 * ```
 * @utils
 */
function computeDeploymentAddress(options) {
    const bytecode = (0, prefix_js_1.ensureBytecodePrefix)(options.bytecode);
    const saltHash = options.salt
        ? (0, keccak_id_js_1.keccakId)(options.salt)
        : (0, get_salt_hash_js_1.getSaltHash)(bytecode);
    // 1. create init bytecode hash with contract's bytecode and encoded args
    const initBytecode = (0, viem_1.encodePacked)(["bytes", "bytes"], [bytecode, options.encodedArgs]);
    // 2. abi-encode pack the deployer address, salt, and bytecode hash
    const deployInfoPacked = (0, viem_1.encodePacked)(["bytes1", "address", "bytes32", "bytes32"], [
        "0xff",
        options.create2FactoryAddress,
        saltHash,
        (0, keccak256_js_1.keccak256)((0, viem_1.encodePacked)(["bytes"], [initBytecode])),
    ]);
    // 3. hash the packed deploy info
    const hashedDeployInfo = (0, keccak256_js_1.keccak256)((0, viem_1.encodePacked)(["bytes"], [deployInfoPacked]));
    // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address
    return `0x${hashedDeployInfo.slice(26)}`;
}
//# sourceMappingURL=compute-deployment-address.js.map