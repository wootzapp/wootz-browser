"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectorLine = void 0;
exports.SwapConfirmationScreen = SwapConfirmationScreen;
exports.SwapFeesRightAligned = SwapFeesRightAligned;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_icons_1 = require("@radix-ui/react-icons");
const react_1 = require("react");
const send_transaction_js_1 = require("../../../../../../../transaction/actions/send-transaction.js");
const wait_for_tx_receipt_js_1 = require("../../../../../../../transaction/actions/wait-for-tx-receipt.js");
const address_js_1 = require("../../../../../../../utils/address.js");
const formatNumber_js_1 = require("../../../../../../../utils/formatNumber.js");
const CustomThemeProvider_js_1 = require("../../../../../../core/design-system/CustomThemeProvider.js");
const index_js_1 = require("../../../../../../core/design-system/index.js");
const useChainQuery_js_1 = require("../../../../../../core/hooks/others/useChainQuery.js");
const wallet_js_1 = require("../../../../../../core/utils/wallet.js");
const Skeleton_js_1 = require("../../../../components/Skeleton.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const StepBar_js_1 = require("../../../../components/StepBar.js");
const SwitchNetwork_js_1 = require("../../../../components/SwitchNetwork.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const text_js_1 = require("../../../../components/text.js");
const elements_js_1 = require("../../../../design-system/elements.js");
const PayTokenIcon_js_1 = require("../PayTokenIcon.js");
const Stepper_js_1 = require("../Stepper.js");
const formatSeconds_js_1 = require("./formatSeconds.js");
const pendingSwapTx_js_1 = require("./pendingSwapTx.js");
/**
 * @internal
 */
function SwapConfirmationScreen(props) {
    const isApprovalRequired = props.quote.approval !== undefined;
    const initialStep = isApprovalRequired ? "approval" : "swap";
    const [step, setStep] = (0, react_1.useState)(initialStep);
    const [status, setStatus] = (0, react_1.useState)("idle");
    const receiver = props.quote.swapDetails.toAddress;
    const sender = props.quote.swapDetails.fromAddress;
    const isDifferentRecipient = receiver.toLowerCase() !== sender.toLowerCase();
    const ensName = (0, wallet_js_1.useEnsName)({ client: props.client, address: receiver });
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }), props.isFiatFlow ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(StepBar_js_1.StepBar, { steps: 2, currentStep: 2 }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "xs", children: ["Step 2 of 2 - Converting ", props.fromTokenSymbol, " to", " ", props.toTokenSymbol] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })) : ((0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })), (0, jsx_runtime_1.jsx)(ConfirmItem, { label: "Pay", children: (0, jsx_runtime_1.jsx)(RenderTokenInfo, { chain: props.fromChain, amount: String((0, formatNumber_js_1.formatNumber)(Number(props.fromAmount), 6)), symbol: props.fromTokenSymbol || "", token: props.fromToken, client: props.client }) }), !isDifferentRecipient && ((0, jsx_runtime_1.jsx)(ConfirmItem, { label: "Receive", children: (0, jsx_runtime_1.jsx)(RenderTokenInfo, { chain: props.toChain, amount: String((0, formatNumber_js_1.formatNumber)(Number(props.toAmount), 6)), symbol: props.toTokenSymbol, token: props.toToken, client: props.client }) })), (0, jsx_runtime_1.jsx)(ConfirmItem, { label: "Fees", children: (0, jsx_runtime_1.jsx)(SwapFeesRightAligned, { quote: props.quote }) }), (0, jsx_runtime_1.jsx)(ConfirmItem, { label: "Time", children: (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "sm", color: "primaryText", children: ["~", (0, formatSeconds_js_1.formatSeconds)(props.quote.swapDetails.estimated.durationSeconds || 0)] }) }), isDifferentRecipient && ((0, jsx_runtime_1.jsx)(ConfirmItem, { label: "Seller", children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "primaryText", size: "sm", children: ensName.data || (0, address_js_1.shortenAddress)(receiver) }) })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), isApprovalRequired && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { gap: "sm", flex: "row", style: {
                            justifyContent: "space-between",
                        }, center: "y", color: "accentText", children: [(0, jsx_runtime_1.jsx)(Stepper_js_1.Step, { isDone: step === "swap", isActive: step === "approval", label: step === "approval" ? "Approve" : "Approved" }), (0, jsx_runtime_1.jsx)(exports.ConnectorLine, {}), (0, jsx_runtime_1.jsx)(Stepper_js_1.Step, { isDone: false, label: "Confirm", isActive: step === "swap" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" })] })), status === "error" && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", center: "both", color: "danger", children: [(0, jsx_runtime_1.jsx)(react_icons_1.CrossCircledIcon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", children: step === "approval" ? "Failed to Approve" : "Failed to Confirm" })] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] })), props.payer.chain.id !== props.fromChain.id ? ((0, jsx_runtime_1.jsx)(SwitchNetwork_js_1.SwitchNetworkButton, { fullWidth: true, variant: "accent", switchChain: async () => {
                    await props.payer.wallet.switchChain(props.fromChain);
                } })) : ((0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { variant: "accent", fullWidth: true, disabled: status === "pending", onClick: async () => {
                    if (step === "approval" && props.quote.approval) {
                        try {
                            setStatus("pending");
                            const tx = await (0, send_transaction_js_1.sendTransaction)({
                                account: props.payer.account,
                                transaction: props.quote.approval,
                            });
                            await (0, wait_for_tx_receipt_js_1.waitForReceipt)({ ...tx, maxBlocksWaitTime: 50 });
                            // props.onQuoteFinalized(props.quote);
                            setStep("swap");
                            setStatus("idle");
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                    if (step === "swap") {
                        setStatus("pending");
                        try {
                            let tx = props.quote.transactionRequest;
                            // Fix for inApp wallet
                            // Ideally - the pay server sends a non-legacy transaction to avoid this issue
                            if (props.payer.wallet.id === "inApp" ||
                                props.payer.wallet.id === "embedded") {
                                tx = {
                                    ...props.quote.transactionRequest,
                                    gasPrice: undefined,
                                };
                            }
                            const _swapTx = await (0, send_transaction_js_1.sendTransaction)({
                                account: props.payer.account,
                                transaction: tx,
                            });
                            await (0, wait_for_tx_receipt_js_1.waitForReceipt)({ ..._swapTx, maxBlocksWaitTime: 50 });
                            // do not add pending tx if the swap is part of fiat flow
                            if (!props.isFiatFlow) {
                                (0, pendingSwapTx_js_1.addPendingTx)({
                                    type: "swap",
                                    txHash: _swapTx.transactionHash,
                                });
                            }
                            props.setSwapTxHash(_swapTx.transactionHash);
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                }, gap: "xs", children: [step === "approval" &&
                        (status === "pending" ? "Approving" : "Approve"), step === "swap" && (status === "pending" ? "Confirming" : "Confirm"), status === "pending" && ((0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "accentButtonText" }))] }))] }));
}
exports.ConnectorLine = (0, elements_js_1.StyledDiv)(() => {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    return {
        height: "4px",
        background: theme.colors.borderColor,
        flex: 1,
    };
});
function RenderTokenInfo(props) {
    const { name } = (0, useChainQuery_js_1.useChainName)(props.chain);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "xxs", style: {
            alignItems: "flex-end",
        }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", center: "y", gap: "xs", children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [props.amount, " ", props.symbol] }), (0, jsx_runtime_1.jsx)(PayTokenIcon_js_1.PayTokenIcon, { token: props.token, chain: props.chain, size: "xs", client: props.client })] }), name ? ((0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", children: name })) : ((0, jsx_runtime_1.jsx)(Skeleton_js_1.Skeleton, { width: "100px", height: index_js_1.fontSize.xs }))] }));
}
function ConfirmItem(props) {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "md", py: "md", style: {
                    justifyContent: "space-between",
                }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", children: props.label }), props.children] }), (0, jsx_runtime_1.jsx)(basic_js_1.Line, {})] }));
}
/**
 * @internal
 */
function SwapFeesRightAligned(props) {
    return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "xs", style: {
            alignItems: "flex-end",
        }, children: props.quote.processingFees.map((fee) => {
            const feeAmount = (0, formatNumber_js_1.formatNumber)(Number(fee.amount), 6);
            return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xxs", children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [feeAmount === 0 ? "~" : "", feeAmount, " ", fee.token.symbol] }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "secondaryText", size: "sm", children: ["($", (fee.amountUSDCents / 100).toFixed(2), ")"] })] }, `${fee.token.chainId}_${fee.token.tokenAddress}_${feeAmount}`));
        }) }));
}
//# sourceMappingURL=ConfirmationScreen.js.map