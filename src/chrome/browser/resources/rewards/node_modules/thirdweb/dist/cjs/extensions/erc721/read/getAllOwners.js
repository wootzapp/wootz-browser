"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllOwners = getAllOwners;
const addresses_js_1 = require("../../../constants/addresses.js");
const bigint_js_1 = require("../../../utils/bigint.js");
const ownerOf_js_1 = require("../__generated__/IERC721A/read/ownerOf.js");
const startTokenId_js_1 = require("../__generated__/IERC721A/read/startTokenId.js");
const totalSupply_js_1 = require("../__generated__/IERC721A/read/totalSupply.js");
const nextTokenIdToMint_js_1 = require("../__generated__/IERC721Enumerable/read/nextTokenIdToMint.js");
const DEFAULT_QUERY_ALL_COUNT = 100n;
/**
 * Retrieves the owners of all ERC721 tokens within a specified range.
 * @param options - The options for retrieving the owners.
 * @returns A promise that resolves to an array of objects containing the token ID and owner address.
 * @throws An error if the contract does not have either `nextTokenIdToMint` or `totalSupply` function available.
 * @extension ERC721
 * @example
 * ```ts
 * import { getAllOwners } from "thirdweb/extensions/erc721";
 * const owners = await getAllOwners({
 *  contract,
 *  start: 0,
 *  count: 10,
 * });
 * ```
 */
async function getAllOwners(options) {
    const [startTokenId_, maxSupply] = await Promise.allSettled([
        (0, startTokenId_js_1.startTokenId)(options),
        (0, nextTokenIdToMint_js_1.nextTokenIdToMint)(options),
        (0, totalSupply_js_1.totalSupply)(options),
    ]).then(([_startTokenId, _next, _total]) => {
        // default to 0 if startTokenId is not available
        const startTokenId__ = _startTokenId.status === "fulfilled" ? _startTokenId.value : 0n;
        let maxSupply_;
        // prioritize nextTokenIdToMint
        if (_next.status === "fulfilled") {
            // because we always default the startTokenId to 0 we can safely just always subtract here
            maxSupply_ = _next.value - startTokenId__;
        }
        // otherwise use totalSupply
        else if (_total.status === "fulfilled") {
            maxSupply_ = _total.value;
        }
        else {
            throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
        }
        return [startTokenId__, maxSupply_];
    });
    const start = BigInt(options.start ?? 0) + startTokenId_;
    const count = BigInt(options.count ?? DEFAULT_QUERY_ALL_COUNT);
    const maxId = (0, bigint_js_1.min)(maxSupply + startTokenId_, start + count);
    const promises = [];
    for (let i = start; i < maxId; i++) {
        promises.push((0, ownerOf_js_1.ownerOf)({ contract: options.contract, tokenId: i })
            .catch(() => addresses_js_1.ADDRESS_ZERO)
            .then((owner) => ({
            tokenId: i,
            owner,
        })));
    }
    return await Promise.all(promises);
}
//# sourceMappingURL=getAllOwners.js.map