"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEcosystemWallet = createEcosystemWallet;
const track_js_1 = require("../../../../analytics/track.js");
const utils_js_1 = require("../../../../chains/utils.js");
const wallet_emitter_js_1 = require("../../../wallet-emitter.js");
const linkAccount_js_1 = require("../authentication/linkAccount.js");
const in_app_core_js_1 = require("./in-app-core.js");
/**
 * @internal
 */
function createEcosystemWallet(args) {
    // Under the hood, an ecosystem wallet wraps an in-app wallet
    const { id, createOptions, connectorFactory } = args;
    const emitter = (0, wallet_emitter_js_1.createWalletEmitter)();
    let account = undefined;
    let chain = undefined;
    let client;
    const ecosystem = {
        id,
        partnerId: createOptions?.partnerId,
    };
    return {
        id,
        subscribe: emitter.subscribe,
        getChain() {
            if (!chain) {
                return undefined;
            }
            chain = (0, utils_js_1.getCachedChainIfExists)(chain.id) || chain;
            return chain;
        },
        getConfig: () => createOptions,
        getProfiles: async () => {
            if (!client) {
                return [];
            }
            return (0, linkAccount_js_1.getLinkedProfilesInternal)({ client, ecosystem });
        },
        getAccount: () => account,
        autoConnect: async (options) => {
            const { autoConnectInAppWallet } = await Promise.resolve().then(() => require("./index.js"));
            const connector = await (0, in_app_core_js_1.getOrCreateInAppWalletConnector)(options.client, connectorFactory, ecosystem);
            const [connectedAccount, connectedChain] = await autoConnectInAppWallet(options, createOptions, connector);
            // set the states
            client = options.client;
            account = connectedAccount;
            chain = connectedChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: id,
                walletAddress: account.address,
            });
            // return only the account
            return account;
        },
        connect: async (options) => {
            const { connectInAppWallet } = await Promise.resolve().then(() => require("./index.js"));
            const connector = await (0, in_app_core_js_1.getOrCreateInAppWalletConnector)(options.client, connectorFactory, ecosystem);
            const [connectedAccount, connectedChain] = await connectInAppWallet(options, createOptions, connector);
            // set the states
            client = options.client;
            account = connectedAccount;
            chain = connectedChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: id,
                walletAddress: account.address,
            });
            // return only the account
            return account;
        },
        disconnect: async () => {
            // If no client is assigned, we should be fine just unsetting the states
            if (client) {
                const connector = await (0, in_app_core_js_1.getOrCreateInAppWalletConnector)(client, connectorFactory, ecosystem);
                const result = await connector.logout();
                if (!result.success) {
                    throw new Error("Failed to logout");
                }
            }
            account = undefined;
            chain = undefined;
            emitter.emit("disconnect", undefined);
        },
        switchChain: async (newChain) => {
            chain = newChain;
            emitter.emit("chainChanged", newChain);
        },
        // This is not included on the global interface but is force-resolved in linkProfile
        linkProfile: async (options) => {
            if (!client) {
                throw new Error("No client found, please connect the wallet before linking a profile");
            }
            const connector = await (0, in_app_core_js_1.getOrCreateInAppWalletConnector)(client, connectorFactory, ecosystem);
            const { storedToken } = await connector.authenticate(options);
            return await (0, linkAccount_js_1.linkAccount)({
                client,
                ecosystem,
                tokenToLink: storedToken.cookieString,
            });
        },
    };
}
//# sourceMappingURL=ecosystem-core.js.map