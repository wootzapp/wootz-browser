"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.otpLogin = otpLogin;
exports.authenticate = authenticate;
exports.socialLogin = socialLogin;
exports.siweLogin = siweLogin;
exports.guestLogin = guestLogin;
exports.customJwt = customJwt;
exports.authEndpoint = authEndpoint;
exports.deleteActiveAccount = deleteActiveAccount;
const WebBrowser = require("expo-web-browser");
const nativeStorage_js_1 = require("../../../../utils/storage/nativeStorage.js");
const getLoginPath_js_1 = require("../../core/authentication/getLoginPath.js");
const guest_js_1 = require("../../core/authentication/guest.js");
const siwe_js_1 = require("../../core/authentication/siwe.js");
const otp_js_1 = require("../../web/lib/auth/otp.js");
const fetchers_js_1 = require("../helpers/api/fetchers.js");
const middleware_js_1 = require("../helpers/auth/middleware.js");
const constants_js_1 = require("../helpers/constants.js");
const errors_js_1 = require("../helpers/errors.js");
async function otpLogin(options) {
    const { storedToken } = await (0, otp_js_1.verifyOtp)(options);
    try {
        const toStoreToken = {
            jwtToken: storedToken.jwtToken,
            authDetails: storedToken.authDetails,
            authProvider: storedToken.authProvider,
            developerClientId: storedToken.developerClientId,
            cookieString: storedToken.cookieString,
            // we should always store the jwt cookie since there's no concept of cookie in react native
            shouldStoreCookieString: true,
            isNewUser: storedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuth)({ storedToken: toStoreToken, client: options.client });
        return { storedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post authentication", e));
    }
}
async function authenticate(auth, client) {
    const loginUrl = (0, getLoginPath_js_1.getLoginUrl)({
        authOption: auth.strategy,
        client,
        mode: "window",
        redirectUrl: auth.redirectUrl,
    });
    const result = await WebBrowser.openAuthSessionAsync(loginUrl, auth.redirectUrl, {
        preferEphemeralSession: false,
        showTitle: false,
        enableDefaultShareMenuItem: false,
        enableBarCollapsing: false,
    });
    if (result.type === "cancel") {
        throw new Error("Sign in cancelled");
    }
    if (result.type !== "success") {
        throw new Error(`Can't sign in with ${auth.strategy}: ${result}`);
    }
    const resultURL = new URL(result.url);
    const authResult = resultURL.searchParams.get("authResult");
    const error = resultURL.searchParams.get("error");
    // assume error
    if (error) {
        throw new Error(`Something went wrong: ${error}`);
    }
    if (!authResult) {
        throw new Error("No auth result found");
    }
    return JSON.parse(authResult);
}
async function socialLogin(auth, client) {
    const { storedToken } = await authenticate(auth, client);
    try {
        const toStoreToken = {
            jwtToken: storedToken.jwtToken,
            authDetails: storedToken.authDetails,
            authProvider: storedToken.authProvider,
            developerClientId: storedToken.developerClientId,
            cookieString: storedToken.cookieString,
            // we should always store the jwt cookie since there's no concept of cookie in react native
            shouldStoreCookieString: true,
            isNewUser: storedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuth)({ storedToken: toStoreToken, client });
        return { storedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post authentication", e));
    }
}
async function siweLogin(client, wallet, chain, ecosystem) {
    const { storedToken } = await (0, siwe_js_1.siweAuthenticate)({
        client,
        ecosystem,
        wallet,
        chain,
    });
    try {
        const toStoreToken = {
            jwtToken: storedToken.jwtToken,
            authDetails: storedToken.authDetails,
            authProvider: storedToken.authProvider,
            developerClientId: storedToken.developerClientId,
            cookieString: storedToken.cookieString,
            // we should always store the jwt cookie since there's no concept of cookie in react native
            shouldStoreCookieString: true,
            isNewUser: storedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuth)({ storedToken: toStoreToken, client });
        return { storedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post authentication", e));
    }
}
async function guestLogin(client, ecosystem) {
    const { storedToken } = await (0, guest_js_1.guestAuthenticate)({
        client,
        ecosystem,
        storage: nativeStorage_js_1.nativeLocalStorage,
    });
    try {
        const toStoreToken = {
            jwtToken: storedToken.jwtToken,
            authDetails: storedToken.authDetails,
            authProvider: storedToken.authProvider,
            developerClientId: storedToken.developerClientId,
            cookieString: storedToken.cookieString,
            // we should always store the jwt cookie since there's no concept of cookie in react native
            shouldStoreCookieString: true,
            isNewUser: storedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuth)({ storedToken: toStoreToken, client });
        return { storedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post authentication", e));
    }
}
async function customJwt(authOptions, client) {
    const { jwt, password } = authOptions;
    const resp = await fetch(constants_js_1.ROUTE_AUTH_JWT_CALLBACK, {
        method: "POST",
        headers: {
            ...(0, fetchers_js_1.getSessionHeaders)(),
        },
        body: JSON.stringify({
            jwt: jwt,
            developerClientId: client.clientId,
        }),
    });
    if (!resp.ok) {
        const error = await resp.json();
        throw new Error(`JWT authentication error: ${error.message}`);
    }
    try {
        const { verifiedToken, verifiedTokenJwtString } = await resp.json();
        const toStoreToken = {
            jwtToken: verifiedToken.jwtToken,
            authProvider: verifiedToken.authProvider,
            authDetails: {
                ...verifiedToken.authDetails,
                email: verifiedToken.authDetails.email,
            },
            developerClientId: verifiedToken.developerClientId,
            cookieString: verifiedTokenJwtString,
            shouldStoreCookieString: true,
            isNewUser: verifiedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuthUserManaged)(toStoreToken, client, password);
        return { storedToken: verifiedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post jwt authentication", e));
    }
}
async function authEndpoint(authOptions, client) {
    const { payload, encryptionKey } = authOptions;
    const resp = await fetch(constants_js_1.ROUTE_AUTH_ENDPOINT_CALLBACK, {
        method: "POST",
        headers: {
            ...(0, fetchers_js_1.getSessionHeaders)(),
        },
        body: JSON.stringify({
            payload: payload,
            developerClientId: client.clientId,
        }),
    });
    if (!resp.ok) {
        const error = await resp.json();
        throw new Error(`Custom auth endpoint authentication error: ${error.message}`);
    }
    try {
        const { verifiedToken, verifiedTokenJwtString } = await resp.json();
        const toStoreToken = {
            jwtToken: verifiedToken.jwtToken,
            authProvider: verifiedToken.authProvider,
            authDetails: {
                ...verifiedToken.authDetails,
                email: verifiedToken.authDetails.email,
            },
            developerClientId: verifiedToken.developerClientId,
            cookieString: verifiedTokenJwtString,
            shouldStoreCookieString: true,
            isNewUser: verifiedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuthUserManaged)(toStoreToken, client, encryptionKey);
        return { storedToken: verifiedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post auth_endpoint authentication", e));
    }
}
async function deleteActiveAccount(options) {
    await (0, fetchers_js_1.verifyClientId)(options.client);
    try {
        return (0, fetchers_js_1.deleteAccount)(options.client);
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Error deleting the active account", e));
    }
}
//# sourceMappingURL=native-auth.js.map