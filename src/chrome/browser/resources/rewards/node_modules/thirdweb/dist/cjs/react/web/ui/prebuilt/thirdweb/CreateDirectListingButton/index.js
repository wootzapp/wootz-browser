"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateDirectListingButton = CreateDirectListingButton;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const contract_js_1 = require("../../../../../../contract/contract.js");
const isERC721_js_1 = require("../../../../../../extensions/erc721/read/isERC721.js");
const isERC1155_js_1 = require("../../../../../../extensions/erc1155/read/isERC1155.js");
const createListing_js_1 = require("../../../../../../extensions/marketplace/direct-listings/write/createListing.js");
const useReadContract_js_1 = require("../../../../../core/hooks/contract/useReadContract.js");
const useSendAndConfirmTransaction_js_1 = require("../../../../../core/hooks/transaction/useSendAndConfirmTransaction.js");
const useActiveAccount_js_1 = require("../../../../../core/hooks/wallets/useActiveAccount.js");
const index_js_1 = require("../../../TransactionButton/index.js");
/**
 * This button is used to create Direct listings for the thirdweb Marketplace v3 contract
 *
 * It uses the [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)
 * and the [`createListing` extension](https://portal.thirdweb.com/references/typescript/v5/marketplace/createListing) under the hood
 * which means it inherits all the props of those 2 components.
 *
 * @example
 * ```tsx
 * import { CreateDirectListingButton } from "thirdweb/react";
 *
 * <CreateDirectListingButton
 *   contractAddress="0x..." // contract address for the marketplace-v3
 *   chain={...} // the chain which the marketplace contract is deployed on
 *
 *   // These props below are the same props for `createListing`
 *   // to get the full list, check the docs link above
 *   tokenId={0n}
 *   assetContractAddress="0x..." // The NFT contract address whose NFT(s) you want to sell
 *   pricePerToken={"0.1"} // sell for 0.1 <native token>
 * >
 *   Sell NFT
 * </CreateDirectListingButton>
 * ```
 *
 * For error handling & callbacks on transaction-sent and transaction-confirmed,
 * please refer to the TransactionButton docs.
 * @component
 */
function CreateDirectListingButton(props) {
    const { contractAddress, chain, client, children, payModal, assetContractAddress, tokenId, } = props;
    const marketplaceContract = (0, contract_js_1.getContract)({
        address: contractAddress,
        chain,
        client,
    });
    const account = (0, useActiveAccount_js_1.useActiveAccount)();
    const defaultPayModalMetadata = payModal ? payModal.metadata : undefined;
    const nftContract = (0, contract_js_1.getContract)({
        address: assetContractAddress,
        chain,
        client,
    });
    const { data: payMetadata } = (0, useReadContract_js_1.useReadContract)(getPayMetadata, {
        contract: nftContract,
        tokenId,
        queryOptions: {
            enabled: !defaultPayModalMetadata,
        },
    });
    const { mutateAsync } = (0, useSendAndConfirmTransaction_js_1.useSendAndConfirmTransaction)();
    const prepareTransaction = (0, react_1.useCallback)(async () => {
        if (!account) {
            throw new Error("No account detected");
        }
        const [is721, is1155] = await Promise.all([
            (0, isERC721_js_1.isERC721)({ contract: nftContract }),
            (0, isERC1155_js_1.isERC1155)({ contract: nftContract }),
        ]);
        if (!is1155 && !is721) {
            throw new Error("Asset must either be ERC721 or ERC1155");
        }
        // Check for token approval
        if (is1155) {
            const [{ isApprovedForAll }, { setApprovalForAll }] = await Promise.all([
                Promise.resolve().then(() => require("../../../../../../extensions/erc1155/__generated__/IERC1155/read/isApprovedForAll.js")),
                Promise.resolve().then(() => require("../../../../../../extensions/erc1155/__generated__/IERC1155/write/setApprovalForAll.js")),
            ]);
            const isApproved = await isApprovedForAll({
                contract: nftContract,
                operator: marketplaceContract.address,
                owner: account.address,
            });
            if (!isApproved) {
                const transaction = setApprovalForAll({
                    contract: nftContract,
                    operator: marketplaceContract.address,
                    approved: true,
                });
                await mutateAsync(transaction);
            }
        }
        else {
            const [{ isApprovedForAll }, { setApprovalForAll }, { getApproved }] = await Promise.all([
                Promise.resolve().then(() => require("../../../../../../extensions/erc721/__generated__/IERC721A/read/isApprovedForAll.js")),
                Promise.resolve().then(() => require("../../../../../../extensions/erc721/__generated__/IERC721A/write/setApprovalForAll.js")),
                Promise.resolve().then(() => require("../../../../../../extensions/erc721/__generated__/IERC721A/read/getApproved.js")),
            ]);
            const [isApproved, tokenApproved] = await Promise.all([
                isApprovedForAll({
                    contract: nftContract,
                    operator: marketplaceContract.address,
                    owner: account.address,
                }),
                getApproved({ contract: nftContract, tokenId: props.tokenId }),
            ]);
            if (!isApproved &&
                tokenApproved.toLowerCase() !==
                    marketplaceContract.address.toLowerCase()) {
                const transaction = setApprovalForAll({
                    contract: nftContract,
                    operator: marketplaceContract.address,
                    approved: true,
                });
                await mutateAsync(transaction);
            }
        }
        const listingTx = (0, createListing_js_1.createListing)({
            contract: marketplaceContract,
            ...props,
        });
        return listingTx;
    }, [marketplaceContract, props, account, mutateAsync, nftContract]);
    return ((0, jsx_runtime_1.jsx)(index_js_1.TransactionButton, { transaction: () => prepareTransaction(), payModal: {
            metadata: defaultPayModalMetadata || payMetadata,
            ...payModal,
        }, ...props, children: children }));
}
/**
 * @internal
 */
async function getPayMetadata(options) {
    const [{ getContractMetadata }, { getNFT: getERC721 }, { getNFT: getERC1155 },] = await Promise.all([
        Promise.resolve().then(() => require("../../../../../../extensions/common/read/getContractMetadata.js")),
        Promise.resolve().then(() => require("../../../../../../extensions/erc721/read/getNFT.js")),
        Promise.resolve().then(() => require("../../../../../../extensions/erc1155/read/getNFT.js")),
    ]);
    const [is721, is1155, contractMetadata] = await Promise.all([
        (0, isERC721_js_1.isERC721)(options),
        (0, isERC1155_js_1.isERC1155)(options),
        getContractMetadata(options),
    ]);
    if (is721) {
        const nft = await getERC721(options);
        return {
            image: nft?.metadata?.image,
            name: nft?.metadata?.name,
        };
    }
    if (is1155) {
        const nft = await getERC1155(options);
        return {
            image: nft?.metadata?.image,
            name: nft?.metadata?.name,
        };
    }
    return {
        image: contractMetadata?.image,
        name: contractMetadata?.name,
    };
}
//# sourceMappingURL=index.js.map