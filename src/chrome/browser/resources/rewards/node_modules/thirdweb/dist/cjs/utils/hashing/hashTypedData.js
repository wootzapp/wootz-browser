"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashTypedData = hashTypedData;
const viem_1 = require("viem");
const encodeAbiParameters_js_1 = require("../abi/encodeAbiParameters.js");
const hex_js_1 = require("../encoding/hex.js");
const keccak256_js_1 = require("./keccak256.js");
/**
 * @internal
 */
function hashTypedData(parameters) {
    const { domain = {}, message, primaryType, } = parameters;
    const types = {
        EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
        ...parameters.types,
    };
    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
    // as we can't statically check this with TypeScript.
    (0, viem_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types,
    });
    const parts = ["0x1901"];
    if (domain)
        parts.push((0, viem_1.hashDomain)({
            domain,
            types: types,
        }));
    if (primaryType !== "EIP712Domain") {
        const hashedStruct = (() => {
            const encoded = encodeData({
                data: message,
                primaryType,
                types: types,
            });
            return (0, keccak256_js_1.keccak256)(encoded);
        })();
        parts.push(hashedStruct);
    }
    return (0, keccak256_js_1.keccak256)((0, viem_1.concat)(parts));
}
function encodeData({ data, primaryType, types, }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType({ primaryType, types })];
    if (!types[primaryType])
        throw new Error("Invalid types");
    for (const field of types[primaryType]) {
        const [type, value] = encodeField({
            types,
            name: field.name,
            type: field.type,
            value: data[field.name],
        });
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
}
function hashType({ primaryType, types, }) {
    const encodedHashType = (0, hex_js_1.toHex)(encodeType({ primaryType, types }));
    return (0, keccak256_js_1.keccak256)(encodedHashType);
}
function encodeType({ primaryType, types, }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
        if (!types[type])
            throw new Error("Invalid types");
        result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(",")})`;
    }
    return result;
}
function findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === undefined) {
        return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
}
function encodeField({ types, name, type, value, }) {
    if (types[type] !== undefined) {
        return [
            { type: "bytes32" },
            (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types })),
        ];
    }
    if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
    }
    if (type === "string")
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, hex_js_1.toHex)(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values
        const typeValuePairs = value.map((item) => encodeField({
            name,
            type: parsedType,
            types,
            value: item,
        }));
        return [
            { type: "bytes32" },
            (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
        ];
    }
    return [{ type }, value];
}
//# sourceMappingURL=hashTypedData.js.map