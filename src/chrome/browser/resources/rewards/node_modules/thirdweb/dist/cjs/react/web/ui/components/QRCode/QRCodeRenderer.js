"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const uqr_1 = require("uqr");
/**
 * @internal
 */
function QRCodeRenderer({ ecl = "M", size: sizeProp = 200, uri, clearSize = 0, image, imageBackground = "transparent", }) {
    const logoSize = clearSize;
    const size = sizeProp - 10 * 2;
    const dots = (0, react_1.useMemo)(() => {
        const dotsArray = [];
        const matrix = (0, uqr_1.encode)(uri, { ecc: ecl, border: 0 }).data;
        const cellSize = size / matrix.length;
        const qrList = [
            { x: 0, y: 0 },
            { x: 1, y: 0 },
            { x: 0, y: 1 },
        ];
        for (const { x, y } of qrList) {
            const x1 = (matrix.length - 7) * cellSize * x;
            const y1 = (matrix.length - 7) * cellSize * y;
            for (let i = 0; i < 3; i++) {
                dotsArray.push((0, jsx_runtime_1.jsx)("rect", { fill: i % 2 !== 0
                        ? "var(--ck-qr-background, var(--ck-body-background))"
                        : "var(--ck-qr-dot-color)", rx: (i - 2) * -5 + (i === 0 ? 2 : 3), ry: (i - 2) * -5 + (i === 0 ? 2 : 3), width: cellSize * (7 - i * 2), height: cellSize * (7 - i * 2), x: x1 + cellSize * i, y: y1 + cellSize * i }, `${i}-${x}-${y}`));
            }
        }
        if (image) {
            const x1 = (matrix.length - 7) * cellSize * 1;
            const y1 = (matrix.length - 7) * cellSize * 1;
            dotsArray.push((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("rect", { fill: imageBackground, rx: (0 - 2) * -5 + 2, ry: (0 - 2) * -5 + 2, width: cellSize * (7 - 0 * 2), height: cellSize * (7 - 0 * 2), x: x1 + cellSize * 0, y: y1 + cellSize * 0 }), (0, jsx_runtime_1.jsx)("foreignObject", { width: cellSize * (7 - 0 * 2), height: cellSize * (7 - 0 * 2), x: x1 + cellSize * 0, y: y1 + cellSize * 0, children: (0, jsx_runtime_1.jsx)("div", { style: { borderRadius: (0 - 2) * -5 + 2, overflow: "hidden" }, children: image }) })] }));
        }
        const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
        const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
        const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
        matrix.forEach((row, i) => {
            row.forEach((_, j) => {
                if (matrix[i]?.[j]) {
                    // Do not render dots under position squares
                    if (!((i < 7 && j < 7) ||
                        (i > matrix.length - 8 && j < 7) ||
                        (i < 7 && j > matrix.length - 8))) {
                        //if (image && i > matrix.length - 9 && j > matrix.length - 9) return;
                        if (image ||
                            !(i > matrixMiddleStart &&
                                i < matrixMiddleEnd &&
                                j > matrixMiddleStart &&
                                j < matrixMiddleEnd)) {
                            dotsArray.push((0, jsx_runtime_1.jsx)("circle", { cx: i * cellSize + cellSize / 2, cy: j * cellSize + cellSize / 2, fill: "var(--ck-qr-dot-color)", r: cellSize / 3 }, `circle-${i}-${
                            // biome-ignore lint/suspicious/noArrayIndexKey: its the only thing available for the key here
                            j}`));
                        }
                    }
                }
            });
        });
        return dotsArray;
    }, [ecl, image, imageBackground, logoSize, size, uri]);
    return ((0, jsx_runtime_1.jsxs)("svg", { height: size, width: size, viewBox: `0 0 ${size} ${size}`, style: {
            width: size,
            height: size,
        }, role: "presentation", children: [(0, jsx_runtime_1.jsx)("rect", { fill: "transparent", height: size, width: size }), dots] }));
}
exports.default = QRCodeRenderer;
//# sourceMappingURL=QRCodeRenderer.js.map