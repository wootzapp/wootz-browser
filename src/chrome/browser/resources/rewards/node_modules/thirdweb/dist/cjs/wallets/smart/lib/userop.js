"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearAccountDeploying = void 0;
exports.waitForUserOpReceipt = waitForUserOpReceipt;
exports.createUnsignedUserOp = createUnsignedUserOp;
exports.signUserOp = signUserOp;
exports.createAndSignUserOp = createAndSignUserOp;
const viem_1 = require("viem");
const contract_js_1 = require("../../../contract/contract.js");
const getNonce_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js");
const getUserOpHash_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js");
const getUserOpHash_js_2 = require("../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js");
const fee_data_js_1 = require("../../../gas/fee-data.js");
const encode_js_1 = require("../../../transaction/actions/encode.js");
const to_serializable_transaction_js_1 = require("../../../transaction/actions/to-serializable-transaction.js");
const is_contract_deployed_js_1 = require("../../../utils/bytecode/is-contract-deployed.js");
const to_bytes_js_1 = require("../../../utils/encoding/to-bytes.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const resolve_promised_value_js_1 = require("../../../utils/promise/resolve-promised-value.js");
const bundler_js_1 = require("./bundler.js");
const calls_js_1 = require("./calls.js");
const constants_js_1 = require("./constants.js");
const packUserOp_js_1 = require("./packUserOp.js");
const paymaster_js_1 = require("./paymaster.js");
const utils_js_1 = require("./utils.js");
const isDeployingSet = new Set();
const getKey = (accountContract) => {
    return `${accountContract.chain.id}:${accountContract.address}`;
};
const markAccountDeploying = (accountContract) => {
    isDeployingSet.add(getKey(accountContract));
};
const clearAccountDeploying = (accountContract) => {
    isDeployingSet.delete(getKey(accountContract));
};
exports.clearAccountDeploying = clearAccountDeploying;
const isAccountDeploying = (accountContract) => {
    return isDeployingSet.has(getKey(accountContract));
};
/**
 * Wait for the user operation to be mined.
 * @param args - The options and user operation hash
 * @returns - The transaction receipt
 *
 * @example
 * ```ts
 * import { waitForUserOpReceipt } from "thirdweb/wallets/smart";
 *
 * const receipt = await waitForUserOpReceipt({
 *  chain,
 *  client,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function waitForUserOpReceipt(args) {
    const timeout = args.timeoutMs || 120000; // 2mins
    const interval = args.intervalMs || 1000; // 1s
    const endtime = Date.now() + timeout;
    while (Date.now() < endtime) {
        const userOpReceipt = await (0, bundler_js_1.getUserOpReceipt)(args);
        if (userOpReceipt) {
            return userOpReceipt;
        }
        await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error("Timeout waiting for userOp to be mined");
}
/**
 * Creates an unsigned user operation from a prepared transaction.
 * @param args - The prepared transaction and options
 * @returns - The unsigned user operation
 * @example
 * ```ts
 * import { createUnsignedUserOp } from "thirdweb/wallets/smart";
 *
 * const transaction = prepareContractCall(...);
 *
 * const userOp = await createUnsignedUserOp({
 *  transaction,
 *  factoryContract,
 *  accountContract,
 *  adminAddress,
 *  sponsorGas,
 *  overrides,
 * });
 * ```
 * @walletUtils
 */
async function createUnsignedUserOp(args) {
    const { transaction: executeTx, accountContract, factoryContract, adminAddress, overrides, sponsorGas, } = args;
    const chain = executeTx.chain;
    const client = executeTx.client;
    const bundlerOptions = {
        client,
        chain,
        entrypointAddress: overrides?.entrypointAddress,
    };
    const entrypointVersion = (0, constants_js_1.getEntryPointVersion)(args.overrides?.entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6);
    const [isDeployed, callData, gasFees, nonce] = await Promise.all([
        (0, is_contract_deployed_js_1.isContractDeployed)(accountContract),
        (0, encode_js_1.encode)(executeTx),
        getGasFees({
            executeTx,
            bundlerOptions,
            chain,
            client,
        }),
        getAccountNonce({
            accountContract,
            chain,
            client,
            entrypointAddress: overrides?.entrypointAddress,
            getNonceOverride: overrides?.getAccountNonce,
        }),
    ]);
    const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;
    if (entrypointVersion === "v0.7") {
        return populateUserOp_v0_7({
            bundlerOptions,
            factoryContract,
            accountContract,
            adminAddress,
            sponsorGas,
            overrides,
            isDeployed,
            nonce,
            callData,
            maxFeePerGas,
            maxPriorityFeePerGas,
        });
    }
    // default to v0.6
    return populateUserOp_v0_6({
        bundlerOptions,
        factoryContract,
        accountContract,
        adminAddress,
        sponsorGas,
        overrides,
        isDeployed,
        nonce,
        callData,
        maxFeePerGas,
        maxPriorityFeePerGas,
    });
}
async function getGasFees(args) {
    const { executeTx, bundlerOptions, chain, client } = args;
    let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;
    const entrypointVersion = (0, constants_js_1.getEntryPointVersion)(bundlerOptions.entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6);
    const bundlerVersion = entrypointVersion === "v0.6" ? "v1" : "v2";
    const bundlerUrl = bundlerOptions?.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(chain, bundlerVersion);
    if ((0, fetch_js_1.isThirdwebUrl)(bundlerUrl)) {
        // get gas prices from bundler
        const bundlerGasPrice = await (0, bundler_js_1.getUserOpGasFees)({
            options: bundlerOptions,
        });
        maxFeePerGas = bundlerGasPrice.maxFeePerGas;
        maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;
    }
    else {
        // Check for explicity values
        const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([
            (0, resolve_promised_value_js_1.resolvePromisedValue)(maxFeePerGas),
            (0, resolve_promised_value_js_1.resolvePromisedValue)(maxPriorityFeePerGas),
        ]);
        if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {
            // Save a network call if the values are provided
            maxFeePerGas = resolvedMaxFeePerGas;
            maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;
        }
        else {
            // Fallback to RPC gas prices if no explicit values provided
            const feeData = await (0, fee_data_js_1.getDefaultGasOverrides)(client, chain);
            // Still check for explicit values in case one is provided and not the other
            maxPriorityFeePerGas =
                resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;
            maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;
        }
    }
    return { maxFeePerGas, maxPriorityFeePerGas };
}
async function populateUserOp_v0_7(args) {
    const { bundlerOptions, isDeployed, factoryContract, accountContract, adminAddress, sponsorGas, overrides, nonce, callData, maxFeePerGas, maxPriorityFeePerGas, } = args;
    const { chain, client } = bundlerOptions;
    let factory;
    let factoryData;
    // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel
    if (isDeployed || isAccountDeploying(accountContract)) {
        factoryData = "0x";
        await waitForAccountDeployed(accountContract);
    }
    else {
        factory = factoryContract.address;
        factoryData = await (0, encode_js_1.encode)((0, calls_js_1.prepareCreateAccount)({
            factoryContract: factoryContract,
            adminAddress,
            accountSalt: overrides?.accountSalt,
            createAccountOverride: overrides?.createAccount,
        }));
        markAccountDeploying(accountContract);
    }
    const partialOp = {
        sender: accountContract.address,
        nonce,
        callData,
        maxFeePerGas,
        maxPriorityFeePerGas,
        callGasLimit: 0n,
        verificationGasLimit: 0n,
        preVerificationGas: 0n,
        factory,
        factoryData,
        paymaster: undefined,
        paymasterData: "0x",
        paymasterVerificationGasLimit: 0n,
        paymasterPostOpGasLimit: 0n,
        signature: constants_js_1.DUMMY_SIGNATURE,
    };
    if (sponsorGas) {
        const paymasterResult = (await (0, paymaster_js_1.getPaymasterAndData)({
            userOp: partialOp,
            chain,
            client,
            entrypointAddress: overrides?.entrypointAddress,
            paymasterOverride: overrides?.paymaster,
        }));
        if (paymasterResult.paymaster && paymasterResult.paymasterData) {
            partialOp.paymaster = paymasterResult.paymaster;
            partialOp.paymasterData = paymasterResult.paymasterData;
        }
        // paymaster can have the gas limits in the response
        if (paymasterResult.callGasLimit &&
            paymasterResult.verificationGasLimit &&
            paymasterResult.preVerificationGas &&
            paymasterResult.paymasterPostOpGasLimit &&
            paymasterResult.paymasterVerificationGasLimit) {
            partialOp.callGasLimit = paymasterResult.callGasLimit;
            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;
            partialOp.preVerificationGas = paymasterResult.preVerificationGas;
            partialOp.paymasterPostOpGasLimit =
                paymasterResult.paymasterPostOpGasLimit;
            partialOp.paymasterVerificationGasLimit =
                paymasterResult.paymasterVerificationGasLimit;
        }
        else {
            // otherwise fallback to bundler for gas limits
            const estimates = await (0, bundler_js_1.estimateUserOpGas)({
                userOp: partialOp,
                options: bundlerOptions,
            });
            partialOp.callGasLimit = estimates.callGasLimit;
            partialOp.verificationGasLimit = estimates.verificationGasLimit;
            partialOp.preVerificationGas = estimates.preVerificationGas;
            partialOp.paymasterPostOpGasLimit =
                paymasterResult.paymasterPostOpGasLimit || 0n;
            partialOp.paymasterVerificationGasLimit =
                paymasterResult.paymasterVerificationGasLimit || 0n;
            // need paymaster to re-sign after estimates
            const paymasterResult2 = (await (0, paymaster_js_1.getPaymasterAndData)({
                userOp: partialOp,
                chain,
                client,
                entrypointAddress: overrides?.entrypointAddress,
                paymasterOverride: overrides?.paymaster,
            }));
            if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {
                partialOp.paymaster = paymasterResult2.paymaster;
                partialOp.paymasterData = paymasterResult2.paymasterData;
            }
        }
    }
    else {
        // not gasless, so we just need to estimate gas limits
        const estimates = await (0, bundler_js_1.estimateUserOpGas)({
            userOp: partialOp,
            options: bundlerOptions,
        });
        partialOp.callGasLimit = estimates.callGasLimit;
        partialOp.verificationGasLimit = estimates.verificationGasLimit;
        partialOp.preVerificationGas = estimates.preVerificationGas;
        partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;
        partialOp.paymasterVerificationGasLimit =
            estimates.paymasterVerificationGasLimit || 0n;
    }
    return {
        ...partialOp,
        signature: "0x",
    };
}
async function populateUserOp_v0_6(args) {
    const { bundlerOptions, isDeployed, factoryContract, accountContract, adminAddress, sponsorGas, overrides, nonce, callData, maxFeePerGas, maxPriorityFeePerGas, } = args;
    const { chain, client } = bundlerOptions;
    let initCode;
    // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel
    if (isDeployed || isAccountDeploying(accountContract)) {
        initCode = "0x";
        await waitForAccountDeployed(accountContract);
    }
    else {
        initCode = await getAccountInitCode({
            factoryContract: factoryContract,
            adminAddress,
            accountSalt: overrides?.accountSalt,
            createAccountOverride: overrides?.createAccount,
        });
        markAccountDeploying(accountContract);
    }
    const partialOp = {
        sender: accountContract.address,
        nonce,
        initCode,
        callData,
        maxFeePerGas,
        maxPriorityFeePerGas,
        callGasLimit: 0n,
        verificationGasLimit: 0n,
        preVerificationGas: 0n,
        paymasterAndData: "0x",
        signature: constants_js_1.DUMMY_SIGNATURE,
    };
    if (sponsorGas) {
        const paymasterResult = await (0, paymaster_js_1.getPaymasterAndData)({
            userOp: partialOp,
            chain,
            client,
            entrypointAddress: overrides?.entrypointAddress,
            paymasterOverride: overrides?.paymaster,
        });
        const paymasterAndData = "paymasterAndData" in paymasterResult
            ? paymasterResult.paymasterAndData
            : "0x";
        if (paymasterAndData && paymasterAndData !== "0x") {
            partialOp.paymasterAndData = paymasterAndData;
        }
        // paymaster can have the gas limits in the response
        if (paymasterResult.callGasLimit &&
            paymasterResult.verificationGasLimit &&
            paymasterResult.preVerificationGas) {
            partialOp.callGasLimit = paymasterResult.callGasLimit;
            partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;
            partialOp.preVerificationGas = paymasterResult.preVerificationGas;
        }
        else {
            // otherwise fallback to bundler for gas limits
            const estimates = await (0, bundler_js_1.estimateUserOpGas)({
                userOp: partialOp,
                options: bundlerOptions,
            });
            partialOp.callGasLimit = estimates.callGasLimit;
            partialOp.verificationGasLimit = estimates.verificationGasLimit;
            partialOp.preVerificationGas = estimates.preVerificationGas;
            // need paymaster to re-sign after estimates
            if (paymasterAndData && paymasterAndData !== "0x") {
                const paymasterResult2 = await (0, paymaster_js_1.getPaymasterAndData)({
                    userOp: partialOp,
                    chain,
                    client,
                    entrypointAddress: overrides?.entrypointAddress,
                    paymasterOverride: overrides?.paymaster,
                });
                const paymasterAndData2 = "paymasterAndData" in paymasterResult2
                    ? paymasterResult2.paymasterAndData
                    : "0x";
                if (paymasterAndData2 && paymasterAndData2 !== "0x") {
                    partialOp.paymasterAndData = paymasterAndData2;
                }
            }
        }
    }
    else {
        // not gasless, so we just need to estimate gas limits
        const estimates = await (0, bundler_js_1.estimateUserOpGas)({
            userOp: partialOp,
            options: bundlerOptions,
        });
        partialOp.callGasLimit = estimates.callGasLimit;
        partialOp.verificationGasLimit = estimates.verificationGasLimit;
        partialOp.preVerificationGas = estimates.preVerificationGas;
    }
    return {
        ...partialOp,
        signature: "0x",
    };
}
/**
 * Sign a user operation.
 * @param userOp - The UserOperation to sign (with signature field ignored)
 * @returns - The user operation with the signature field populated
 * @example
 * ```ts
 * import { signUserOp } from "thirdweb/wallets/smart";
 *
 * const userOp = await createUnsignedUserOp(...);
 *
 * const signedUserOp = await signUserOp({
 *  client,
 *  userOp,
 *  chain,
 *  adminAccount,
 * });
 * ```
 * @walletUtils
 */
async function signUserOp(args) {
    const { userOp, chain, entrypointAddress, adminAccount } = args;
    const entrypointVersion = (0, constants_js_1.getEntryPointVersion)(entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6);
    let userOpHash;
    if (entrypointVersion === "v0.7") {
        const packedUserOp = (0, packUserOp_js_1.getPackedUserOperation)(userOp);
        userOpHash = await (0, getUserOpHash_js_2.getUserOpHash)({
            contract: (0, contract_js_1.getContract)({
                address: entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_7,
                chain,
                client: args.client,
            }),
            userOp: packedUserOp,
        });
    }
    else {
        userOpHash = await (0, getUserOpHash_js_1.getUserOpHash)({
            contract: (0, contract_js_1.getContract)({
                address: entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
                chain,
                client: args.client,
            }),
            userOp: userOp,
        });
    }
    if (adminAccount.signMessage) {
        const signature = await adminAccount.signMessage({
            message: {
                raw: (0, to_bytes_js_1.hexToBytes)(userOpHash),
            },
        });
        return {
            ...userOp,
            signature,
        };
    }
    throw new Error("signMessage not implemented in signingAccount");
}
async function getAccountInitCode(options) {
    const { factoryContract, adminAddress, accountSalt, createAccountOverride } = options;
    const deployTx = (0, calls_js_1.prepareCreateAccount)({
        factoryContract,
        adminAddress,
        accountSalt,
        createAccountOverride,
    });
    return (0, viem_1.concat)([factoryContract.address, await (0, encode_js_1.encode)(deployTx)]);
}
async function getAccountNonce(options) {
    const { accountContract, chain, client, entrypointAddress, getNonceOverride, } = options;
    if (getNonceOverride) {
        return getNonceOverride(accountContract);
    }
    return (0, getNonce_js_1.getNonce)({
        contract: (0, contract_js_1.getContract)({
            address: entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
            chain,
            client,
        }),
        key: (0, utils_js_1.generateRandomUint192)(),
        sender: accountContract.address,
    });
}
/**
 * Create and sign a user operation.
 * @param options - The options for creating and signing the user operation
 * @returns - The signed user operation
 * @example
 * ```ts
 * import { createAndSignUserOp } from "thirdweb/wallets/smart";
 *
 * const userOp = await createAndSignUserOp({
 *  client,
 *  adminAccount,
 *  smartWalletOptions,
 *  transactions,
 * });
 * ```
 * @walletUtils
 */
async function createAndSignUserOp(options) {
    const config = options.smartWalletOptions;
    const factoryContract = (0, contract_js_1.getContract)({
        address: config.factoryAddress ||
            (0, constants_js_1.getDefaultAccountFactory)(config.overrides?.entrypointAddress),
        chain: config.chain,
        client: options.client,
    });
    const accountAddress = await (0, calls_js_1.predictAddress)({
        factoryContract,
        adminAddress: options.adminAccount.address,
        predictAddressOverride: config.overrides?.predictAddress,
        accountSalt: config.overrides?.accountSalt,
        accountAddress: config.overrides?.accountAddress,
    });
    const accountContract = (0, contract_js_1.getContract)({
        address: accountAddress,
        chain: config.chain,
        client: options.client,
    });
    let executeTx;
    if (options.transactions.length === 1) {
        const tx = options.transactions[0];
        const serializedTx = await (0, to_serializable_transaction_js_1.toSerializableTransaction)({
            transaction: tx,
        });
        executeTx = (0, calls_js_1.prepareExecute)({
            accountContract,
            transaction: serializedTx,
            executeOverride: config.overrides?.execute,
        });
    }
    else {
        const serializedTxs = await Promise.all(options.transactions.map((tx) => (0, to_serializable_transaction_js_1.toSerializableTransaction)({
            transaction: tx,
        })));
        executeTx = (0, calls_js_1.prepareBatchExecute)({
            accountContract,
            transactions: serializedTxs,
            executeBatchOverride: config.overrides?.executeBatch,
        });
    }
    const unsignedUserOp = await createUnsignedUserOp({
        transaction: executeTx,
        factoryContract,
        accountContract,
        adminAddress: options.adminAccount.address,
        sponsorGas: "sponsorGas" in config ? config.sponsorGas : config.gasless,
        overrides: config.overrides,
    });
    const signedUserOp = await signUserOp({
        client: options.client,
        chain: config.chain,
        adminAccount: options.adminAccount,
        entrypointAddress: config.overrides?.entrypointAddress,
        userOp: unsignedUserOp,
    });
    return signedUserOp;
}
async function waitForAccountDeployed(accountContract) {
    const startTime = Date.now();
    while (isAccountDeploying(accountContract)) {
        if (Date.now() - startTime > 60000) {
            throw new Error("Account deployment is taking too long (over 1 minute). Please try again.");
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
    }
}
//# sourceMappingURL=userop.js.map