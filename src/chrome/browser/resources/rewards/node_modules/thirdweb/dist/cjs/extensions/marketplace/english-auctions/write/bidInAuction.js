"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bidInAuction = bidInAuction;
const addresses_js_1 = require("../../../../constants/addresses.js");
const isNewWinningBid_js_1 = require("../../__generated__/IEnglishAuctions/read/isNewWinningBid.js");
const bidInAuction_js_1 = require("../../__generated__/IEnglishAuctions/write/bidInAuction.js");
const getAuction_js_1 = require("../read/getAuction.js");
const getWinningBid_js_1 = require("../read/getWinningBid.js");
/**
 * Places a bid in an English auction.
 * @param options - The options for placing the bid.
 * @returns A transaction that can be sent to place the bid.
 * @extension MARKETPLACE
 * @example
 * ```ts
 * import { bidInAuction } from "thirdweb/extensions/marketplace";
 * import { sendTransaction } from "thirdweb";
 *
 * const transaction = bidInAuction({
 *  contract,
 *  auctionId: 0n,
 *  bidAmount: "100",
 * });
 *
 * await sendTransaction({ transaction, account });
 * ```
 */
function bidInAuction(options) {
    return (0, bidInAuction_js_1.bidInAuction)({
        contract: options.contract,
        asyncParams: async () => {
            const auction = await (0, getAuction_js_1.getAuction)({
                contract: options.contract,
                auctionId: options.auctionId,
            });
            const resolvedBidAmountWei = await (async () => {
                // if we already have the bid amount in wei, use that
                if ("bidAmountWei" in options) {
                    return options.bidAmountWei;
                }
                // otherwise load the utility function and convert the amount
                const { convertErc20Amount } = await Promise.resolve().then(() => require("../../../../utils/extensions/convert-erc20-amount.js"));
                return await convertErc20Amount({
                    amount: options.bidAmount,
                    chain: options.contract.chain,
                    erc20Address: auction.currencyContractAddress,
                    client: options.contract.client,
                });
            })();
            if (resolvedBidAmountWei === 0n) {
                throw new Error("Bid amount is zero");
            }
            if (resolvedBidAmountWei > auction.buyoutCurrencyValue.value) {
                throw new Error("Bid amount is above the buyout amount");
            }
            const existingWinningBid = await (0, getWinningBid_js_1.getWinningBid)({
                auctionId: options.auctionId,
                contract: options.contract,
            });
            if (existingWinningBid) {
                // check if the bid amount is sufficient to outbid the existing winning bid
                const isNewWinner = await (0, isNewWinningBid_js_1.isNewWinningBid)({
                    contract: options.contract,
                    auctionId: options.auctionId,
                    bidAmount: resolvedBidAmountWei,
                });
                if (!isNewWinner) {
                    throw new Error("Bid amount is too low to outbid the existing winning bid");
                }
            }
            else {
                // no existing winning bid, check if the bid amount is sufficient to outbid the minimum bid
                if (resolvedBidAmountWei < auction.minimumBidCurrencyValue.value) {
                    throw new Error("Bid amount is below the minimum bid amount");
                }
            }
            return {
                auctionId: options.auctionId,
                bidAmount: resolvedBidAmountWei,
                overrides: {
                    value: (0, addresses_js_1.isNativeTokenAddress)(auction.currencyContractAddress)
                        ? resolvedBidAmountWei
                        : undefined,
                    extraGas: 50000n, // add extra gas to account for router call
                },
            };
        },
    });
}
//# sourceMappingURL=bidInAuction.js.map