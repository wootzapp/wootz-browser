"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApprovalForTransaction = getApprovalForTransaction;
const contract_js_1 = require("../../../contract/contract.js");
const address_js_1 = require("../../../utils/address.js");
const resolve_promised_value_js_1 = require("../../../utils/promise/resolve-promised-value.js");
const allowance_js_1 = require("../__generated__/IERC20/read/allowance.js");
const approve_js_1 = require("../__generated__/IERC20/write/approve.js");
/**
 * When dealing with transactions that involve ERC20 tokens (Airdropping ERC20, buy NFTs with ERC20, etc.)
 * you often have to do a pre-check to see if the targeted contract has the sufficient allowance to "take" the ERC20 tokens from the caller's wallet.
 *
 * This extension is a handy method that checks for the allowance and requests to approve for more if current allowance is insufficient
 *
 * @param options GetApprovalForTransactionParams
 * @returns a PreparedTransaction
 *
 * @example
 * ```ts
 * import { getApprovalForTransaction } from "thirdweb/extensions/erc20";
 * import { sendAndConfirmTransaction } from "thirdweb";
 *
 * async function buyNFT() {
 *   const buyTransaction = ... // could be a marketplacev3's buyFromListing
 *
 *   // Check if you need to approve spending for the involved ERC20 contract
 *   const approveTx = await getApprovalForTransaction({
 *     transaction: buyTransaction,
 *     account, // the connected account
 *   });
 *   if (approveTx) {
 *     await sendAndConfirmTransaction({
 *       transaction: approveTx,
 *       account,
 *     })
 *   }
 *   // Once approved, you can finally perform the buy transaction
 *   await sendAndConfirmTransaction({
 *     transaction: buyTransaction,
 *     account,
 *   });
 * }
 * ```
 *
 * @transaction
 */
async function getApprovalForTransaction(options) {
    const { transaction, account } = options;
    if (!account) {
        return null;
    }
    const erc20Value = await (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.erc20Value);
    if (erc20Value) {
        const target = await (0, resolve_promised_value_js_1.resolvePromisedValue)(transaction.to);
        if (!target ||
            !erc20Value.tokenAddress ||
            (0, address_js_1.getAddress)(target) === (0, address_js_1.getAddress)(erc20Value.tokenAddress)) {
            return null;
        }
        const contract = (0, contract_js_1.getContract)({
            address: erc20Value.tokenAddress,
            chain: transaction.chain,
            client: transaction.client,
        });
        const approvedValue = await (0, allowance_js_1.allowance)({
            contract,
            owner: account.address,
            spender: target,
        });
        if (approvedValue > erc20Value.amountWei) {
            return null;
        }
        return (0, approve_js_1.approve)({
            contract,
            value: erc20Value.amountWei,
            spender: target,
        });
    }
    return null;
}
//# sourceMappingURL=getApprovalForTransaction.js.map