"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareOpenZeppelinTransaction = prepareOpenZeppelinTransaction;
exports.relayOpenZeppelinTransaction = relayOpenZeppelinTransaction;
const contract_js_1 = require("../../../../contract/contract.js");
const is_hex_js_1 = require("../../../../utils/encoding/helpers/is-hex.js");
const json_js_1 = require("../../../../utils/json.js");
const read_contract_js_1 = require("../../../read-contract.js");
/**
 * @internal - only exported for testing
 */
async function prepareOpenZeppelinTransaction({ account, serializableTransaction, transaction, gasless, }) {
    const forrwaderContract = (0, contract_js_1.getContract)({
        address: gasless.relayerForwarderAddress,
        chain: transaction.chain,
        client: transaction.client,
    });
    const nonce = await (0, read_contract_js_1.readContract)({
        contract: forrwaderContract,
        method: "function getNonce(address) view returns (uint256)",
        params: [account.address],
    });
    const [signature, message] = await (async () => {
        // TODO: handle special case for `approve` -> `permit` transactions
        if (!serializableTransaction.to) {
            throw new Error("OpenZeppelin transactions must have a 'to' address");
        }
        if (!serializableTransaction.gas) {
            throw new Error("OpenZeppelin transactions must have a 'gas' value");
        }
        if (!serializableTransaction.data) {
            throw new Error("OpenZeppelin transactions must have a 'data' value");
        }
        // chainless support!
        if (gasless.experimentalChainlessSupport) {
            const message = {
                from: account.address,
                to: serializableTransaction.to,
                value: 0n,
                gas: serializableTransaction.gas,
                nonce: nonce,
                data: serializableTransaction.data,
                chainid: BigInt(transaction.chain.id),
            };
            return [
                await account.signTypedData({
                    domain: {
                        name: "GSNv2 Forwarder",
                        version: "0.0.1",
                        verifyingContract: forrwaderContract.address,
                    },
                    message,
                    primaryType: "ForwardRequest",
                    types: { ForwardRequest: ChainAwareForwardRequest },
                }),
                message,
            ];
        }
        // else non-chainless support
        const message = {
            from: account.address,
            to: serializableTransaction.to,
            value: 0n,
            gas: serializableTransaction.gas,
            nonce: nonce,
            data: serializableTransaction.data,
        };
        return [
            await account.signTypedData({
                domain: {
                    name: gasless.domainName ?? "GSNv2 Forwarder",
                    version: gasless.domainVersion ?? "0.0.1",
                    chainId: transaction.chain.id,
                    verifyingContract: forrwaderContract.address,
                },
                message,
                primaryType: "ForwardRequest",
                types: { ForwardRequest },
            }),
            message,
        ];
    })();
    // TODO: handle special case for `approve` -> `permit`
    const messageType = "forward";
    return { message, signature, messageType };
}
const ForwardRequest = [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "gas", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "data", type: "bytes" },
];
const ChainAwareForwardRequest = [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "gas", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "data", type: "bytes" },
    { name: "chainid", type: "uint256" },
];
/**
 * @internal
 */
async function relayOpenZeppelinTransaction(options) {
    const { message, messageType, signature } = await prepareOpenZeppelinTransaction(options);
    const response = await fetch(options.gasless.relayerUrl, {
        method: "POST",
        body: (0, json_js_1.stringify)({
            request: message,
            type: messageType,
            signature,
            forwarderAddress: options.gasless.relayerForwarderAddress,
        }),
    });
    if (!response.ok) {
        response.body?.cancel();
        throw new Error(`Failed to send transaction: ${await response.text()}`);
    }
    const json = await response.json();
    if (!json.result) {
        throw new Error(`Relay transaction failed: ${json.message}`);
    }
    const transactionHash = JSON.parse(json.result).txHash;
    if ((0, is_hex_js_1.isHex)(transactionHash)) {
        return {
            transactionHash,
            chain: options.transaction.chain,
            client: options.transaction.client,
        };
    }
    throw new Error(`Failed to send transaction: ${(0, json_js_1.stringify)(json)}`);
}
//# sourceMappingURL=openzeppelin.js.map