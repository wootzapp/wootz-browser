"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSendToken = useSendToken;
const react_query_1 = require("@tanstack/react-query");
const contract_js_1 = require("../../../../contract/contract.js");
const resolve_address_js_1 = require("../../../../extensions/ens/resolve-address.js");
const transfer_js_1 = require("../../../../extensions/erc20/write/transfer.js");
const send_transaction_js_1 = require("../../../../transaction/actions/send-transaction.js");
const prepare_transaction_js_1 = require("../../../../transaction/prepare-transaction.js");
const address_js_1 = require("../../../../utils/address.js");
const units_js_1 = require("../../../../utils/units.js");
const useActiveWallet_js_1 = require("./useActiveWallet.js");
/**
 * Send Native or ERC20 tokens from active wallet to given address.
 * @example
 * ```tsx
 * const { mutate: sendToken } = useSendToken(client);
 *
 * // send native currency
 * sendToken({
 *    receiverAddress: "0x...",
 *    amount: "0.1",
 * });
 *
 * // send ERC20
 * sendToken({
 *   tokenAddress,
 *   receiverAddress: "0x...",
 *   amount: "0.5",
 * });
 * ```
 * @wallet
 */
function useSendToken(client) {
    const wallet = (0, useActiveWallet_js_1.useActiveWallet)();
    return (0, react_query_1.useMutation)({
        async mutationFn(option) {
            const { tokenAddress, receiverAddress, amount } = option;
            const activeChain = wallet?.getChain();
            const account = wallet?.getAccount();
            // state validation
            if (!activeChain) {
                throw new Error("No active chain");
            }
            if (!account) {
                throw new Error("No active account");
            }
            // input validation
            if (!receiverAddress ||
                (!receiverAddress.endsWith(".eth") && !(0, address_js_1.isAddress)(receiverAddress))) {
                throw new Error("Invalid receiver address");
            }
            if (!amount || Number.isNaN(Number(amount)) || Number(amount) < 0) {
                throw new Error("Invalid amount");
            }
            let to = receiverAddress;
            // resolve ENS if needed
            try {
                to = await (0, resolve_address_js_1.resolveAddress)({
                    client,
                    name: receiverAddress,
                });
            }
            catch {
                throw new Error("Failed to resolve address");
            }
            // native token transfer
            if (!tokenAddress) {
                const sendNativeTokenTx = (0, prepare_transaction_js_1.prepareTransaction)({
                    chain: activeChain,
                    client,
                    to,
                    value: (0, units_js_1.toWei)(amount),
                });
                await (0, send_transaction_js_1.sendTransaction)({
                    transaction: sendNativeTokenTx,
                    account,
                });
            }
            // erc20 token transfer
            else {
                const contract = (0, contract_js_1.getContract)({
                    address: tokenAddress,
                    client,
                    chain: activeChain,
                });
                const tx = (0, transfer_js_1.transfer)({
                    amount,
                    contract,
                    to,
                });
                await (0, send_transaction_js_1.sendTransaction)({
                    transaction: tx,
                    account,
                });
            }
        },
    });
}
//# sourceMappingURL=useSendToken.js.map