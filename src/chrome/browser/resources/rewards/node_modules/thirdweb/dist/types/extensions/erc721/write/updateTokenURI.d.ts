import type { BaseTransactionOptions } from "../../../transaction/types.js";
import type { NFTInput } from "../../../utils/nft/parseNft.js";
export { isSetTokenURISupported as isUpdateTokenURISupported } from "../../erc721/__generated__/INFTMetadata/write/setTokenURI.js";
/**
 * @extension ERC721
 */
export type UpdateTokenURIParams = {
    tokenId: bigint;
    newMetadata: NFTInput;
};
/**
 * This function is an abstracted layer of the [`setTokenURI` extension](https://portal.thirdweb.com/references/typescript/v5/erc721/setTokenURI),
 * which means it uses `setTokenURI` under the hood.
 * While the `setTokenURI` method only takes in a uri string, this extension takes in a user-friendly [`NFTInput`](https://portal.thirdweb.com/references/typescript/v5/NFTInput),
 * upload that content to IPFS and pass the IPFS URI (of said `NFTInput`) to the underlying `setTokenURI` method.
 *
 * This extension does not validate the NFTInput so make sure you are passing the proper content that you want to update.
 *
 * @extension ERC721
 * @returns the prepared transaction from `setTokenURI`
 * @example
 * ```ts
 * import { updateTokenURI } from "thirdweb/extensions/erc721";
 *
 * const transaction = updateTokenURI({
 *   tokenId: 0n,
 *   nft: {
 *     name: "new name",
 *     description: "new description",
 *     image: "https://image-host.com/new-image.png",
 *   },
 * });
 * ```
 */
export declare function updateTokenURI(options: BaseTransactionOptions<UpdateTokenURIParams>): import("../../../transaction/prepare-transaction.js").PreparedTransaction<any, import("abitype").AbiFunction, import("../../../transaction/prepare-transaction.js").PrepareTransactionOptions>;
//# sourceMappingURL=updateTokenURI.d.ts.map