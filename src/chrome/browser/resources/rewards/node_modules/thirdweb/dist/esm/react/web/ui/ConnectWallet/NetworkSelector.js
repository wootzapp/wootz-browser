"use client";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import styled from "@emotion/styled";
import { CrossCircledIcon, MagnifyingGlassIcon } from "@radix-ui/react-icons";
import Fuse from "fuse.js";
import { Fragment, memo, useCallback, useContext, useEffect, useMemo, useState, } from "react";
import { convertApiChainToChain } from "../../../../chains/utils.js";
import { CustomThemeProvider, useCustomTheme, } from "../../../core/design-system/CustomThemeProvider.js";
import { fontSize, iconSize, media, radius, spacing, } from "../../../core/design-system/index.js";
import { useChainIconUrl, useChainName, useChainsQuery, } from "../../../core/hooks/others/useChainQuery.js";
import { useActiveWalletChain } from "../../../core/hooks/wallets/useActiveWalletChain.js";
import { useSwitchActiveWalletChain } from "../../../core/hooks/wallets/useSwitchActiveWalletChain.js";
import { SetRootElementContext } from "../../../core/providers/RootElementContext.js";
import { ChainIcon } from "../components/ChainIcon.js";
import { Modal } from "../components/Modal.js";
import { Skeleton } from "../components/Skeleton.js";
import { Spacer } from "../components/Spacer.js";
import { Spinner } from "../components/Spinner.js";
import { Container, Line, ModalHeader } from "../components/basic.js";
import { Button } from "../components/buttons.js";
import { Input } from "../components/formElements.js";
import { ModalTitle } from "../components/modalElements.js";
import { Text } from "../components/text.js";
import { StyledButton, StyledP, StyledUl } from "../design-system/elements.js";
import { useDebouncedValue } from "../hooks/useDebouncedValue.js";
import { useShowMore } from "../hooks/useShowMore.js";
import { getConnectLocale } from "./locale/getConnectLocale.js";
/**
 * @internal
 */
export function NetworkSelectorContent(props) {
    const locale = props.connectLocale.networkSelector;
    const [searchTerm, setSearchTerm] = useState("");
    const [selectedTab, setSelectedTab] = useState("all");
    const deferredSearchTerm = useDebouncedValue(searchTerm, 300);
    const { onSwitch, onCustomClick } = props.networkSelector || {};
    // labels
    const othersLabel = locale.categoryLabel.others;
    const popularLabel = locale.categoryLabel.popular;
    const recentLabel = locale.categoryLabel.recentlyUsed;
    // create sections, chainToSectionMap and allChains
    const { chainSections, allChains, allChainsToSectionMap } = useMemo(() => {
        const chainSectionsValue = [];
        const allChainsValue = [];
        const allChainsToSectionMapValue = new Map();
        function addChain(c, section) {
            allChainsToSectionMapValue.set(c.id, section);
            allChainsValue.push(c);
        }
        // if new API is used
        if (props.networkSelector?.sections) {
            for (const s of props.networkSelector.sections) {
                const chainsToAdd = s.chains.filter((c) => !allChainsToSectionMapValue.has(c.id));
                if (chainsToAdd.length > 0) {
                    chainSectionsValue.push({
                        label: s.label,
                        chains: chainsToAdd,
                    });
                    for (const c of chainsToAdd) {
                        addChain(c, s.label);
                    }
                }
            }
        }
        // if old API is used
        else {
            const allChainsMap = new Map(props.chains.map((c) => [c.id, c]));
            // add all recent chains
            if (props.networkSelector?.recentChainIds &&
                props.networkSelector?.recentChainIds.length > 0) {
                const recentChains = props.networkSelector.recentChainIds
                    .map((id) => allChainsMap.get(id))
                    .filter((c) => c !== undefined);
                chainSectionsValue.push({
                    label: recentLabel,
                    chains: recentChains,
                });
                for (const c of recentChains) {
                    addChain(c, recentLabel);
                }
            }
            // then add all popular chains ( exclude already added chains )
            if (props.networkSelector?.popularChainIds &&
                props.networkSelector.popularChainIds.length > 0) {
                const popularChains = props.networkSelector.popularChainIds
                    .map((id) => allChainsMap.get(id))
                    .filter((c) => c !== undefined);
                const chainsToAdd = popularChains.filter((c) => !allChainsToSectionMapValue.has(c.id));
                if (chainsToAdd.length > 0) {
                    chainSectionsValue.push({
                        label: popularLabel,
                        chains: chainsToAdd,
                    });
                    for (const c of chainsToAdd) {
                        addChain(c, popularLabel);
                    }
                }
            }
        }
        // add all other chains ( exclude already added chains )
        const otherChainsToAdd = props.chains.filter((c) => !allChainsToSectionMapValue.has(c.id));
        if (otherChainsToAdd.length > 0) {
            chainSectionsValue.push({
                label: othersLabel,
                chains: otherChainsToAdd,
            });
            for (const c of otherChainsToAdd) {
                addChain(c, othersLabel);
            }
        }
        return {
            chainSections: chainSectionsValue,
            allChains: allChainsValue,
            allChainsToSectionMap: allChainsToSectionMapValue,
        };
    }, [
        props.networkSelector?.sections,
        props.networkSelector?.recentChainIds,
        props.networkSelector?.popularChainIds,
        props.chains,
        recentLabel,
        popularLabel,
        othersLabel,
    ]);
    // optimizing for dashboard - if we already have names - don't query - we already have the data we want
    const chainsHaveName = allChains.every((c) => !!c.name);
    const allChainsQuery = useChainsQuery(chainsHaveName ? [] : allChains, 10);
    const isAllChainsQueryLoading = chainsHaveName
        ? false
        : allChainsQuery.some((q) => q.isLoading);
    const allChainsMetadata = chainsHaveName
        ? allChains
        : !isAllChainsQueryLoading
            ? allChainsQuery
                .filter((x) => !!x.data)
                .map((q) => convertApiChainToChain(q.data))
            : [];
    // fuse instance for searching
    const fuse = useMemo(() => {
        return new Fuse(allChainsMetadata, {
            threshold: 0.4,
            keys: [
                {
                    name: "name",
                    weight: 1,
                },
                {
                    name: "chainId",
                    weight: 1,
                },
            ],
        });
    }, [allChainsMetadata]);
    // chains filtered by search term
    const searchedChainSections = useMemo(() => {
        if (deferredSearchTerm === "") {
            return undefined;
        }
        const filteredChainSectionsValue = [];
        const filteredAllChains = fuse
            .search(deferredSearchTerm)
            .map((r) => r.item);
        for (const c of filteredAllChains) {
            const label = allChainsToSectionMap.get(c.id);
            if (!label) {
                return; // just a type guard, this never happens
            }
            const section = filteredChainSectionsValue.find((s) => s.label === label);
            if (section) {
                section.chains.push(c);
            }
            else {
                filteredChainSectionsValue.push({
                    label,
                    chains: [c],
                });
            }
        }
        return filteredChainSectionsValue;
    }, [deferredSearchTerm, fuse, allChainsToSectionMap]) || chainSections;
    const filteredChainSections = useMemo(() => {
        if (selectedTab === "all") {
            return searchedChainSections;
        }
        return searchedChainSections.map((section) => ({
            label: section.label,
            chains: section.chains.filter((c) => (selectedTab === "mainnet" && !c.testnet) ||
                (selectedTab === "testnet" && c.testnet)),
        }));
    }, [searchedChainSections, selectedTab]);
    const handleSwitch = useCallback((chain) => {
        if (onSwitch) {
            onSwitch(chain);
        }
        props.closeModal();
    }, [onSwitch, props]);
    return (_jsxs(Container, { children: [_jsx(Container, { p: "lg", children: props.onBack ? (_jsx(ModalHeader, { title: locale.title, onBack: props.onBack })) : (_jsx(ModalTitle, { children: locale.title })) }), props.showTabs !== false && (_jsxs(_Fragment, { children: [_jsx(Container, { px: "lg", children: _jsxs(Container, { flex: "row", gap: "xxs", children: [_jsx(TabButton, { onClick: () => setSelectedTab("all"), "data-active": selectedTab === "all", children: locale.allNetworks }), _jsx(TabButton, { onClick: () => setSelectedTab("mainnet"), "data-active": selectedTab === "mainnet", children: locale.mainnets }), _jsx(TabButton, { onClick: () => setSelectedTab("testnet"), "data-active": selectedTab === "testnet", children: locale.testnets })] }) }), _jsx(Spacer, { y: "lg" })] })), props.showTabs === false && _jsx(Spacer, { y: "xxs" }), _jsx(Container, { px: "lg", children: _jsxs("div", { style: {
                        display: "flex",
                        alignItems: "center",
                        position: "relative",
                    }, children: [_jsx(StyledMagnifyingGlassIcon, { width: iconSize.md, height: iconSize.md }), _jsx(Input, { style: {
                                padding: `${spacing.sm} ${spacing.md} ${spacing.sm} ${spacing.xxl}`,
                            }, tabIndex: -1, variant: "outline", value: searchTerm, onChange: (e) => {
                                setSearchTerm(e.target.value);
                            }, disabled: isAllChainsQueryLoading, placeholder: isAllChainsQueryLoading
                                ? "Loading chains..."
                                : locale.inputPlaceholder }), (deferredSearchTerm !== searchTerm || isAllChainsQueryLoading) && (_jsx("div", { style: {
                                position: "absolute",
                                right: spacing.md,
                            }, children: _jsx(Spinner, { size: "md", color: "accentText" }) }))] }) }), _jsx(Spacer, { y: "lg" }), _jsx(Container, { px: "md", children: _jsx(NetworkTabContent, { chainSections: filteredChainSections, onSwitch: handleSwitch, renderChain: props.networkSelector?.renderChain, connectLocale: props.connectLocale, client: props.client, close: props.closeModal }) }), onCustomClick && (_jsxs(_Fragment, { children: [_jsx(Line, {}), _jsx(Container, { p: "lg", children: _jsx(Button, { fullWidth: true, variant: "link", onClick: () => {
                                onCustomClick();
                                props.closeModal();
                            }, style: {
                                display: "flex",
                                fontSize: fontSize.sm,
                                boxShadow: "none",
                            }, children: locale.addCustomNetwork }) })] }))] }));
}
/**
 *
 * @internal
 */
const NetworkTabContent = (props) => {
    const { chainSections } = props;
    const noChainsToShow = chainSections.every((section) => section.chains.length === 0);
    return (_jsx(Container, { scrollY: true, animate: "fadein", style: {
            height: "330px",
            paddingBottom: spacing.lg,
        }, children: noChainsToShow ? (_jsxs(Container, { flex: "column", gap: "md", center: "both", color: "secondaryText", children: [_jsx(Spacer, { y: "xl" }), _jsx(CrossCircledIcon, { width: iconSize.xl, height: iconSize.xl }), _jsx(Text, { children: " No Results " })] })) : (chainSections.map((section, idx) => {
            if (section.chains.length === 0) {
                return null;
            }
            return (_jsxs(Fragment, { children: [idx !== 0 && _jsx(Spacer, { y: "lg" }), _jsx(SectionLabel, { children: section.label }), _jsx(Spacer, { y: "xs" }), _jsx(NetworkList, { chains: section.chains, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale })] }, section.label));
        })) }));
};
const NetworkList = /* @__PURE__ */ memo(function NetworkList(props) {
    // show 10 items first, when reaching the last item, show 10 more
    const { itemsToShow, lastItemRef } = useShowMore(10, 10);
    const switchChain = useSwitchActiveWalletChain();
    const activeChain = useActiveWalletChain();
    const [switchingChainId, setSwitchingChainId] = useState(-1);
    const [errorSwitchingChainId, setErrorSwitchingChainId] = useState(-1);
    const close = props.close;
    useEffect(() => {
        // if switching and switched successfully - close modal
        if (switchingChainId !== -1 && activeChain?.id === switchingChainId) {
            if (close) {
                close();
            }
        }
    }, [switchingChainId, close, activeChain?.id]);
    const handleSwitch = async (chain) => {
        setErrorSwitchingChainId(-1);
        setSwitchingChainId(chain.id);
        try {
            await switchChain(chain);
            props.onSwitch(chain);
        }
        catch (e) {
            setErrorSwitchingChainId(chain.id);
            console.error(e);
        }
        finally {
            setSwitchingChainId(-1);
        }
    };
    const RenderChain = props.renderChain;
    const chainsToShow = props.chains.slice(0, itemsToShow);
    return (_jsx(NetworkListUl, { children: chainsToShow.map((chain, i) => {
            if (!chain) {
                return null;
            }
            const confirming = switchingChainId === chain.id;
            const switchingFailed = errorSwitchingChainId === chain.id;
            const isLast = i === chainsToShow.length - 1;
            return (_jsx("li", { ref: isLast ? lastItemRef : undefined, children: RenderChain ? (_jsx(RenderChain, { switchChain: () => {
                        handleSwitch(chain);
                    }, chain: chain, switching: switchingChainId === chain.id, switchFailed: errorSwitchingChainId === chain.id, close: props.close })) : (_jsx(ChainButton, { chain: chain, confirming: confirming, onClick: () => handleSwitch(chain), switchingFailed: switchingFailed, client: props.client, connectLocale: props.connectLocale })) }, chain.id));
        }) }));
});
export const ChainButton = /* @__PURE__ */ memo(function ChainButton(props) {
    const locale = props.connectLocale;
    const { chain, confirming, switchingFailed } = props;
    const activeChain = useActiveWalletChain();
    const chainNameQuery = useChainName(chain);
    const chainIconQuery = useChainIconUrl(chain);
    let chainName;
    if (chainNameQuery.name) {
        chainName = _jsxs("span", { children: [chainNameQuery.name, " "] });
    }
    else {
        chainName = _jsx(Skeleton, { width: "150px", height: "20px" });
    }
    return (_jsxs(NetworkButton, { "data-active": activeChain?.id === chain.id, onClick: props.onClick, children: [!chainIconQuery.isLoading ? (_jsx(ChainIcon, { chainIconUrl: chainIconQuery.url, size: iconSize.lg, active: activeChain?.id === chain.id, loading: "lazy", client: props.client })) : (_jsx(Skeleton, { width: `${iconSize.lg}px`, height: `${iconSize.lg}px` })), confirming || switchingFailed ? (_jsxs("div", { style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: spacing.xs,
                }, children: [chainName, _jsxs(Container, { animate: "fadein", flex: "row", gap: "xxs", center: "y", children: [confirming && (_jsxs(_Fragment, { children: [_jsx(Text, { size: "xs", color: "accentText", children: locale.confirmInWallet }), _jsx(Spinner, { size: "xs", color: "accentText" })] })), switchingFailed && (_jsx(Container, { animate: "fadein", children: _jsx(Text, { size: "xs", color: "danger", children: locale.networkSelector.failedToSwitch }) }))] })] })) : (chainName)] }));
});
const TabButton = /* @__PURE__ */ (() => styled.button((_) => {
    const theme = useCustomTheme();
    return {
        all: "unset",
        fontSize: fontSize.sm,
        fontWeight: 500,
        color: theme.colors.secondaryText,
        cursor: "pointer",
        padding: `${spacing.sm} ${spacing.sm}`,
        WebkitTapHighlightColor: "transparent",
        borderRadius: radius.lg,
        transition: "background 0.2s ease, color 0.2s ease",
        "&[data-active='true']": {
            background: theme.colors.secondaryButtonBg,
            color: theme.colors.primaryText,
        },
    };
}))();
const SectionLabel = /* @__PURE__ */ StyledP(() => {
    const theme = useCustomTheme();
    return {
        fontSize: fontSize.sm,
        color: theme.colors.secondaryText,
        margin: 0,
        display: "block",
        padding: `0 ${spacing.xs}`,
    };
});
const NetworkListUl = /* @__PURE__ */ StyledUl({
    padding: 0,
    margin: 0,
    listStyle: "none",
    display: "flex",
    flexDirection: "column",
    gap: spacing.xs,
    boxSizing: "border-box",
});
const NetworkButton = /* @__PURE__ */ StyledButton((_) => {
    const theme = useCustomTheme();
    return {
        all: "unset",
        display: "flex",
        width: "100%",
        boxSizing: "border-box",
        alignItems: "center",
        gap: spacing.md,
        padding: `${spacing.xs} ${spacing.sm}`,
        borderRadius: radius.md,
        cursor: "pointer",
        transition: "background 0.2s ease",
        color: theme.colors.primaryText,
        fontWeight: 500,
        fontSize: fontSize.md,
        "&:hover": {
            background: theme.colors.secondaryButtonBg,
        },
        [media.mobile]: {
            fontSize: fontSize.sm,
        },
    };
});
const StyledMagnifyingGlassIcon = /* @__PURE__ */ styled(MagnifyingGlassIcon)((_) => {
    const theme = useCustomTheme();
    return {
        color: theme.colors.secondaryText,
        position: "absolute",
        left: spacing.sm,
    };
});
/**
 * Hook to open the Wallet Network Switcher Modal that shows allows users to switch to different network.
 *
 * @example
 * ```tsx
 * import { createThirdwebClient } from "thirdweb";
 * import { useNetworkSwitcherModal } from "thirdweb/react";
 * import { base, ethereum, polygon, sepolia, arbitrum } from "thirdweb/chains";
 *
 * const client = createThirdwebClient({
 *  clientId: "<your_client_id>",
 * });
 *
 * function Example() {
 *   const networkSwitcher = useNetworkSwitcherModal();
 *
 *   function handleClick() {
 *      networkSwitcher.open({
 *        client,
 *        theme: 'light'
 *        sections: [
 *          { label: 'Recently used', chains: [arbitrum, polygon] },
 *          { label: 'Popular', chains: [base, ethereum, sepolia] },
 *        ]
 *     });
 *   }
 *
 *   return <button onClick={handleClick}> Switch Network </button>
 * }
 * ```
 * @wallet
 */
export function useNetworkSwitcherModal() {
    const activeChain = useActiveWalletChain();
    const setRootEl = useContext(SetRootElementContext);
    const closeModal = useCallback(() => {
        setRootEl(null);
    }, [setRootEl]);
    const openNetworkSwitcher = useCallback(async (props) => {
        if (!activeChain) {
            throw new Error("No active wallet found");
        }
        const locale = await getConnectLocale(props.locale || "en_US");
        setRootEl(_jsx(CustomThemeProvider, { theme: props.theme, children: _jsx(Modal, { size: "compact", open: true, setOpen: (value) => {
                    if (!value) {
                        closeModal();
                    }
                }, style: {
                    paddingBottom: props.onCustomClick ? spacing.md : "0px",
                }, children: _jsx(NetworkSelectorContent, { client: props.client, closeModal: closeModal, chains: [activeChain], connectLocale: locale, networkSelector: {
                        onCustomClick: props.onCustomClick,
                        onSwitch: props.onSwitch,
                        renderChain: props.renderChain,
                        sections: props.sections,
                    } }) }) }));
    }, [setRootEl, closeModal, activeChain]);
    return {
        open: openNetworkSwitcher,
        close: closeModal,
    };
}
//# sourceMappingURL=NetworkSelector.js.map