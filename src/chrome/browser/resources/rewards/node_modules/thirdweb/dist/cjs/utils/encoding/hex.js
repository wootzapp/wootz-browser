"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHex = void 0;
exports.padHex = padHex;
exports.hexToString = hexToString;
exports.hexToBigInt = hexToBigInt;
exports.hexToNumber = hexToNumber;
exports.hexToBool = hexToBool;
exports.hexToUint8Array = hexToUint8Array;
exports.fromHex = fromHex;
exports.boolToHex = boolToHex;
exports.uint8ArrayToHex = uint8ArrayToHex;
exports.numberToHex = numberToHex;
exports.stringToHex = stringToHex;
exports.toHex = toHex;
const text_decoder_js_1 = require("../text-decoder.js");
const text_encoder_js_1 = require("../text-encoder.js");
// slightly tweaked re-exports from viem for the moment
const assert_size_js_1 = require("./helpers/assert-size.js");
const charcode_to_base_16_js_1 = require("./helpers/charcode-to-base-16.js");
var is_hex_js_1 = require("./helpers/is-hex.js");
Object.defineProperty(exports, "isHex", { enumerable: true, get: function () { return is_hex_js_1.isHex; } });
function trim(hexOrBytes, options = {}) {
    const dir = options.dir || "left";
    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
            sliceLength++;
        }
        else {
            break;
        }
    }
    data =
        dir === "left"
            ? data.slice(sliceLength)
            : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right") {
            data = `${data}0`;
        }
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
}
/**
 * Pads a hexadecimal string with zeros to a specified size.
 * @param hex_ The hexadecimal string to pad.
 * @param options The padding options.
 * @returns The padded hexadecimal string.
 * @throws Error if the resulting padded string exceeds the specified size.
 * @example
 * ```ts
 * import { padHex } from "thirdweb/utils";
 * const paddedHex = padHex("0x1a4", { size: 32 });
 * console.log(paddedHex); // "0x000000000000000000000000000001a4"
 * ```
 * @utils
 */
function padHex(hex_, options = {}) {
    const { dir, size = 32 } = options;
    if (size === null) {
        return hex_;
    }
    const hex = hex_.replace("0x", "");
    if (hex.length > size * 2) {
        throw new Error(`Size overflow: ${Math.ceil(hex.length / 2)} > ${size}`);
    }
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
}
/**
 * Converts a hexadecimal string to a UTF-8 string.
 * @param hex The hexadecimal string to convert.
 * @param opts The options for the conversion.
 * @returns The UTF-8 string representation of the hexadecimal string.
 * @example
 * ```ts
 * import { hexToString } from "thirdweb/utils";
 * const string = hexToString("0x48656c6c6f2c20776f726c6421");
 * console.log(string); // "Hello, world!"
 * ```
 * @utils
 */
function hexToString(hex, opts = {}) {
    let bytes = hexToUint8Array(hex);
    if (opts.size) {
        (0, assert_size_js_1.assertSize)(bytes, { size: opts.size });
        bytes = trim(bytes, { dir: "right" });
    }
    return (0, text_decoder_js_1.cachedTextDecoder)().decode(bytes);
}
/**
 * Converts a hexadecimal string to a BigInt.
 * @param hex - The hexadecimal string to convert.
 * @param opts - Optional parameters for the conversion.
 * @returns The BigInt representation of the hexadecimal string.
 * @example
 * ```ts
 * import { hexToBigInt } from "thirdweb/utils";
 * const bigInt = hexToBigInt("0x1a4");
 * console.log(bigInt); // 420n
 * ```
 * @utils
 */
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size) {
        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
    }
    const value = BigInt(hex);
    if (!signed) {
        return value;
    }
    const size = (hex.length - 2) / 2;
    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
    if (value <= max) {
        return value;
    }
    return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
}
/**
 * Converts a hexadecimal string to a number.
 * @param hex The hexadecimal string to convert.
 * @param opts Optional options for the conversion.
 * @returns The converted number.
 * @example
 * ```ts
 * import { hexToNumber } from "thirdweb/utils";
 * const number = hexToNumber("0x1a4");
 * console.log(number); // 420
 * ```
 * @utils
 */
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
/**
 * Converts a hexadecimal string to a boolean value.
 * @param hex The hexadecimal string to convert.
 * @param opts Optional options for the conversion.
 * @returns The boolean value corresponding to the hexadecimal string.
 * @throws Error if the hexadecimal string is invalid.
 * @example
 * ```ts
 * import { hexToBool } from "thirdweb/utils";
 * const bool = hexToBool("0x01");
 * console.log(bool); // true
 * ```
 * @utils
 */
function hexToBool(hex, opts = {}) {
    if (opts.size) {
        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
        // biome-ignore lint/style/noParameterAssign: for perf
        hex = trim(hex);
    }
    if (trim(hex) === "0x00") {
        return false;
    }
    if (trim(hex) === "0x01") {
        return true;
    }
    throw new Error(`Invalid hex boolean: ${hex}`);
}
/**
 * Converts a hexadecimal string to a Uint8Array.
 * @param hex The hexadecimal string to convert.
 * @param opts Options for the conversion.
 * @returns The Uint8Array representation of the hexadecimal string.
 * @example
 * ```ts
 * import { hexToUint8Array } from "thirdweb/utils";
 * const bytes = hexToUint8Array("0x48656c6c6f2c20776f726c6421");
 * console.log(bytes); // Uint8Array([72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33])
 * ```
 * @utils
 */
function hexToUint8Array(hex, opts = {}) {
    if (opts.size) {
        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
        // biome-ignore lint/style/noParameterAssign: for perf
        hex = padHex(hex, { dir: "right", size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) {
        hexString = `0${hexString}`;
    }
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = (0, charcode_to_base_16_js_1.charCodeToBase16)(hexString.charCodeAt(j++));
        const nibbleRight = (0, charcode_to_base_16_js_1.charCodeToBase16)(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new Error(`Invalid hex character: ${hexString}`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
/**
 * Converts a hexadecimal string to the specified type.
 * @param hex - The hexadecimal string to convert.
 * @param toOrOpts - The target type or conversion options.
 * @returns The converted value of the specified type.
 * @example
 * ```ts
 * import { fromHex } from "thirdweb/utils";
 * const string = fromHex("0x48656c6c6f2c20776f726c6421", "string");
 * console.log(string); // "Hello, world!"
 * ```
 * @utils
 */
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
    switch (opts.to) {
        case "number":
            return hexToNumber(hex, opts);
        case "bigint":
            return hexToBigInt(hex, opts);
        case "string":
            return hexToString(hex, opts);
        case "boolean":
            return hexToBool(hex, opts);
        default:
            return hexToUint8Array(hex, opts);
    }
}
//--------------------------------------------------------------------------
// TO HEX
//--------------------------------------------------------------------------
const hexes = /* @__PURE__ */ (() => Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0")))();
/**
 * Converts a boolean value to a hexadecimal string representation.
 * @param value - The boolean value to convert.
 * @param opts - Optional options for the conversion.
 * @returns The hexadecimal string representation of the boolean value.
 * @example
 * ```ts
 * import { boolToHex } from "thirdweb/utils";
 * const hex = boolToHex(true);
 * console.log(hex); // "0x01"
 * ```
 * @utils
 */
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
        return padHex(hex, { size: opts.size });
    }
    return hex;
}
/**
 * Converts an array of bytes to a hexadecimal string.
 * @param value - The array of bytes to convert.
 * @param opts - Optional parameters for the conversion.
 * @returns The hexadecimal string representation of the bytes.
 * @example
 * ```ts
 * import { uint8arrayToHex } from "thirdweb/utils";
 * const hex = uint8arrayToHex(new Uint8Array([72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100]));
 * console.log(hex); // "0x48656c6c6f2c20776f726c64"
 * ```
 * @utils
 */
function uint8ArrayToHex(value, opts = {}) {
    let string = "";
    for (let i = 0; i < value.length; i++) {
        // biome-ignore lint/style/noNonNullAssertion: we know this is defined
        string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === "number") {
        (0, assert_size_js_1.assertSize)(hex, { size: opts.size });
        return padHex(hex, { dir: "right", size: opts.size });
    }
    return hex;
}
/**
 * Converts a number or bigint to a hexadecimal string.
 * @param value_ - The number or bigint value to convert.
 * @param opts - Optional configuration options.
 * @returns The hexadecimal representation of the input value.
 * @throws An error if the input value is not within the safe integer range.
 * @example
 * ```ts
 * import { numberToHex } from "thirdweb/utils";
 * const hex = numberToHex(420);
 * console.log(hex); // "0x1a4"
 * ```
 * @utils
 */
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed) {
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        }
        else {
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
        }
    }
    else if (typeof value_ === "number") {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if ((maxValue && value > maxValue) || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new Error(`Number "${value_}${suffix}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${maxValue ? `(${minValue} to ${maxValue})` : `(above ${minValue})`}`);
    }
    const hex = `0x${(signed && value < 0
        ? (1n << BigInt(size * 8)) + BigInt(value)
        : value).toString(16)}`;
    if (size) {
        return padHex(hex, { size });
    }
    return hex;
}
/**
 * Converts a string to its hexadecimal representation.
 * @param value_ The string to convert to hexadecimal.
 * @param opts Options for the conversion.
 * @returns The hexadecimal representation of the input string.
 * @example
 * ```ts
 * import { stringToHex } from "thirdweb/utils";
 * const hex = stringToHex("Hello, world!");
 * console.log(hex); // "0x48656c6c6f2c20776f726c6421"
 * ```
 * @utils
 */
function stringToHex(value_, opts = {}) {
    const value = (0, text_encoder_js_1.cachedTextEncoder)().encode(value_);
    return uint8ArrayToHex(value, opts);
}
/**
 * Converts a value to its hexadecimal representation.
 * @param value - The value to convert to hexadecimal.
 * @param opts - Optional parameters for the conversion.
 * @returns The hexadecimal representation of the value.
 * @example
 * ```ts
 * import { toHex } from "thirdweb/utils";
 * const hex = toHex(420);
 * console.log(hex); // "0x1a4"
 * ```
 * @utils
 */
function toHex(value, opts = {}) {
    switch (typeof value) {
        case "number":
        case "bigint":
            return numberToHex(value, opts);
        case "string":
            return stringToHex(value, opts);
        case "boolean":
            return boolToHex(value, opts);
        default:
            return uint8ArrayToHex(value, opts);
    }
}
//# sourceMappingURL=hex.js.map