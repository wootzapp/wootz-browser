import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Cross1Icon, ExternalLinkIcon, TriangleDownIcon, } from "@radix-ui/react-icons";
import { useMemo } from "react";
import { getCachedChain } from "../../../../../../../chains/utils.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../../../constants/addresses.js";
import { formatNumber } from "../../../../../../../utils/formatNumber.js";
import { fontSize, iconSize, radius, spacing, } from "../../../../../../core/design-system/index.js";
import { useChainExplorers, useChainName, } from "../../../../../../core/hooks/others/useChainQuery.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { Container, Line, ModalHeader } from "../../../../components/basic.js";
import { Button, ButtonLink } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { TokenSymbol } from "../../../../components/token/TokenSymbol.js";
import { NATIVE_TOKEN } from "../../nativeToken.js";
import { PayTokenIcon } from "../PayTokenIcon.js";
import { StepIcon } from "../Stepper.js";
import { getBuyWithFiatStatusMeta, } from "../pay-transactions/statusMeta.js";
import { getCurrencyMeta } from "./currencies.js";
export function fiatQuoteToPartialQuote(quote) {
    const data = {
        fromCurrencyAmount: quote.fromCurrencyWithFees.amount,
        fromCurrencySymbol: quote.fromCurrencyWithFees.currencySymbol,
        onRampTokenAmount: quote.onRampToken.amount,
        toTokenAmount: quote.estimatedToAmountMin,
        onRampToken: {
            chainId: quote.onRampToken.token.chainId,
            tokenAddress: quote.onRampToken.token.tokenAddress,
            name: quote.onRampToken.token.name,
            symbol: quote.onRampToken.token.symbol,
        },
        toToken: {
            chainId: quote.toToken.chainId,
            tokenAddress: quote.toToken.tokenAddress,
            name: quote.toToken.name,
            symbol: quote.toToken.symbol,
        },
    };
    return data;
}
export function FiatSteps(props) {
    const statusMeta = props.status
        ? getBuyWithFiatStatusMeta(props.status)
        : undefined;
    const { toToken: toTokenMeta, onRampToken: onRampTokenMeta, onRampTokenAmount, fromCurrencySymbol, fromCurrencyAmount, toTokenAmount, } = props.partialQuote;
    const currency = getCurrencyMeta(fromCurrencySymbol);
    const isPartialSuccess = statusMeta?.progressStatus === "partialSuccess";
    const toChain = useMemo(() => getCachedChain(toTokenMeta.chainId), [toTokenMeta.chainId]);
    const destinationChain = useMemo(() => {
        if (props.status?.status !== "NOT_FOUND" && props.status?.destination) {
            return getCachedChain(props.status?.destination.token.chainId);
        }
        return undefined;
    }, [props.status]);
    const toToken = useMemo(() => {
        if (toTokenMeta.tokenAddress === NATIVE_TOKEN_ADDRESS) {
            return NATIVE_TOKEN;
        }
        const tokenInfo = {
            address: toTokenMeta.tokenAddress,
            name: toTokenMeta.name || "",
            symbol: toTokenMeta.symbol || "",
            // TODO: when icon is available in endpoint
            // icon: toTokenMeta.icon
        };
        return tokenInfo;
    }, [toTokenMeta]);
    const onRampChain = useMemo(() => getCachedChain(onRampTokenMeta.chainId), [onRampTokenMeta.chainId]);
    const onRampToken = useMemo(() => {
        if (onRampTokenMeta.tokenAddress === NATIVE_TOKEN_ADDRESS) {
            return NATIVE_TOKEN;
        }
        const tokenInfo = {
            address: onRampTokenMeta.tokenAddress,
            name: onRampTokenMeta.name || "",
            symbol: onRampTokenMeta.symbol || "",
            // TODO: when icon is available in endpoint
            // icon: onRampTokenMeta.icon,
        };
        return tokenInfo;
    }, [onRampTokenMeta]);
    const onRampName = useChainName(onRampChain);
    const onRampExplorers = useChainExplorers(onRampChain);
    const toChainName = useChainName(toChain);
    const toChainExplorers = useChainExplorers(toChain);
    const destinationName = useChainName(destinationChain);
    const onRampTokenInfo = (_jsx("div", { children: _jsxs(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(onRampTokenAmount), 6), " ", _jsx(TokenSymbol, { token: onRampToken, chain: onRampChain, size: "sm", inline: true })] }) }));
    const fiatIcon = _jsx(currency.icon, { size: iconSize.sm });
    const onRampTokenIcon = (_jsx(PayTokenIcon, { token: onRampToken, chain: onRampChain, size: "sm", client: props.client }));
    const toTokenIcon = (_jsx(PayTokenIcon, { token: toToken, chain: toChain, size: "sm", client: props.client }));
    const onRampChainInfo = _jsx(Text, { size: "xs", children: onRampName.name });
    const partialSuccessToTokenInfo = props.status?.status === "CRYPTO_SWAP_FALLBACK" &&
        props.status.destination ? (_jsxs("div", { children: [_jsxs(Text, { color: "secondaryText", size: "sm", inline: true, style: {
                    textDecoration: "line-through",
                }, children: [formatNumber(Number(toTokenAmount), 6), " ", _jsx(TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "secondaryText" })] }), " ", _jsxs(Text, { color: "danger", size: "sm", inline: true, children: [formatNumber(Number(props.status.destination.amount), 6), " ", _jsx(TokenSymbol, { token: {
                            address: props.status.destination.token.tokenAddress,
                            name: props.status.destination.token.name || "",
                            symbol: props.status.destination.token.symbol || "",
                        }, chain: toChain, size: "sm", inline: true, color: "danger" })] })] })) : null;
    const toTokenInfo = partialSuccessToTokenInfo || (_jsxs(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(toTokenAmount), 6), " ", _jsx(TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true })] }));
    const partialSuccessToChainInfo = props.status?.status === "CRYPTO_SWAP_FALLBACK" &&
        props.status.destination &&
        props.status.destination.token.chainId !==
            props.status.quote.toToken.chainId ? (_jsxs("div", { children: [_jsx(Text, { size: "xs", inline: true, style: {
                    textDecoration: "line-through",
                }, children: toChainName.name }), " ", _jsx(Text, { size: "xs", inline: true, children: destinationName.name })] })) : null;
    const toTokehChainInfo = partialSuccessToChainInfo || (_jsx(Text, { size: "xs", children: toChainName.name }));
    const onRampTxHash = props.status?.status !== "NOT_FOUND"
        ? props.status?.source?.transactionHash
        : undefined;
    const toTokenTxHash = props.status?.status !== "NOT_FOUND"
        ? props.status?.destination?.transactionHash
        : undefined;
    const showContinueBtn = !props.status ||
        props.status.status === "CRYPTO_SWAP_REQUIRED" ||
        props.status.status === "CRYPTO_SWAP_FAILED";
    function getStep1State() {
        if (!statusMeta) {
            if (props.step === 2) {
                return "completed";
            }
            return "actionRequired";
        }
        if (statusMeta.step === 2) {
            return "completed";
        }
        return statusMeta.progressStatus;
    }
    function getStep2State() {
        if (!statusMeta) {
            if (props.step === 2) {
                return "actionRequired";
            }
            return undefined;
        }
        if (statusMeta.step === 2) {
            return statusMeta.progressStatus;
        }
        return undefined;
    }
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: props.title, onBack: props.onBack }), _jsx(Spacer, { y: "lg" }), _jsx(PaymentStep, { title: _jsxs(Text, { color: "primaryText", size: "md", children: ["Get", " ", _jsx(TokenSymbol, { token: onRampToken, chain: onRampChain, size: "md", inline: true }), " ", "with ", props.partialQuote.fromCurrencySymbol] }), step: 1, from: {
                    icon: fiatIcon,
                    primaryText: (_jsxs(Text, { color: "primaryText", size: "sm", children: [formatNumber(Number(fromCurrencyAmount), 6), " ", fromCurrencySymbol] })),
                }, to: {
                    icon: onRampTokenIcon,
                    primaryText: onRampTokenInfo,
                    secondaryText: onRampChainInfo,
                }, state: getStep1State(), explorer: onRampExplorers.explorers[0]?.url && onRampTxHash
                    ? {
                        label: "View on Explorer",
                        url: `${onRampExplorers.explorers[0]?.url}/tx/${onRampTxHash}`,
                    }
                    : undefined }), _jsx(Spacer, { y: "md" }), _jsx(PaymentStep, { title: _jsxs(Text, { color: "primaryText", size: "md", children: ["Convert", " ", _jsx(TokenSymbol, { token: onRampToken, chain: onRampChain, size: "md", inline: true }), " ", "to ", _jsx(TokenSymbol, { token: toToken, chain: toChain, size: "md", inline: true })] }), step: 2, from: {
                    icon: onRampTokenIcon,
                    primaryText: onRampTokenInfo,
                    secondaryText: onRampChainInfo,
                }, to: {
                    icon: toTokenIcon,
                    primaryText: toTokenInfo,
                    secondaryText: toTokehChainInfo,
                }, state: getStep2State(), explorer: toChainExplorers.explorers[0]?.url && toTokenTxHash
                    ? {
                        label: "View on Explorer",
                        url: `${toChainExplorers.explorers[0].url}/tx/${toTokenTxHash}`,
                    }
                    : undefined }), isPartialSuccess &&
                props.status &&
                props.status.status !== "NOT_FOUND" &&
                props.status.source &&
                props.status.destination && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "md" }), _jsxs(Text, { color: "danger", size: "sm", center: true, children: ["Expected ", props.status.source?.token.symbol, ", Got", " ", props.status.destination?.token.symbol, " instead"] }), _jsx(Spacer, { y: "sm" })] })), showContinueBtn && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "md" }), _jsx(Button, { variant: "accent", onClick: props.onContinue, fullWidth: true, children: "Continue" })] }))] }));
}
function PaymentStep(props) {
    return (_jsxs(StepContainer, { state: props.state, children: [_jsxs(Text, { size: "sm", children: ["Step ", props.step] }), _jsx(Spacer, { y: "sm" }), props.title, _jsx(Spacer, { y: "sm" }), _jsx(Line, {}), _jsx(Spacer, { y: "md" }), _jsx(PaymentSubStep, { ...props.from }), _jsxs(Container, { color: "borderColor", style: {
                    paddingLeft: "18px",
                    position: "relative",
                    marginBlock: "3px",
                }, children: [_jsx("div", { style: {
                            height: "18px",
                            width: "2px",
                            backgroundColor: "currentColor",
                            transform: "translateX(-50%)",
                        } }), _jsx(TriangleDownIcon, { width: iconSize.sm, height: iconSize.sm, style: {
                            position: "absolute",
                            bottom: "0",
                            transform: "translate(-50%, 50%)",
                        } })] }), _jsx(PaymentSubStep, { ...props.to }), props.explorer && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "md" }), _jsxs(ButtonLink, { variant: "outline", fullWidth: true, href: props.explorer.url, style: {
                            fontSize: fontSize.xs,
                            padding: spacing.xs,
                        }, gap: "xxs", target: "_blank", children: [props.explorer.label, " ", _jsx(ExternalLinkIcon, { width: iconSize.xs, height: iconSize.xs })] })] }))] }));
}
function PaymentSubStep(props) {
    return (_jsxs(Container, { flex: "row", gap: "sm", center: "y", style: {
            flexWrap: "nowrap",
        }, children: [_jsx(Container, { p: "xs", borderColor: "borderColor", flex: "row", center: "both", style: {
                    borderStyle: "solid",
                    borderWidth: "1.5px",
                    borderRadius: radius.lg,
                }, children: props.icon }), _jsxs(Container, { flex: "column", gap: "xxs", children: [props.primaryText, props.secondaryText] })] }));
}
function StepContainer(props) {
    let color = "borderColor";
    let text;
    if (props.state === "pending") {
        text = "Pending";
        color = "accentText";
    }
    else if (props.state === "actionRequired") {
        color = "accentText";
    }
    else if (props.state === "completed") {
        text = "Completed";
        color = "success";
    }
    else if (props.state === "failed") {
        color = "danger";
        text = "Failed";
    }
    else if (props.state === "partialSuccess") {
        color = "danger";
        text = "Incomplete";
    }
    return (_jsxs(Container, { bg: "tertiaryBg", borderColor: color === "success" ? "borderColor" : color, py: "sm", px: "md", style: {
            borderRadius: radius.lg,
            alignItems: "flex-start",
            borderWidth: "1px",
            borderStyle: "solid",
            position: "relative",
        }, children: [props.children, _jsxs("div", { style: {
                    position: "absolute",
                    right: spacing.sm,
                    top: spacing.sm,
                    display: "flex",
                    gap: spacing.xs,
                    alignItems: "center",
                }, children: [props.state && text && (_jsx(Text, { size: "sm", color: color, children: text })), (props.state === "actionRequired" || props.state === "completed") && (_jsx(StepIcon, { isActive: props.state === "actionRequired", isDone: props.state === "completed" })), props.state === "pending" && _jsx(Spinner, { color: "accentText", size: "sm" }), props.state === "failed" && (_jsx(Container, { color: "danger", flex: "row", center: "both", children: _jsx(Cross1Icon, { width: iconSize.sm, height: iconSize.sm }) }))] })] }));
}
//# sourceMappingURL=FiatSteps.js.map