"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mintWithSignature = mintWithSignature;
exports.generateMintSignature = generateMintSignature;
const addresses_js_1 = require("../../../constants/addresses.js");
const address_js_1 = require("../../../utils/address.js");
const date_js_1 = require("../../../utils/date.js");
const random_js_1 = require("../../../utils/random.js");
const mintWithSignature_js_1 = require("../__generated__/ERC20Core/write/mintWithSignature.js");
const encodeBytesBeforeMintWithSignatureERC20_js_1 = require("../__generated__/MintableERC20/encode/encodeBytesBeforeMintWithSignatureERC20.js");
/**
 * Mints ERC20 tokens to a specified address with a signature via a MintableERC20 module.
 * @param options The options for minting tokens.
 * @returns A transaction to mint tokens.
 * @example
 * ```typescript
 * import { MintableERC20 } from "thirdweb/modules";
 *
 * // generate the payload and signature, this is typically done on the server
 * // requires to be generated with a wallet that has the MINTER_ROLE
 * const { payload, signature } = await MintableERC20.generateMintSignature({
 *   account,
 *   contract,
 *   mintRequest: {
 *     recipient: "0x...",
 *     quantity: "10",
 *   },
 * });
 *
 * // prepare the transaction, this is typically done on the client
 * // can be executed by any wallet
 * const transaction = MintableERC20.mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 *
 * // Send the transaction
 * await sendTransaction({ transaction, account });
 * ```
 * @modules MintableERC20
 */
function mintWithSignature(options) {
    return (0, mintWithSignature_js_1.mintWithSignature)({
        contract: options.contract,
        asyncParams: async () => {
            const { payload, signature } = options;
            return {
                to: payload.to,
                amount: payload.amount,
                data: payload.data,
                signature,
            };
        },
    });
}
/**
 * Generates a mint signature for a given mint request to be used with a MintableERC20 module.
 * @param options The options for minting tokens.
 * @returns A transaction to mint tokens.
 * @example
 * ```typescript
 * import { MintableERC20 } from "thirdweb/modules";
 *
 * // generate the payload and signature, this is typically done on the server
 * // requires to be generated with a wallet that has the MINTER_ROLE
 * const { payload, signature } = await MintableERC20.generateMintSignature({
 *   account,
 *   contract,
 *   mintRequest: {
 *     recipient: "0x...",
 *     quantity: "10",
 *   },
 * });
 *
 * // prepare the transaction, this is typically done on the client
 * // can be executed by any wallet
 * const transaction = MintableERC20.mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 *
 * // Send the transaction
 * await sendTransaction({ transaction, account });
 * ```
 * @modules MintableERC20
 */
async function generateMintSignature(options) {
    const { mintRequest, account, contract } = options;
    const currency = (0, address_js_1.getAddress)(mintRequest.currency || addresses_js_1.NATIVE_TOKEN_ADDRESS);
    const [pricePerUnit, quantity] = await Promise.all([
        // price per token in wei
        (async () => {
            // if pricePerUnit is provided, use it
            if ("pricePerUnit" in mintRequest && mintRequest.pricePerUnit) {
                return mintRequest.pricePerUnit;
            }
            // if neither price nor priceInWei is provided, default to 0
            return 0n;
        })(),
        // quantity in wei
        (async () => {
            // if the quantity is already passed in wei, use it
            if ("quantityWei" in mintRequest) {
                return mintRequest.quantityWei;
            }
            // otherwise convert the quantity to wei using the contract's OWN decimals
            const { convertErc20Amount } = await Promise.resolve().then(() => require("../../../utils/extensions/convert-erc20-amount.js"));
            return await convertErc20Amount({
                amount: mintRequest.quantity,
                client: contract.client,
                chain: contract.chain,
                erc20Address: contract.address,
            });
        })(),
    ]);
    const uid = options.mintRequest.uid || (0, random_js_1.randomBytesHex)();
    const startTime = mintRequest.validityStartTimestamp || new Date(0);
    const endTime = mintRequest.validityEndTimestamp || (0, date_js_1.tenYearsFromNow)();
    const mintParams = {
        pricePerUnit,
        uid,
        currency,
        startTimestamp: Number((0, date_js_1.dateToSeconds)(startTime)),
        endTimestamp: Number((0, date_js_1.dateToSeconds)(endTime)),
    };
    const payload = {
        to: (0, address_js_1.getAddress)(mintRequest.recipient),
        amount: quantity,
        data: (0, encodeBytesBeforeMintWithSignatureERC20_js_1.encodeBytesBeforeMintWithSignatureERC20Params)({
            params: mintParams,
        }),
    };
    const signature = await account.signTypedData({
        domain: {
            name: "ERC20Core",
            version: "1",
            chainId: contract.chain.id,
            verifyingContract: contract.address,
        },
        types: { MintRequestERC20: MintRequestERC20 },
        primaryType: "MintRequestERC20",
        message: payload,
    });
    return { payload, signature };
}
const MintRequestERC20 = [
    { type: "address", name: "to" },
    { type: "uint256", name: "amount" },
    { type: "bytes", name: "data" },
];
//# sourceMappingURL=mintWithSignature.js.map