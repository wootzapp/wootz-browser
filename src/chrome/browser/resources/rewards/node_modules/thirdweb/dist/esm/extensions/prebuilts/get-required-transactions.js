import { getDeployedCreate2Factory } from "../../contract/deployment/utils/create-2-factory.js";
import { getDeployedInfraContract } from "../../contract/deployment/utils/infra.js";
import { getDeployedInfraContractFromMetadata } from "../../contract/deployment/utils/infra.js";
import { computePublishedContractAddress } from "../../utils/any-evm/compute-published-contract-address.js";
import { isZkSyncChain } from "../../utils/any-evm/zksync/isZkSyncChain.js";
/**
 * @internal
 */
export async function getRequiredTransactions(options) {
    const { chain, client, deployMetadata, implementationConstructorParams, modules = [], } = options;
    if (deployMetadata?.deployType === "autoFactory") {
        const results = await Promise.all([
            getDeployedCreate2Factory({
                chain,
                client,
            }).then((c) => c || isZkSyncChain(chain)
                ? null
                : { type: "infra", contractId: "Create2Factory" }),
            getDeployedInfraContract({
                chain,
                client,
                contractId: "Forwarder",
            }).then((c) => c || isZkSyncChain(chain)
                ? null
                : { type: "infra", contractId: "Forwarder" }),
            getDeployedInfraContract({
                chain,
                client,
                contractId: "TWCloneFactory",
                constructorParams: {
                    _trustedForwarder: await computePublishedContractAddress({
                        chain,
                        client,
                        contractId: "Forwarder",
                    }),
                },
            }).then((c) => c || isZkSyncChain(chain)
                ? null
                : { type: "infra", contractId: "TWCloneFactory" }),
            // TODO (deploy): add WETH contract check for implementations that need it (check implementation constructor params)
            getTransactionsForImplementation({
                chain,
                client,
                deployMetadata,
                implementationConstructorParams,
            }),
            ...modules.map((m) => getDeployedInfraContractFromMetadata({
                chain,
                client,
                contractMetadata: m.deployMetadata,
            }).then((c) => c
                ? null
                : {
                    type: "module",
                    contractId: m.deployMetadata.name,
                })),
        ]);
        results.push({ type: "proxy", contractId: deployMetadata.name });
        return results.flat().filter((r) => r !== null);
    }
    return [{ type: "implementation", contractId: deployMetadata.name }];
}
async function getTransactionsForImplementation(options) {
    const { chain, client, deployMetadata, implementationConstructorParams } = options;
    if (deployMetadata.name === "MarketplaceV3") {
        return getTransactionsForMaketplaceV3(options);
    }
    const constructorParams = implementationConstructorParams ??
        (await getAllDefaultConstructorParamsForImplementation({
            chain,
            client,
        }));
    const result = await getDeployedInfraContract({
        chain,
        client,
        contractId: deployMetadata.name,
        constructorParams,
        publisher: deployMetadata.publisher,
        version: deployMetadata.version,
    }).then((c) => c
        ? null
        : {
            type: "implementation",
            contractId: deployMetadata.name,
        });
    return result ? [result] : [];
}
async function getTransactionsForMaketplaceV3(options) {
    const { chain, client } = options;
    const WETHAdress = await computePublishedContractAddress({
        chain,
        client,
        contractId: "WETH9",
    });
    const extensions = await Promise.all([
        getDeployedInfraContract({
            chain,
            client,
            contractId: "WETH9",
        }).then((c) => c ? null : { type: "infra", contractId: "WETH9" }),
        getDeployedInfraContract({
            chain,
            client,
            contractId: "DirectListingsLogic",
            constructorParams: { _nativeTokenWrapper: WETHAdress },
        }).then((c) => c
            ? null
            : { type: "extension", contractId: "DirectListingsLogic" }),
        getDeployedInfraContract({
            chain,
            client,
            contractId: "EnglishAuctionsLogic",
            constructorParams: { _nativeTokenWrapper: WETHAdress },
        }).then((c) => c
            ? null
            : { type: "extension", contractId: "EnglishAuctionsLogic" }),
        getDeployedInfraContract({
            chain,
            client,
            contractId: "OffersLogic",
        }).then((c) => c ? null : { type: "extension", contractId: "OffersLogic" }),
    ]);
    // hacky assumption: if we need to deploy any of the extensions, we also need to deploy the implementation
    const transactions = extensions.filter((e) => e !== null);
    if (transactions.length) {
        transactions.push({ type: "implementation", contractId: "MarketplaceV3" });
    }
    return transactions;
}
export async function getAllDefaultConstructorParamsForImplementation(args) {
    const { chain, client } = args;
    const [forwarder, weth] = await Promise.all([
        computePublishedContractAddress({
            chain,
            client,
            contractId: "Forwarder",
        }),
        computePublishedContractAddress({
            chain,
            client,
            contractId: "WETH9",
        }),
    ]);
    return {
        trustedForwarder: forwarder,
        nativeTokenWrapper: weth,
    };
}
//# sourceMappingURL=get-required-transactions.js.map