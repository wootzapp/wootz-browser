"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mintWithSignature = mintWithSignature;
exports.generateMintSignature = generateMintSignature;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../constants/addresses.js");
const bigint_js_1 = require("../../../utils/bigint.js");
const date_js_1 = require("../../../utils/date.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const random_js_1 = require("../../../utils/random.js");
const mintWithSignature_js_1 = require("../__generated__/ISignatureMintERC1155/write/mintWithSignature.js");
/**
 * Mints a new ERC1155 token with the given minter signature
 * @param options - The transaction options.
 * @example
 * ```ts
 * import { mintWithSignature, generateMintSignature } from "thirdweb/extensions/erc1155";
 * import { sendTransaction } from "thirdweb";
 *
 * const { payload, signature } = await generateMintSignature(...)
 *
 * const transaction = mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 * await sendTransaction({ transaction, account });
 * ```
 * @extension ERC1155
 * @returns A promise that resolves to the transaction result.
 */
function mintWithSignature(options) {
    const value = (0, addresses_js_1.isNativeTokenAddress)(options.payload.currency)
        ? options.payload.pricePerToken * options.payload.quantity
        : 0n;
    return (0, mintWithSignature_js_1.mintWithSignature)({
        ...options,
        overrides: {
            value,
        },
    });
}
/**
 * Generates the payload and signature for minting an ERC1155 token.
 * @param options - The options for the minting process.
 * @example
 * ```ts
 * import { mintWithSignature, generateMintSignature } from "thirdweb/extensions/erc1155";
 *
 * const { payload, signature } = await generateMintSignature({
 *   account,
 *   contract,
 *   mintRequest: {
 *     to: "0x...",
 *     quantity: 10n,
 *     metadata: {
 *       name: "My NFT",
 *       description: "This is my NFT",
 *       image: "https://example.com/image.png",
 *     },
 *   },
 * });
 *
 * const transaction = mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 * await sendTransaction({ transaction, account });
 * ```
 * @extension ERC1155
 * @returns A promise that resolves to the payload and signature.
 */
async function generateMintSignature(options) {
    const { mintRequest, account, contract } = options;
    const currency = mintRequest.currency || addresses_js_1.NATIVE_TOKEN_ADDRESS;
    const [pricePerToken, uri, uid] = await Promise.all([
        // price per token in wei
        (async () => {
            // if priceInWei is provided, use it
            if ("pricePerTokenWei" in mintRequest && mintRequest.pricePerTokenWei) {
                return mintRequest.pricePerTokenWei;
            }
            // if price is provided, convert it to wei
            if ("pricePerToken" in mintRequest && mintRequest.pricePerToken) {
                const { convertErc20Amount } = await Promise.resolve().then(() => require("../../../utils/extensions/convert-erc20-amount.js"));
                return await convertErc20Amount({
                    amount: mintRequest.pricePerToken,
                    client: contract.client,
                    chain: contract.chain,
                    erc20Address: currency,
                });
            }
            // if neither price nor priceInWei is provided, default to 0
            return 0n;
        })(),
        // uri
        (async () => {
            if ("metadata" in mintRequest) {
                if (typeof mintRequest.metadata === "object") {
                    // async import the upload function because it is not always required
                    const { upload } = await Promise.resolve().then(() => require("../../../storage/upload.js"));
                    return await upload({
                        client: options.contract.client,
                        files: [mintRequest.metadata],
                    });
                }
                return mintRequest.metadata;
            }
            return "";
        })(),
        // uid computation
        (() => {
            if (mintRequest.uid) {
                return (0, hex_js_1.isHex)(mintRequest.uid)
                    ? mintRequest.uid
                    : (0, hex_js_1.stringToHex)(mintRequest.uid, { size: 32 });
            }
            return (0, random_js_1.randomBytesHex)();
        })(),
    ]);
    const startTime = mintRequest.validityStartTimestamp || new Date(0);
    const endTime = mintRequest.validityEndTimestamp || (0, date_js_1.tenYearsFromNow)();
    const payload = {
        uri,
        currency,
        uid,
        pricePerToken,
        tokenId: "tokenId" in mintRequest && mintRequest.tokenId !== undefined
            ? mintRequest.tokenId
            : viem_1.maxUint256,
        quantity: mintRequest.quantity,
        to: mintRequest.to,
        royaltyRecipient: mintRequest.royaltyRecipient || account.address,
        royaltyBps: (0, bigint_js_1.toBigInt)(mintRequest.royaltyBps || 0),
        primarySaleRecipient: mintRequest.primarySaleRecipient || account.address,
        validityStartTimestamp: (0, date_js_1.dateToSeconds)(startTime),
        validityEndTimestamp: (0, date_js_1.dateToSeconds)(endTime),
    };
    const signature = await account.signTypedData({
        domain: {
            name: options.contractType || "TokenERC1155",
            version: "1",
            chainId: contract.chain.id,
            verifyingContract: contract.address,
        },
        types: { MintRequest: MintRequest1155 },
        primaryType: "MintRequest",
        message: payload,
    });
    return { payload, signature };
}
const MintRequest1155 = [
    { name: "to", type: "address" },
    { name: "royaltyRecipient", type: "address" },
    { name: "royaltyBps", type: "uint256" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "tokenId", type: "uint256" },
    { name: "uri", type: "string" },
    { name: "quantity", type: "uint256" },
    { name: "pricePerToken", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
];
//# sourceMappingURL=sigMint.js.map