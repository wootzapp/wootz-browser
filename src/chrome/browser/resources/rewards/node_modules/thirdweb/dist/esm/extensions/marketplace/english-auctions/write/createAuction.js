import { NATIVE_TOKEN_ADDRESS, isNativeTokenAddress, } from "../../../../constants/addresses.js";
import { getContract } from "../../../../contract/contract.js";
import { eth_getBlockByNumber } from "../../../../rpc/actions/eth_getBlockByNumber.js";
import { getRpcClient } from "../../../../rpc/rpc.js";
import { toUnits } from "../../../../utils/units.js";
import { isERC721 } from "../../../erc721/read/isERC721.js";
import { isERC1155 } from "../../../erc1155/read/isERC1155.js";
import { createAuction as generatedCreateAuction } from "../../__generated__/IEnglishAuctions/write/createAuction.js";
/**
 * Creates an auction.
 * @param options The options for creating the auction.
 * @returns The result of creating the auction.
 * @extension MARKETPLACE
 * @example
 * ```typescript
 * import { createAuction } from "thirdweb/extensions/marketplace";
 * import { sendTransaction } from "thirdweb";
 *
 * const transaction = createAuction({...});
 *
 * await sendTransaction({ transaction, account });
 * ```
 */
export function createAuction(options) {
    return generatedCreateAuction({
        ...options,
        asyncParams: async () => {
            const assetContract = getContract({
                ...options.contract,
                address: options.assetContractAddress,
            });
            const rpcClient = getRpcClient(options.contract);
            const [assetIsERC721, assetIsERC1155, lastestBlock] = await Promise.all([
                isERC721({ contract: assetContract }),
                isERC1155({ contract: assetContract }),
                eth_getBlockByNumber(rpcClient, { blockTag: "latest" }),
            ]);
            // validate valid asset
            if (!assetIsERC721 && !assetIsERC1155) {
                throw new Error("AssetContract must implement ERC 1155 or ERC 721.");
            }
            // validate the timestamps
            let startTimestamp = BigInt(Math.floor((options.startTimestamp ?? new Date()).getTime() / 1000));
            const endTimestamp = BigInt(Math.floor((options.endTimestamp ??
                new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000)).getTime() / 1000));
            if (startTimestamp <= lastestBlock.timestamp) {
                // set the start time to the next block if it is in the past
                startTimestamp = lastestBlock.timestamp + 1n;
            }
            if (startTimestamp >= endTimestamp) {
                throw new Error("Start time must be before end time.");
            }
            // valdiate quantity
            let quantity;
            if (assetIsERC721) {
                // force quantity to 1 for ERC721s
                quantity = 1n;
            }
            else {
                // otherwise use the provided quantity or default to 1
                quantity = options.quantity ?? 1n;
            }
            const currencyAddress = options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS;
            // validate buyout bid amount
            let buyoutBidAmount;
            if ("buyoutBidAmount" in options) {
                // for native token, we know decimals are 18
                if (isNativeTokenAddress(currencyAddress)) {
                    buyoutBidAmount = toUnits(options.buyoutBidAmount, 18);
                }
                else {
                    // otherwise get the decimals of the currency
                    const currencyContract = getContract({
                        ...options.contract,
                        address: currencyAddress,
                    });
                    const { decimals } = await import("../../../erc20/read/decimals.js");
                    const currencyDecimals = await decimals({
                        contract: currencyContract,
                    });
                    buyoutBidAmount = toUnits(options.buyoutBidAmount, currencyDecimals);
                }
            }
            else {
                buyoutBidAmount = BigInt(options.buyoutBidAmountWei);
            }
            // validate buyout bid amount
            let minimumBidAmount;
            if ("minimumBidAmount" in options) {
                // for native token, we know decimals are 18
                if (isNativeTokenAddress(currencyAddress)) {
                    minimumBidAmount = toUnits(options.minimumBidAmount, 18);
                }
                else {
                    // otherwise get the decimals of the currency
                    const currencyContract = getContract({
                        ...options.contract,
                        address: currencyAddress,
                    });
                    const { decimals } = await import("../../../erc20/read/decimals.js");
                    const currencyDecimals = await decimals({
                        contract: currencyContract,
                    });
                    minimumBidAmount = toUnits(options.minimumBidAmount, currencyDecimals);
                }
            }
            else {
                minimumBidAmount = BigInt(options.minimumBidAmountWei);
            }
            return {
                params: {
                    assetContract: options.assetContractAddress,
                    tokenId: options.tokenId,
                    currency: options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS,
                    quantity,
                    startTimestamp,
                    endTimestamp,
                    buyoutBidAmount,
                    minimumBidAmount,
                    // TODO validate these?
                    bidBufferBps: BigInt(options.bidBufferBps ?? 500),
                    timeBufferInSeconds: BigInt(options.timeBufferInSeconds ?? 900),
                },
                overrides: {
                    extraGas: 50000n, // add extra gas to account for router call
                },
            };
        },
    });
}
//# sourceMappingURL=createAuction.js.map