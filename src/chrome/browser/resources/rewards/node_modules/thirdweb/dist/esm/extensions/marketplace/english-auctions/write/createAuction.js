import { NATIVE_TOKEN_ADDRESS, isNativeTokenAddress, } from "../../../../constants/addresses.js";
import { getContract } from "../../../../contract/contract.js";
import { eth_getBlockByNumber } from "../../../../rpc/actions/eth_getBlockByNumber.js";
import { getRpcClient } from "../../../../rpc/rpc.js";
import { toUnits } from "../../../../utils/units.js";
import { isERC721 } from "../../../erc721/read/isERC721.js";
import { isERC1155 } from "../../../erc1155/read/isERC1155.js";
import * as CreateAuction from "../../__generated__/IEnglishAuctions/write/createAuction.js";
/**
 * Creates an auction.
 * @param options The options for creating the auction.
 * @returns The result of creating the auction.
 * @extension MARKETPLACE
 * @example
 * ```typescript
 * import { createAuction } from "thirdweb/extensions/marketplace";
 * import { sendTransaction } from "thirdweb";
 *
 * const transaction = createAuction({...});
 *
 * await sendTransaction({ transaction, account });
 * ```
 */
export function createAuction(options) {
    return CreateAuction.createAuction({
        ...options,
        asyncParams: async () => {
            const assetContract = getContract({
                ...options.contract,
                address: options.assetContractAddress,
            });
            const rpcClient = getRpcClient(options.contract);
            const [assetIsERC721, assetIsERC1155, lastestBlock] = await Promise.all([
                isERC721({ contract: assetContract }),
                isERC1155({ contract: assetContract }),
                eth_getBlockByNumber(rpcClient, { blockTag: "latest" }),
            ]);
            // validate valid asset
            if (!assetIsERC721 && !assetIsERC1155) {
                throw new Error("AssetContract must implement ERC 1155 or ERC 721.");
            }
            // validate the timestamps
            let startTimestamp = BigInt(Math.floor((options.startTimestamp ?? new Date()).getTime() / 1000));
            const endTimestamp = BigInt(Math.floor((options.endTimestamp ??
                new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000)).getTime() / 1000));
            if (startTimestamp <= lastestBlock.timestamp) {
                // set the start time to the next block if it is in the past
                startTimestamp = lastestBlock.timestamp + 1n;
            }
            if (startTimestamp >= endTimestamp) {
                throw new Error("Start time must be before end time.");
            }
            // valdiate quantity
            let quantity;
            if (assetIsERC721) {
                // force quantity to 1 for ERC721s
                quantity = 1n;
            }
            else {
                // otherwise use the provided quantity or default to 1
                quantity = options.quantity ?? 1n;
            }
            const currencyAddress = options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS;
            // validate buyout bid amount
            let buyoutBidAmount;
            if ("buyoutBidAmount" in options) {
                // for native token, we know decimals are 18
                if (isNativeTokenAddress(currencyAddress)) {
                    buyoutBidAmount = toUnits(options.buyoutBidAmount, 18);
                }
                else {
                    // otherwise get the decimals of the currency
                    const currencyContract = getContract({
                        ...options.contract,
                        address: currencyAddress,
                    });
                    const { decimals } = await import("../../../erc20/read/decimals.js");
                    const currencyDecimals = await decimals({
                        contract: currencyContract,
                    });
                    buyoutBidAmount = toUnits(options.buyoutBidAmount, currencyDecimals);
                }
            }
            else {
                buyoutBidAmount = BigInt(options.buyoutBidAmountWei);
            }
            // validate buyout bid amount
            let minimumBidAmount;
            if ("minimumBidAmount" in options) {
                // for native token, we know decimals are 18
                if (isNativeTokenAddress(currencyAddress)) {
                    minimumBidAmount = toUnits(options.minimumBidAmount, 18);
                }
                else {
                    // otherwise get the decimals of the currency
                    const currencyContract = getContract({
                        ...options.contract,
                        address: currencyAddress,
                    });
                    const { decimals } = await import("../../../erc20/read/decimals.js");
                    const currencyDecimals = await decimals({
                        contract: currencyContract,
                    });
                    minimumBidAmount = toUnits(options.minimumBidAmount, currencyDecimals);
                }
            }
            else {
                minimumBidAmount = BigInt(options.minimumBidAmountWei);
            }
            return {
                params: {
                    assetContract: options.assetContractAddress,
                    tokenId: options.tokenId,
                    currency: options.currencyContractAddress ?? NATIVE_TOKEN_ADDRESS,
                    quantity,
                    startTimestamp,
                    endTimestamp,
                    buyoutBidAmount,
                    minimumBidAmount,
                    // TODO validate these?
                    bidBufferBps: BigInt(options.bidBufferBps ?? 500),
                    timeBufferInSeconds: BigInt(options.timeBufferInSeconds ?? 900),
                },
                overrides: {
                    extraGas: 50000n, // add extra gas to account for router call
                },
            };
        },
    });
}
/**
 * Checks if the `createAuction` method is supported by the given contract.
 * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using "whatsabi" or if you have the ABI of the contract available you can use it to generate the selectors.
 * @returns A boolean indicating if the `createAuction` method is supported.
 * @extension MARKETPLACE
 * @example
 * ```ts
 * import { isCreateAuctionSupported } from "thirdweb/extensions/marketplace";
 *
 * const supported = isCreateAuctionSupported(["0x..."]);
 * ```
 */
export function isCreateAuctionSupported(availableSelectors) {
    return CreateAuction.isCreateAuctionSupported(availableSelectors);
}
//# sourceMappingURL=createAuction.js.map