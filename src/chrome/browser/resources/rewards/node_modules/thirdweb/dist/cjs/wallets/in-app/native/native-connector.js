"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InAppNativeConnector = void 0;
const json_js_1 = require("../../../utils/json.js");
const nativeStorage_js_1 = require("../../../utils/storage/nativeStorage.js");
const passkeys_js_1 = require("../core/authentication/passkeys.js");
const siwe_js_1 = require("../core/authentication/siwe.js");
const types_js_1 = require("../core/authentication/types.js");
const otp_js_1 = require("../web/lib/auth/otp.js");
const native_auth_js_1 = require("./auth/native-auth.js");
const fetchers_js_1 = require("./helpers/api/fetchers.js");
const logout_js_1 = require("./helpers/auth/logout.js");
const middleware_js_1 = require("./helpers/auth/middleware.js");
const local_js_1 = require("./helpers/storage/local.js");
const retrieval_js_1 = require("./helpers/wallet/retrieval.js");
class InAppNativeConnector {
    constructor(options) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.options = options;
    }
    async getUser() {
        const localData = await (0, local_js_1.getWalletUserDetails)(this.options.client.clientId);
        const userStatus = await (0, fetchers_js_1.fetchUserDetails)({
            client: this.options.client,
            email: localData?.email,
        });
        if (userStatus.status === types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {
            return {
                status: userStatus.status,
                authDetails: userStatus.storedToken.authDetails,
                walletAddress: userStatus.walletAddress,
                account: await this.getAccount(),
            };
        }
        if (userStatus.status === types_js_1.UserWalletStatus.LOGGED_IN_NEW_DEVICE) {
            return {
                status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,
                authDetails: userStatus.storedToken.authDetails,
            };
        }
        if (userStatus.status === types_js_1.UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED) {
            return {
                status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,
                authDetails: userStatus.storedToken.authDetails,
            };
        }
        // Logged out
        return { status: types_js_1.UserWalletStatus.LOGGED_OUT };
    }
    getAccount() {
        return (0, retrieval_js_1.getExistingUserAccount)({ client: this.options.client });
    }
    preAuthenticate(args) {
        return (0, otp_js_1.sendOtp)({
            ...args,
            client: this.options.client,
        });
    }
    async authenticate(params) {
        const strategy = params.strategy;
        switch (strategy) {
            case "email":
            case "phone": {
                return (0, otp_js_1.verifyOtp)(params);
            }
            case "wallet": {
                return (0, siwe_js_1.siweAuthenticate)({
                    client: this.options.client,
                    wallet: params.wallet,
                    chain: params.chain,
                });
            }
            case "google":
            case "facebook":
            case "discord":
            case "apple": {
                const ExpoLinking = require("expo-linking");
                const redirectUrl = params.redirectUrl || ExpoLinking.createURL("");
                return (0, native_auth_js_1.authenticate)({ strategy, redirectUrl }, this.options.client);
            }
            case "passkey":
                return this.passkeyAuth(params);
            default:
                throw new Error(`Unsupported authentication type: ${strategy}`);
        }
    }
    async connect(params) {
        const strategy = params.strategy;
        switch (strategy) {
            case "email": {
                return await this.validateOtp({
                    email: params.email,
                    verificationCode: params.verificationCode,
                    strategy: "email",
                    client: this.options.client,
                });
            }
            case "phone": {
                return await this.validateOtp({
                    phoneNumber: params.phoneNumber,
                    verificationCode: params.verificationCode,
                    strategy: "phone",
                    client: this.options.client,
                });
            }
            case "google":
            case "facebook":
            case "discord":
            case "farcaster":
            case "telegram":
            case "apple": {
                const ExpoLinking = require("expo-linking");
                const redirectUrl = params.redirectUrl || ExpoLinking.createURL(""); // Will default to the app scheme
                return this.socialLogin({
                    strategy,
                    redirectUrl,
                });
            }
            case "wallet": {
                return this.siweLogin({
                    wallet: params.wallet,
                    chain: params.chain,
                });
            }
            case "jwt": {
                return this.customJwt({
                    jwt: params.jwt,
                    password: params.encryptionKey,
                });
            }
            case "auth_endpoint": {
                return this.authEndpoint({
                    payload: params.payload,
                    encryptionKey: params.encryptionKey,
                });
            }
            case "passkey": {
                const authToken = await this.passkeyAuth(params);
                const account = await this.getAccount();
                return {
                    user: {
                        status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                        account,
                        authDetails: authToken.storedToken.authDetails,
                        walletAddress: account.address,
                    },
                };
            }
            case "iframe": {
                throw new Error("iframe_email_verification is not supported in native");
            }
            case "iframe_email_verification": {
                throw new Error("iframe_email_verification is not supported in native");
            }
            default:
                assertUnreachable(strategy);
        }
    }
    async passkeyAuth(args) {
        const { type, passkeyName, client, ecosystem } = args;
        const domain = this.options.passkeyDomain;
        if (!domain) {
            throw new Error("Passkey domain is required for native platforms. Please pass it in the 'auth' options when creating the inAppWallet().");
        }
        try {
            const { PasskeyNativeClient } = await Promise.resolve().then(() => require("./auth/passkeys.js"));
            const passkeyClient = new PasskeyNativeClient();
            const storage = nativeStorage_js_1.nativeLocalStorage;
            let authToken;
            if (type === "sign-up") {
                authToken = await (0, passkeys_js_1.registerPasskey)({
                    client,
                    ecosystem,
                    username: passkeyName,
                    passkeyClient,
                    storage,
                    rp: {
                        id: domain,
                        name: domain,
                    },
                });
            }
            else {
                authToken = await (0, passkeys_js_1.loginWithPasskey)({
                    client,
                    ecosystem,
                    passkeyClient,
                    storage,
                    rp: {
                        id: domain,
                        name: domain,
                    },
                });
            }
            const toStoreToken = {
                jwtToken: authToken.storedToken.jwtToken,
                authDetails: authToken.storedToken.authDetails,
                authProvider: authToken.storedToken.authProvider,
                developerClientId: authToken.storedToken.developerClientId,
                cookieString: authToken.storedToken.cookieString,
                // we should always store the jwt cookie since there's no concept of cookie in react native
                shouldStoreCookieString: true,
                isNewUser: authToken.storedToken.isNewUser,
            };
            await (0, middleware_js_1.postAuth)({ storedToken: toStoreToken, client });
            return authToken;
        }
        catch (error) {
            console.error(`Error while signing in with passkey. ${error?.message || typeof error === "object" ? (0, json_js_1.stringify)(error) : error}`);
            if (error instanceof Error) {
                throw new Error(`Error signing in with passkey: ${error.message}`);
            }
            throw new Error("An unknown error occurred signing in with passkey");
        }
    }
    async validateOtp(options) {
        try {
            const { storedToken } = await (0, native_auth_js_1.otpLogin)(options);
            const account = await this.getAccount();
            return {
                user: {
                    status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                    account,
                    authDetails: storedToken.authDetails,
                    walletAddress: account.address,
                },
            };
        }
        catch (error) {
            console.error(`Error while validating OTP: ${error}`);
            if (error instanceof Error) {
                throw new Error(`Error while validating otp: ${error.message}`);
            }
            throw new Error("An unknown error occurred while validating otp");
        }
    }
    // TODO (rn) expose in the interface
    async deleteActiveAccount() {
        return (0, native_auth_js_1.deleteActiveAccount)({ client: this.options.client });
    }
    async socialLogin(auth) {
        try {
            const { storedToken } = await (0, native_auth_js_1.socialLogin)(auth, this.options.client);
            const account = await this.getAccount();
            return {
                user: {
                    status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                    account,
                    authDetails: storedToken.authDetails,
                    walletAddress: account.address,
                },
            };
        }
        catch (error) {
            console.error(`Error while signing in with: ${auth}. ${error}`);
            if (error instanceof Error) {
                throw new Error(`Error signing in with ${auth}: ${error.message}`);
            }
            throw new Error(`An unknown error occurred signing in with ${auth}`);
        }
    }
    async siweLogin(options) {
        try {
            const { storedToken } = await (0, native_auth_js_1.siweLogin)(this.options.client, options.wallet, options.chain);
            const account = await this.getAccount();
            return {
                user: {
                    status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                    account,
                    authDetails: storedToken.authDetails,
                    walletAddress: account.address,
                },
            };
        }
        catch (error) {
            console.error(`Error while signing in with: ${options.wallet.id}. ${error}`);
            if (error instanceof Error) {
                throw new Error(`Error signing in with ${options.wallet.id}: ${error.message}`);
            }
            throw new Error(`An unknown error occurred signing in with ${options.wallet.id}`);
        }
    }
    async customJwt(authOptions) {
        try {
            const { storedToken } = await (0, native_auth_js_1.customJwt)(authOptions, this.options.client);
            const account = await this.getAccount();
            return {
                user: {
                    status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                    account,
                    authDetails: storedToken.authDetails,
                    walletAddress: account.address,
                },
            };
        }
        catch (error) {
            console.error(`Error while verifying auth: ${error}`);
            throw error;
        }
    }
    async authEndpoint(authOptions) {
        try {
            const { storedToken } = await (0, native_auth_js_1.authEndpoint)(authOptions, this.options.client);
            const account = await this.getAccount();
            return {
                user: {
                    status: types_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                    account,
                    authDetails: storedToken.authDetails,
                    walletAddress: account.address,
                },
            };
        }
        catch (error) {
            console.error(`Error while verifying auth_endpoint auth: ${error}`);
            throw error;
        }
    }
    logout() {
        return (0, logout_js_1.logoutUser)(this.options.client.clientId);
    }
}
exports.InAppNativeConnector = InAppNativeConnector;
function assertUnreachable(x) {
    throw new Error(`Invalid param: ${x}`);
}
//# sourceMappingURL=native-connector.js.map