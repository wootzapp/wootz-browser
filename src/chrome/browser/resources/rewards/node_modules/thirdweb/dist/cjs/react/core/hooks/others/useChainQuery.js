"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useChainName = useChainName;
exports.useChainIconUrl = useChainIconUrl;
exports.useChainFaucets = useChainFaucets;
exports.useChainSymbol = useChainSymbol;
exports.useChainExplorers = useChainExplorers;
exports.useChainMetadata = useChainMetadata;
exports.useChainsQuery = useChainsQuery;
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const utils_js_1 = require("../../../../chains/utils.js");
const p_limit_js_1 = require("../../../../utils/promise/p-limit.js");
function useChainName(chain) {
    // only if we have a chain and no chain name!
    const isEnabled = !!chain && !chain.name;
    const chainQuery = (0, react_query_1.useQuery)({
        queryKey: ["chain", chain?.id],
        enabled: isEnabled,
        retry: false,
        // 1 hour
        staleTime: 60 * 60 * 1000,
        queryFn: async () => {
            if (!chain) {
                throw new Error("chain is required");
            }
            return (0, utils_js_1.convertApiChainToChain)(await (0, utils_js_1.getChainMetadata)(chain));
        },
    });
    return {
        name: chain?.name ?? chainQuery.data?.name,
        isLoading: isEnabled && chainQuery.isLoading,
    };
}
function useChainIconUrl(chain) {
    // only if we have a chain and no chain icon url!
    const isEnabled = !!chain && !chain.icon?.url;
    const chainQuery = (0, react_query_1.useQuery)({
        queryKey: ["chain", chain?.id],
        // only if we have a chain and no chain icon url!
        enabled: isEnabled,
        retry: false,
        // 1 hour
        staleTime: 60 * 60 * 1000,
        queryFn: async () => {
            if (!chain) {
                throw new Error("chain is required");
            }
            return (0, utils_js_1.convertApiChainToChain)(await (0, utils_js_1.getChainMetadata)(chain));
        },
    });
    return {
        url: chain?.icon?.url ?? chainQuery.data?.icon?.url,
        isLoading: isEnabled && chainQuery.isLoading,
    };
}
function useChainFaucets(chain) {
    // only if we have a chain and it might be a testnet and no faucets and its not localhost
    const isEnabled = !!chain &&
        "testnet" in chain &&
        !chain.faucets?.length &&
        chain.id !== 1337;
    const chainQuery = (0, react_query_1.useQuery)({
        queryKey: ["chain", chain?.id],
        enabled: isEnabled,
        retry: false,
        // 1 hour
        staleTime: 60 * 60 * 1000,
        queryFn: async () => {
            if (!chain) {
                throw new Error("chain is required");
            }
            return (0, utils_js_1.convertApiChainToChain)(await (0, utils_js_1.getChainMetadata)(chain));
        },
    });
    return {
        faucets: chain?.faucets ?? chainQuery.data?.faucets ?? [],
        isLoading: isEnabled && chainQuery.isLoading,
    };
}
function useChainSymbol(chain) {
    // only if we have a chain and no chain icon url!
    const isEnabled = !!chain && !chain.nativeCurrency?.symbol;
    const chainQuery = (0, react_query_1.useQuery)({
        queryKey: ["chain", chain?.id],
        // only if we have a chain and no chain icon url!
        enabled: isEnabled,
        retry: false,
        // 1 hour
        staleTime: 60 * 60 * 1000,
        queryFn: async () => {
            if (!chain) {
                throw new Error("chain is required");
            }
            return (0, utils_js_1.convertApiChainToChain)(await (0, utils_js_1.getChainMetadata)(chain));
        },
    });
    return {
        symbol: chain?.nativeCurrency?.symbol ?? chainQuery.data?.nativeCurrency?.symbol,
        isLoading: isEnabled && chainQuery.isLoading,
    };
}
function useChainExplorers(chain) {
    // only if we have a chain and it might be a testnet and no faucets and its not localhost
    const isEnabled = !!chain && !chain.blockExplorers?.length;
    const chainQuery = (0, react_query_1.useQuery)({
        queryKey: ["chain", chain?.id],
        enabled: isEnabled,
        retry: false,
        // 1 hour
        staleTime: 60 * 60 * 1000,
        queryFn: async () => {
            if (!chain) {
                throw new Error("chain is required");
            }
            return (0, utils_js_1.convertApiChainToChain)(await (0, utils_js_1.getChainMetadata)(chain));
        },
    });
    return {
        explorers: chain?.blockExplorers ?? chainQuery.data?.blockExplorers ?? [],
        isLoading: isEnabled && chainQuery.isLoading,
    };
}
function getQueryOptions(chain) {
    return {
        queryKey: ["chain", chain],
        enabled: !!chain,
        staleTime: 1000 * 60 * 60, // 1 hour
    };
}
/**
 * @description Retrieves metadata for a chain such as name, icon, available faucets, block explorers, etc.
 *
 * @param chain - Chain to retrieve metadata for, see [defineChain](https://portal.thirdweb.com/references/typescript/v5/defineChain) for how to create a chain from a chain ID.
 * @returns A React Query result containing the chain metadata, @see {@link ChainMetadata}.
 *
 * @example
 * ```jsx
 * import { useChainMetadata } from "thirdweb/react";
 *
 * const { data: chainMetadata } = useChainMetadata(defineChain(11155111));
 *
 * console.log("Name:", chainMetadata.name); // Sepolia
 * console.log("Faucets:", chainMetadata.faucets); // ["https://thirdweb.com/sepolia/faucet"]
 * console.log("Explorers:", chainMetadata.explorers); // ["https://sepolia.etherscan.io/"]
 * ```
 *
 * @chain
 */
function useChainMetadata(chain) {
    return (0, react_query_1.useQuery)({
        ...getQueryOptions(chain),
        queryFn: async () => {
            if (!chain) {
                throw new Error("chainId is required");
            }
            return (0, utils_js_1.getChainMetadata)(chain);
        },
    });
}
/**
 * @param chains - array of `Chains`
 * @param maxConcurrency - maximum number of concurrent requests to make
 * @internal
 */
function useChainsQuery(chains, maxConcurrency) {
    const queryList = (0, react_1.useMemo)(() => {
        const limit = (0, p_limit_js_1.pLimit)(maxConcurrency);
        return chains.map((chain) => {
            return {
                ...getQueryOptions(chain),
                queryFn: () => limit(() => (0, utils_js_1.getChainMetadata)(chain)),
            };
        });
    }, [chains, maxConcurrency]);
    return (0, react_query_1.useQueries)({
        queries: queryList,
    });
}
//# sourceMappingURL=useChainQuery.js.map