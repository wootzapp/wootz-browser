"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mintWithSignature = mintWithSignature;
exports.generateMintSignature = generateMintSignature;
const addresses_js_1 = require("../../../constants/addresses.js");
const address_js_1 = require("../../../utils/address.js");
const date_js_1 = require("../../../utils/date.js");
const ipfs_js_1 = require("../../../utils/ipfs.js");
const random_js_1 = require("../../../utils/random.js");
const startTokenId_js_1 = require("../../erc721/__generated__/IERC721A/read/startTokenId.js");
const totalMinted_js_1 = require("../__generated__/ERC721Core/read/totalMinted.js");
const mintWithSignature_js_1 = require("../__generated__/ERC721Core/write/mintWithSignature.js");
const encodeBytesBeforeMintWithSignatureERC721_js_1 = require("../__generated__/MintableERC721/encode/encodeBytesBeforeMintWithSignatureERC721.js");
/**
 * Mints ERC721 tokens to a specified address with a signature via a MintableERC721 module.
 * @param options The options for minting tokens.
 * @returns A transaction to mint tokens.
 * @example
 * ```typescript
 * import { MintableERC721 } from "thirdweb/modules";
 *
 * // generate the payload and signature, this is typically done on the server
 * // requires to be generated with a wallet that has the MINTER_ROLE
 * const { payload, signature } = await MintableERC721.generateMintSignature({
 *   account,
 *   contract,
 *   nfts: [{
 *    name: "My NFT",
 *    description: "My NFT",
 *    image: "https://example.com/image.png",
 *   }],
 *   mintRequest: {
 *     recipient: "0x...",
 *   },
 * });
 *
 * // prepare the transaction, this is typically done on the client
 * // can be executed by any wallet
 * const transaction = MintableERC721.mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 *
 * // Send the transaction
 * await sendTransaction({ transaction, account });
 * ```
 * @modules MintableERC721
 */
function mintWithSignature(options) {
    return (0, mintWithSignature_js_1.mintWithSignature)({
        contract: options.contract,
        asyncParams: async () => {
            const { payload, signature } = options;
            return {
                to: payload.to,
                amount: payload.amount,
                baseURI: payload.baseURI,
                data: payload.data,
                signature,
            };
        },
    });
}
/**
 * Generates a payload and signature for minting ERC721 tokens via a MintableERC721 module.
 * @param options The options for generating the payload and signature.
 * @returns The payload and signature.
 * @example
 * ```typescript
 * import { MintableERC20 } from "thirdweb/modules";
 *
 * // generate the payload and signature, this is typically done on the server
 * // requires to be generated with a wallet that has the MINTER_ROLE
 * const { payload, signature } = await MintableERC721.generateMintSignature({
 *   account,
 *   contract,
 *   nfts: [{
 *    name: "My NFT",
 *    description: "My NFT",
 *    image: "https://example.com/image.png",
 *   }],
 *   mintRequest: {
 *     recipient: "0x...",
 *   },
 * });
 *
 * // prepare the transaction, this is typically done on the client
 * // can be executed by any wallet
 * const transaction = MintableERC20.mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 *
 * // Send the transaction
 * await sendTransaction({ transaction, account });
 * ```
 * @modules MintableERC721
 */
async function generateMintSignature(options) {
    const { mintRequest, account, contract } = options;
    const currency = (0, address_js_1.getAddress)(mintRequest.currency || addresses_js_1.NATIVE_TOKEN_ADDRESS);
    const quantity = BigInt(options.nfts.length);
    const pricePerUnit = options.mintRequest.pricePerUnit || 0n;
    const uid = options.mintRequest.uid || (0, random_js_1.randomBytesHex)();
    const startTime = mintRequest.validityStartTimestamp || new Date(0);
    const endTime = mintRequest.validityEndTimestamp || (0, date_js_1.tenYearsFromNow)();
    const start = await (0, startTokenId_js_1.startTokenId)({ contract: options.contract });
    const minted = await (0, totalMinted_js_1.totalMinted)({ contract: options.contract });
    const nextIdToMint = start + minted;
    const batchOfUris = await (0, ipfs_js_1.uploadOrExtractURIs)(options.nfts, options.contract.client, Number(nextIdToMint));
    const baseURI = (0, ipfs_js_1.getBaseUriFromBatch)(batchOfUris);
    const mintParams = {
        pricePerUnit,
        uid,
        currency,
        startTimestamp: Number((0, date_js_1.dateToSeconds)(startTime)),
        endTimestamp: Number((0, date_js_1.dateToSeconds)(endTime)),
    };
    const payload = {
        to: (0, address_js_1.getAddress)(mintRequest.recipient),
        amount: quantity,
        baseURI: baseURI,
        data: (0, encodeBytesBeforeMintWithSignatureERC721_js_1.encodeBytesBeforeMintWithSignatureERC721Params)({
            params: mintParams,
        }),
    };
    const signature = await account.signTypedData({
        domain: {
            name: "ERC721Core",
            version: "1",
            chainId: contract.chain.id,
            verifyingContract: contract.address,
        },
        types: { MintRequestERC721: MintRequestERC721 },
        primaryType: "MintRequestERC721",
        message: payload,
    });
    return { payload, signature };
}
const MintRequestERC721 = [
    { type: "address", name: "to" },
    { type: "uint256", name: "amount" },
    { type: "string", name: "baseURI" },
    { type: "bytes", name: "data" },
];
//# sourceMappingURL=mintWithSignature.js.map