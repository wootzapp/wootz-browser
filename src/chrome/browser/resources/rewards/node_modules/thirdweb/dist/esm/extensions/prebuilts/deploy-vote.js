import { getContract } from "../../contract/contract.js";
import { deployViaAutoFactory } from "../../contract/deployment/deploy-via-autofactory.js";
import { getOrDeployInfraForPublishedContract } from "../../contract/deployment/utils/bootstrap.js";
import { decimals } from "../erc20/read/decimals.js";
/**
 * Deploys a thirdweb [`VoteERC20 contract`](https://thirdweb.com/thirdweb.eth/VoteERC20)
 * On chains where the thirdweb infrastructure contracts are not deployed, this function will deploy them as well.
 * @param options - The deployment options.
 * @returns The deployed contract address.
 * @extension DEPLOY
 *
 * @example
 * ```ts
 * import { deployVoteContract } from "thirdweb/deploys";
 * const contractAddress = await deployVoteContract({
 *  chain,
 *  client,
 *  account,
 *  params: {
 *    tokenAddress: "0x...",
 *    // user needs 0.5 <token> to create proposal
 *    initialProposalThreshold: "0.5",
 *    // vote expires 10 blocks later
 *    initialVotingPeriod: 10,
 *    // Requires 51% of users who voted, voted "For", for this proposal to pass
 *    minVoteQuorumRequiredPercent: 51,
 *  }
 * });
 * ```
 */
export async function deployVoteContract(options) {
    const { chain, client, account, params } = options;
    const { cloneFactoryContract, implementationContract } = await getOrDeployInfraForPublishedContract({
        chain,
        client,
        account,
        contractId: "VoteERC20",
    });
    const initializeTransaction = await getInitializeTransaction({
        client,
        implementationContract,
        params,
        accountAddress: account.address,
        chain,
    });
    return deployViaAutoFactory({
        client,
        chain,
        account,
        cloneFactoryContract,
        initializeTransaction,
    });
}
async function getInitializeTransaction(options) {
    const { client, implementationContract, params, chain } = options;
    const { name, tokenAddress, initialProposalThreshold, minVoteQuorumRequiredPercent, initialVotingDelay, initialVotingPeriod, description, symbol, image, external_link, social_urls, } = params;
    const tokenErc20Contract = getContract({
        address: tokenAddress,
        client,
        chain,
    });
    /**
     * A good side effect for checking for token decimals (instead of just taking in value in wei)
     * is that it validates the token address that user entered. In case they enter an invalid ERC20 contract address,
     * the extension will throw.
     */
    const _decimals = await decimals({ contract: tokenErc20Contract });
    if (!_decimals) {
        throw new Error(`Could not fetch decimals for contract: ${tokenAddress}`);
    }
    const [{ toUnits }, { upload }, { initialize }] = await Promise.all([
        import("../../utils/units.js"),
        import("../../storage/upload.js"),
        import("./__generated__/VoteERC20/write/initialize.js"),
    ]);
    const initialProposalThresholdInWei = toUnits(String(initialProposalThreshold), _decimals);
    const contractURI = params.contractURI ||
        (await upload({
            client,
            files: [
                {
                    name,
                    description,
                    symbol,
                    image,
                    external_link,
                    social_urls,
                },
            ],
        })) ||
        "";
    // Validate initialVoteQuorumFraction
    const _num = Number(minVoteQuorumRequiredPercent);
    if (Number.isNaN(_num)) {
        throw new Error(`${minVoteQuorumRequiredPercent} is not a valid minVoteQuorumRequiredPercent`);
    }
    if (_num < 0 || _num > 100) {
        throw new Error("minVoteQuorumRequiredPercent must be >= 0 and <= 100");
    }
    // Make sure if user is passing a float, it should only have 2 digit after the decimal point
    if (!Number.isInteger(_num)) {
        throw new Error(`${_num} is an invalid value. Only integer-like values accepted`);
    }
    const initialVoteQuorumFraction = BigInt(_num);
    return initialize({
        contract: implementationContract,
        name,
        token: tokenAddress,
        // Make sure the final value passed to `initialProposalThreshold` is in wei
        initialProposalThreshold: initialProposalThresholdInWei,
        initialVoteQuorumFraction,
        initialVotingDelay: BigInt(initialVotingDelay || 0),
        initialVotingPeriod: BigInt(initialVotingPeriod),
        contractURI,
        trustedForwarders: params.trustedForwarders || [],
    });
}
//# sourceMappingURL=deploy-vote.js.map