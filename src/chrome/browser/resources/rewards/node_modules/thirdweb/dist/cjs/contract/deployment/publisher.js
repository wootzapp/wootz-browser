"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CONTRACT_PUBLISHER_ADDRESS = void 0;
exports.fetchPublishedContractMetadata = fetchPublishedContractMetadata;
exports.fetchDeployBytecodeFromPublishedContractMetadata = fetchDeployBytecodeFromPublishedContractMetadata;
exports.fetchPublishedContract = fetchPublishedContract;
const polygon_js_1 = require("../../chains/chain-definitions/polygon.js");
const download_js_1 = require("../../storage/download.js");
const read_contract_js_1 = require("../../transaction/read-contract.js");
const deploy_metadata_js_1 = require("../../utils/any-evm/deploy-metadata.js");
const extractIPFS_js_1 = require("../../utils/bytecode/extractIPFS.js");
const resolveImplementation_js_1 = require("../../utils/bytecode/resolveImplementation.js");
const withCache_js_1 = require("../../utils/promise/withCache.js");
const contract_js_1 = require("../contract.js");
exports.CONTRACT_PUBLISHER_ADDRESS = "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808"; // Polygon only
const THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
/**
 * @internal
 */
async function fetchPublishedContractMetadata(options) {
    const cacheKey = `${options.contractId}-${options.publisher}-${options.version}`;
    return (0, withCache_js_1.withCache)(async () => {
        const publishedContract = await fetchPublishedContract({
            client: options.client,
            publisherAddress: options.publisher || THIRDWEB_DEPLOYER,
            contractId: options.contractId,
            version: options.version,
        });
        if (!publishedContract.publishMetadataUri) {
            throw new Error(`No published metadata URI found for ${options.contractId}`);
        }
        const data = await (0, deploy_metadata_js_1.fetchDeployMetadata)({
            client: options.client,
            uri: publishedContract.publishMetadataUri,
        });
        return data;
    }, { cacheKey, cacheTime: 1000 * 60 * 60 });
}
// TODO: clean this up
/**
 *
 * @param contract
 * @example
 * @internal
 */
async function fetchDeployBytecodeFromPublishedContractMetadata(contract) {
    const { bytecode } = await (0, resolveImplementation_js_1.resolveImplementation)(contract);
    const compilerMetaUri = (0, extractIPFS_js_1.extractIPFSUri)(bytecode);
    // early return if no compiler metadata
    if (!compilerMetaUri) {
        return undefined;
    }
    const contractPublisher = (0, contract_js_1.getContract)({
        client: contract.client,
        chain: polygon_js_1.polygon,
        address: exports.CONTRACT_PUBLISHER_ADDRESS,
    });
    const publishedMetadataUri = await (0, read_contract_js_1.readContract)({
        contract: contractPublisher,
        method: "function getPublishedUriFromCompilerUri(string) returns (string[])",
        params: [compilerMetaUri],
    });
    if (publishedMetadataUri.length === 0) {
        throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);
    }
    const pubmeta = await Promise.all(publishedMetadataUri
        .filter((uri) => uri.length > 0)
        .map((uri) => (0, download_js_1.download)({ uri, client: contract.client })
        .then((res) => res.text())
        .then(JSON.parse)));
    return pubmeta.length > 0
        ? await (await (0, download_js_1.download)({ uri: pubmeta[0].bytecodeUri, client: contract.client })).text()
        : undefined;
}
const GET_PUBLISHED_CONTRACT_ABI = {
    inputs: [
        {
            internalType: "address",
            name: "_publisher",
            type: "address",
        },
        {
            internalType: "string",
            name: "_contractId",
            type: "string",
        },
    ],
    name: "getPublishedContract",
    outputs: [
        {
            components: [
                {
                    internalType: "string",
                    name: "contractId",
                    type: "string",
                },
                {
                    internalType: "uint256",
                    name: "publishTimestamp",
                    type: "uint256",
                },
                {
                    internalType: "string",
                    name: "publishMetadataUri",
                    type: "string",
                },
                {
                    internalType: "bytes32",
                    name: "bytecodeHash",
                    type: "bytes32",
                },
                {
                    internalType: "address",
                    name: "implementation",
                    type: "address",
                },
            ],
            internalType: "struct IContractPublisher.CustomContractInstance",
            name: "published",
            type: "tuple",
        },
    ],
    stateMutability: "view",
    type: "function",
};
const GET_PUBLISHED_CONTRACT_VERSIONS_ABI = {
    inputs: [
        {
            internalType: "address",
            name: "_publisher",
            type: "address",
        },
        {
            internalType: "string",
            name: "_contractId",
            type: "string",
        },
    ],
    name: "getPublishedContractVersions",
    outputs: [
        {
            components: [
                {
                    internalType: "string",
                    name: "contractId",
                    type: "string",
                },
                {
                    internalType: "uint256",
                    name: "publishTimestamp",
                    type: "uint256",
                },
                {
                    internalType: "string",
                    name: "publishMetadataUri",
                    type: "string",
                },
                {
                    internalType: "bytes32",
                    name: "bytecodeHash",
                    type: "bytes32",
                },
                {
                    internalType: "address",
                    name: "implementation",
                    type: "address",
                },
            ],
            internalType: "struct IContractPublisher.CustomContractInstance[]",
            name: "published",
            type: "tuple[]",
        },
    ],
    stateMutability: "view",
    type: "function",
};
/**
 * Fetches the published contract based on the provided options.
 * @param options - The options for fetching the published contract.
 * @returns The published contract.
 * @throws Error if the contract version or published contract is not found.
 * @example
 * ```ts
 * const publishedContract = await fetchPublishedContract({
 *  publisherAddress: "0x1234",
 *  contractName: "MyContract",
 *  version: "1.0.0",
 *  client: client,
 * });
 * ```
 * @contract
 */
async function fetchPublishedContract(options) {
    const contractPublisher = (0, contract_js_1.getContract)({
        client: options.client,
        chain: polygon_js_1.polygon,
        address: exports.CONTRACT_PUBLISHER_ADDRESS,
    });
    if (!options.version || options.version === "latest") {
        return await (0, read_contract_js_1.readContract)({
            contract: contractPublisher,
            method: GET_PUBLISHED_CONTRACT_ABI,
            params: [options.publisherAddress, options.contractId],
        });
    }
    const allVersions = await (0, read_contract_js_1.readContract)({
        contract: contractPublisher,
        method: GET_PUBLISHED_CONTRACT_VERSIONS_ABI,
        params: [options.publisherAddress, options.contractId],
    });
    const versionsMetadata = (await Promise.all(allVersions.map((version) => {
        return (0, download_js_1.download)({
            uri: version.publishMetadataUri,
            client: options.client,
        }).then((res) => res.json());
    }))).map((item, index) => {
        return {
            name: allVersions[index]?.contractId,
            publishedTimestamp: allVersions[index]?.publishTimestamp,
            publishedMetadata: item,
        };
    });
    // find the version that matches the version string
    const versionMatch = versionsMetadata.find((metadata) => 
    // Will probably only need metadata.publishedMetadata.version unless its an outdated contract
    metadata.publishedMetadata.extendedMetadata?.version ===
        options.version ||
        metadata.publishedMetadata.version === options.version);
    if (!versionMatch) {
        throw Error("Contract version not found");
    }
    // match the version back to the contract based on the published timestamp
    const publishedContract = allVersions.find((c) => c.publishTimestamp === versionMatch.publishedTimestamp);
    if (!publishedContract) {
        throw Error(`No published contract found for ${options.contractId} at version by '${options.publisherAddress}'`);
    }
    return publishedContract;
}
//# sourceMappingURL=publisher.js.map