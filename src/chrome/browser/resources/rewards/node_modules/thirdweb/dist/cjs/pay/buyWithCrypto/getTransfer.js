"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBuyWithCryptoTransfer = getBuyWithCryptoTransfer;
const utils_js_1 = require("../../chains/utils.js");
const contract_js_1 = require("../../contract/contract.js");
const approve_js_1 = require("../../extensions/erc20/write/approve.js");
const fetch_js_1 = require("../../utils/fetch.js");
const definitions_js_1 = require("../utils/definitions.js");
/**
 * Get a quote of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) to facilitate a token transfer transaction.
 * Using this instead of a native transfer allows you to receive status and webhooks about successful or failed payments.
 *
 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
 * @param params - object of type [`GetBuyWithCryptoTransferParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoTransferParams)
 * @returns Object of type [`BuyWithCryptoTransfer`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransfer) which contains the information about the transfer
 * @example
 *
 * ```ts
 * import { getBuyWithCryptoTransfer } from "thirdweb/pay";
 *
 * const transfer = await getBuyWithCryptoTransfer({
 *  client,
 *  fromAddress: "0x...", // wallet address
 *  toAddress: "0x...", // recipient address - likely to be your wallet
 *  chainId: 10, // chain id of the token
 *  tokenAddress: "0x...", // address of the token
 *  amount: "10", // amount of token to transfer
 *  purchaseData: {  // any metadata for you to attribute this purchase
 *    "customerId": "yourId"
 *  }
 * });
 * ```
 * @buyCrypto
 */
async function getBuyWithCryptoTransfer(params) {
    try {
        const clientFetch = (0, fetch_js_1.getClientFetch)(params.client);
        const response = await clientFetch((0, definitions_js_1.getPayBuyWithCryptoTransferEndpoint)(), {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                fromAddress: params.fromAddress,
                toAddress: params.toAddress,
                chainId: params.chainId,
                tokenAddress: params.tokenAddress,
                amount: params.amount,
                purchaseData: params.purchaseData,
            }),
        });
        if (!response.ok) {
            const errorObj = await response.json();
            if (errorObj && "error" in errorObj) {
                throw errorObj;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = (await response.json()).result;
        const transfer = {
            transactionRequest: {
                chain: (0, utils_js_1.getCachedChain)(data.transactionRequest.chainId),
                client: params.client,
                data: data.transactionRequest.data,
                to: data.transactionRequest.to,
                value: BigInt(data.transactionRequest.value),
                gas: BigInt(data.transactionRequest.gasLimit),
            },
            approval: data.approval
                ? (0, approve_js_1.approve)({
                    contract: (0, contract_js_1.getContract)({
                        client: params.client,
                        address: data.approval.tokenAddress,
                        chain: (0, utils_js_1.getCachedChain)(data.approval.chainId),
                    }),
                    spender: data.approval.spenderAddress,
                    amountWei: BigInt(data.approval.amountWei),
                })
                : undefined,
            fromAddress: data.fromAddress,
            toAddress: data.toAddress,
            paymentToken: data.paymentToken,
            processingFee: data.processingFee,
            estimatedGasCostUSDCents: data.estimatedGasCostUSDCents,
            client: params.client,
        };
        return transfer;
    }
    catch (error) {
        console.error("Error getting buy with crypto transfer", error);
        throw error;
    }
}
//# sourceMappingURL=getTransfer.js.map