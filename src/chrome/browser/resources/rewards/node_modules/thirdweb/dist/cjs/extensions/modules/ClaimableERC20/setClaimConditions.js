"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setClaimCondition = setClaimCondition;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../constants/addresses.js");
const upload_js_1 = require("../../../storage/upload.js");
const address_js_1 = require("../../../utils/address.js");
const date_js_1 = require("../../../utils/date.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const process_override_list_js_1 = require("../../../utils/extensions/drops/process-override-list.js");
const keccak256_js_1 = require("../../../utils/hashing/keccak256.js");
const setClaimCondition_js_1 = require("../__generated__/ClaimableERC20/write/setClaimCondition.js");
/**
 * Sets the claim conditions for a given token ID.
 * @param options - The options for setting the claim conditions.
 * @returns A transaction to set the claim conditions.
 * @modules ClaimableERC20
 * @example
 * ```ts
 * import { ClaimableERC20 } from "thirdweb/modules";
 *
 * const transaction = ClaimableERC20.setClaimCondition({
 *   contract: contract,
 *   pricePerToken: "1", // in ETH
 *   maxClaimableSupply: "1000000",
 *   maxClaimablePerWallet: "1",
 * });
 *
 * await sendTransaction({ transaction, account });
 * ```
 */
function setClaimCondition(options) {
    return (0, setClaimCondition_js_1.setClaimCondition)({
        contract: options.contract,
        asyncParams: async () => {
            const { convertErc20Amount } = await Promise.resolve().then(() => require("../../../utils/extensions/convert-erc20-amount.js"));
            const startTime = options.startTime || new Date(0);
            const endTime = options.endTime || (0, date_js_1.tenYearsFromNow)();
            const [pricePerUnit, availableSupply, maxMintPerWallet] = await Promise.all([
                options.pricePerToken
                    ? convertErc20Amount({
                        chain: options.contract.chain,
                        client: options.contract.client,
                        erc20Address: options.currencyAddress || addresses_js_1.NATIVE_TOKEN_ADDRESS,
                        amount: options.pricePerToken.toString(),
                    })
                    : 0n,
                options.maxClaimableSupply
                    ? await convertErc20Amount({
                        chain: options.contract.chain,
                        client: options.contract.client,
                        erc20Address: options.contract.address,
                        amount: options.maxClaimableSupply.toString(),
                    })
                    : viem_1.maxUint256,
                options.maxClaimablePerWallet
                    ? await convertErc20Amount({
                        chain: options.contract.chain,
                        client: options.contract.client,
                        erc20Address: options.contract.address,
                        amount: options.maxClaimablePerWallet.toString(),
                    })
                    : viem_1.maxUint256,
            ]);
            // allowlist + metadata
            let metadata = "";
            let merkleRoot = (0, hex_js_1.toHex)("", { size: 32 });
            if (options.allowList) {
                const { shardedMerkleInfo, uri } = await (0, process_override_list_js_1.processOverrideList)({
                    overrides: options.allowList.map((entry) => ({
                        address: entry,
                    })),
                    client: options.contract.client,
                    chain: options.contract.chain,
                    tokenDecimals: 18, // unused in this case, we only care
                    async hashEntry(options) {
                        return (0, keccak256_js_1.keccak256)((0, viem_1.encodePacked)(["address"], [(0, address_js_1.getAddress)(options.entry.address)]));
                    },
                });
                merkleRoot = shardedMerkleInfo.merkleRoot;
                metadata = await (0, upload_js_1.upload)({
                    client: options.contract.client,
                    files: [
                        {
                            merkleRoot: shardedMerkleInfo.merkleRoot,
                            merkleTreeUri: uri,
                        },
                    ],
                });
            }
            return {
                claimCondition: {
                    startTimestamp: Number((0, date_js_1.dateToSeconds)(startTime)),
                    endTimestamp: Number((0, date_js_1.dateToSeconds)(endTime)),
                    pricePerUnit,
                    currency: (0, address_js_1.getAddress)(options.currencyAddress || addresses_js_1.NATIVE_TOKEN_ADDRESS),
                    availableSupply,
                    maxMintPerWallet,
                    allowlistMerkleRoot: merkleRoot,
                    auxData: metadata, // stores the merkle root and merkle tree uri in IPFS
                },
            };
        },
    });
}
//# sourceMappingURL=setClaimConditions.js.map