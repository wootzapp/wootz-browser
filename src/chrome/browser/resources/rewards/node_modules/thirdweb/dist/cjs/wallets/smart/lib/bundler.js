"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleUserOp = bundleUserOp;
exports.estimateUserOpGas = estimateUserOpGas;
exports.getUserOpGasFees = getUserOpGasFees;
exports.getUserOpReceipt = getUserOpReceipt;
exports.getUserOpReceiptRaw = getUserOpReceiptRaw;
exports.getZkPaymasterData = getZkPaymasterData;
exports.broadcastZkTransaction = broadcastZkTransaction;
const viem_1 = require("viem");
const parse_logs_js_1 = require("../../../event/actions/parse-logs.js");
const UserOperationRevertReason_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js");
const PostOpRevertReason_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const json_js_1 = require("../../../utils/json.js");
const types_js_1 = require("../types.js");
const constants_js_1 = require("./constants.js");
const utils_js_1 = require("./utils.js");
/**
 * Bundle a user operation.
 * @param args - The options for bundling a user operation.
 * @returns The bundle hash of the user operation.
 * @example
 * ```ts
 * import { bundleUserOp } from "thirdweb/wallets/smart";
 *
 * const userOpHash = await bundleUserOp({
 *  userOp,
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function bundleUserOp(args) {
    return sendBundlerRequest({
        ...args,
        operation: "eth_sendUserOperation",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
        ],
    });
}
/**
 * Estimate the gas cost of a user operation.
 * @param args - The options for estimating the gas cost of a user operation.
 * @returns The estimated gas cost of the user operation.
 * @example
 * ```ts
 * import { estimateUserOpGas } from "thirdweb/wallets/smart";
 *
 * const gasCost = await estimateUserOpGas({
 *  userOp,
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function estimateUserOpGas(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "eth_estimateUserOperationGas",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
        ],
    });
    // add gas buffer for managed account factory delegate calls
    return {
        preVerificationGas: (0, hex_js_1.hexToBigInt)(res.preVerificationGas),
        verificationGas: (0, hex_js_1.hexToBigInt)(res.verificationGas),
        verificationGasLimit: (0, hex_js_1.hexToBigInt)(res.verificationGasLimit),
        callGasLimit: (0, hex_js_1.hexToBigInt)(res.callGasLimit) + constants_js_1.MANAGED_ACCOUNT_GAS_BUFFER,
        paymasterVerificationGasLimit: res.paymasterVerificationGasLimit !== undefined
            ? (0, hex_js_1.hexToBigInt)(res.paymasterVerificationGasLimit)
            : undefined,
        paymasterPostOpGasLimit: res.paymasterPostOpGasLimit !== undefined
            ? (0, hex_js_1.hexToBigInt)(res.paymasterPostOpGasLimit)
            : undefined,
    };
}
/**
 * Get the gas fees of a user operation.
 * @param args - The options for getting the gas price of a user operation.
 * @returns The gas price of the user operation.
 * @example
 * ```ts
 * import { getUserOpGasPrice } from "thirdweb/wallets/smart";
 *
 * const fees = await getUserOpGasPrice({
 *  options,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpGasFees(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "thirdweb_getUserOperationGasPrice",
        params: [],
    });
    return {
        maxPriorityFeePerGas: (0, hex_js_1.hexToBigInt)(res.maxPriorityFeePerGas),
        maxFeePerGas: (0, hex_js_1.hexToBigInt)(res.maxFeePerGas),
    };
}
/**
 * Get the receipt of a user operation.
 * @param args - The options for getting the receipt of a user operation.
 * @returns The receipt of the user operation.
 * @example
 * ```ts
 * import { getUserOpReceipt } from "thirdweb/wallets/smart";
 *
 * const receipt = await getUserOpReceipt({
 *  client,
 *  chain,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpReceipt(args) {
    const res = await getUserOpReceiptRaw(args);
    if (!res) {
        return undefined;
    }
    if (res.success === false) {
        // parse revert reason
        const logs = (0, parse_logs_js_1.parseEventLogs)({
            events: [(0, UserOperationRevertReason_js_1.userOperationRevertReasonEvent)(), (0, PostOpRevertReason_js_1.postOpRevertReasonEvent)()],
            logs: res.logs,
        });
        const revertReason = logs[0]?.args?.revertReason;
        if (!revertReason) {
            throw new Error(`UserOp failed at txHash: ${res.receipt.transactionHash}`);
        }
        const revertMsg = (0, viem_1.decodeErrorResult)({
            data: revertReason,
        });
        throw new Error(`UserOp failed with reason: '${revertMsg.args.join(",")}' at txHash: ${res.receipt.transactionHash}`);
    }
    return res.receipt;
}
/**
 * Get the receipt of a user operation.
 * @param args - The options for getting the receipt of a user operation.
 * @returns The raw receipt of the user operation.
 * @example
 * ```ts
 * import { getUserOpReceiptRaw } from "thirdweb/wallets/smart";
 *
 * const receipt = await getUserOpReceiptRaw({
 *  client,
 *  chain,
 *  userOpHash,
 * });
 * ```
 * @walletUtils
 */
async function getUserOpReceiptRaw(args) {
    const res = await sendBundlerRequest({
        options: args,
        operation: "eth_getUserOperationReceipt",
        params: [args.userOpHash],
    });
    if (!res) {
        return undefined;
    }
    return (0, types_js_1.formatUserOperationReceipt)(res);
}
/**
 * @internal
 */
async function getZkPaymasterData(args) {
    const res = await sendBundlerRequest({
        options: args.options,
        operation: "zk_paymasterData",
        params: [args.transaction],
    });
    return {
        paymaster: res.paymaster,
        paymasterInput: res.paymasterInput,
    };
}
async function broadcastZkTransaction(args) {
    const res = await sendBundlerRequest({
        options: args.options,
        operation: "zk_broadcastTransaction",
        params: [
            {
                ...args.transaction,
                signedTransaction: args.signedTransaction,
            },
        ],
    });
    return {
        transactionHash: res.transactionHash,
    };
}
async function sendBundlerRequest(args) {
    const { options, operation, params } = args;
    if (constants_js_1.DEBUG) {
        console.debug(`>>> sending ${operation} with payload:`, params);
    }
    const entryPointVersion = (0, constants_js_1.getEntryPointVersion)(options.entrypointAddress || constants_js_1.ENTRYPOINT_ADDRESS_v0_6);
    const bundlerVersion = entryPointVersion === "v0.6" ? "v1" : "v2";
    const bundlerUrl = options.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(options.chain, bundlerVersion);
    const fetchWithHeaders = (0, fetch_js_1.getClientFetch)(options.client);
    const response = await fetchWithHeaders(bundlerUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: (0, json_js_1.stringify)({
            jsonrpc: "2.0",
            id: 1,
            method: operation,
            params,
        }),
    });
    const res = await response.json();
    if (!response.ok || res.error) {
        let error = res.error || response.statusText;
        if (typeof error === "object") {
            error = JSON.stringify(error);
        }
        const code = res.code || "UNKNOWN";
        throw new Error(`${operation} error: ${error}
Status: ${response.status}
Code: ${code}`);
    }
    if (constants_js_1.DEBUG) {
        console.debug(`<<< ${operation} result:`, res);
    }
    return res.result;
}
//# sourceMappingURL=bundler.js.map