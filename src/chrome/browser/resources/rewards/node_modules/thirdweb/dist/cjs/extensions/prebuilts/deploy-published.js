"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployPublishedContract = deployPublishedContract;
exports.deployContractfromDeployMetadata = deployContractfromDeployMetadata;
const contract_js_1 = require("../../contract/contract.js");
const publisher_js_1 = require("../../contract/deployment/publisher.js");
const bootstrap_js_1 = require("../../contract/deployment/utils/bootstrap.js");
const zkDeployContract_js_1 = require("../../contract/deployment/zksync/zkDeployContract.js");
const send_and_confirm_transaction_js_1 = require("../../transaction/actions/send-and-confirm-transaction.js");
const simulate_js_1 = require("../../transaction/actions/simulate.js");
const prepare_contract_call_js_1 = require("../../transaction/prepare-contract-call.js");
const resolve_method_js_1 = require("../../transaction/resolve-method.js");
const encodeAbiParameters_js_1 = require("../../utils/abi/encodeAbiParameters.js");
const normalizeFunctionParams_js_1 = require("../../utils/abi/normalizeFunctionParams.js");
const address_js_1 = require("../../utils/address.js");
const isZkSyncChain_js_1 = require("../../utils/any-evm/zksync/isZkSyncChain.js");
const get_required_transactions_js_1 = require("./get-required-transactions.js");
/**
 * Deploy an instance of a published contract on a given chain
 * @param options - the deploy options
 * @returns a promise that resolves to the deployed contract address
 * @example
 *
 * ## Deploying a published contract
 *
 * ```ts
 * import { deployPublishedContract } from "thirdweb/deploys";
 *
 * const address = await deployedPublishedContract({
 *   client,
 *   chain,
 *   account,
 *   contractId: "MyPublishedContract",
 *   contractParams: {
 *     param1: "value1",
 *     param2: 123,
 *   },
 *   publisher: "0x...", // optional, defaults to the thirdweb deployer
 * });
 * ```
 *
 *  ## Deploying a published contract deterministically
 *
 * ```ts
 * import { deployPublishedContract } from "thirdweb/deploys";
 *
 * const address = await deployedPublishedContract({
 *   client,
 *   chain,
 *   account,
 *   contractId: "MyPublishedContract",
 *   contractParams: {
 *     param1: "value1",
 *     param2: 123,
 *   },
 *   publisher: "0x...",
 *   salt: "your-salt", // this will deterministically deploy the contract at the same address on all chains
 * });
 * ```
 * @extension DEPLOY
 */
async function deployPublishedContract(options) {
    const { client, account, chain, contractId, contractParams, publisher, version, implementationConstructorParams, salt, } = options;
    const deployMetadata = await (0, publisher_js_1.fetchPublishedContractMetadata)({
        client,
        contractId: (0, isZkSyncChain_js_1.isZkSyncChain)(chain) ? `${contractId}_ZkSync` : contractId,
        publisher,
        version,
    });
    return deployContractfromDeployMetadata({
        account,
        chain,
        deployMetadata,
        client,
        initializeParams: contractParams,
        implementationConstructorParams,
        salt,
    });
}
/**
 * @internal
 */
async function deployContractfromDeployMetadata(options) {
    const { client, account, chain, initializeParams, deployMetadata, implementationConstructorParams, modules, salt, } = options;
    switch (deployMetadata?.deployType) {
        case "standard": {
            return directDeploy({
                account,
                client,
                chain,
                compilerMetadata: deployMetadata,
                contractParams: initializeParams,
                salt,
            });
        }
        case "autoFactory": {
            const [{ deployViaAutoFactory }, { getOrDeployInfraForPublishedContract },] = await Promise.all([
                Promise.resolve().then(() => require("../../contract/deployment/deploy-via-autofactory.js")),
                Promise.resolve().then(() => require("../../contract/deployment/utils/bootstrap.js")),
            ]);
            const { cloneFactoryContract, implementationContract } = await getOrDeployInfraForPublishedContract({
                chain,
                client,
                account,
                contractId: deployMetadata.name,
                constructorParams: implementationConstructorParams ||
                    (await (0, get_required_transactions_js_1.getAllDefaultConstructorParamsForImplementation)({
                        chain,
                        client,
                    })),
                publisher: deployMetadata.publisher,
            });
            const initializeTransaction = await getInitializeTransaction({
                client,
                chain,
                deployMetadata: deployMetadata,
                implementationContract,
                initializeParams,
                account,
                modules,
            });
            return deployViaAutoFactory({
                client,
                chain,
                account,
                cloneFactoryContract,
                initializeTransaction,
                salt,
            });
        }
        case "customFactory": {
            if (!deployMetadata?.factoryDeploymentData?.customFactoryInput) {
                throw new Error("No custom factory info found");
            }
            const factoryAddress = deployMetadata?.factoryDeploymentData?.customFactoryInput
                ?.customFactoryAddresses?.[chain.id];
            const factoryFunction = deployMetadata.factoryDeploymentData?.customFactoryInput
                ?.factoryFunction;
            if (!factoryAddress || !factoryFunction) {
                throw new Error(`No factory address found on chain ${chain.id}`);
            }
            const factory = (0, contract_js_1.getContract)({
                client,
                chain,
                address: factoryAddress,
            });
            const method = await (0, resolve_method_js_1.resolveMethod)(factoryFunction)(factory);
            const deployTx = (0, prepare_contract_call_js_1.prepareContractCall)({
                contract: factory,
                method,
                params: (0, normalizeFunctionParams_js_1.normalizeFunctionParams)(method, initializeParams),
            });
            // asumption here is that the factory address returns the deployed proxy address
            const address = await (0, simulate_js_1.simulateTransaction)({
                transaction: deployTx,
            });
            await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
                transaction: deployTx,
                account,
            });
            return address;
        }
        case undefined: {
            // Default to standard deployment if none was specified
            return directDeploy({
                account,
                client,
                chain,
                compilerMetadata: deployMetadata,
                contractParams: initializeParams,
                salt,
            });
        }
        default:
            // If a deployType was specified but we don't support it, throw an error
            throw new Error(`Unsupported deploy type: ${deployMetadata?.deployType}`);
    }
}
async function directDeploy(options) {
    const { account, client, chain, compilerMetadata, contractParams, salt } = options;
    if ((0, isZkSyncChain_js_1.isZkSyncChain)(chain)) {
        return (0, zkDeployContract_js_1.zkDeployContract)({
            account,
            client,
            chain,
            bytecode: compilerMetadata.bytecode,
            abi: compilerMetadata.abi,
            params: contractParams,
            salt,
        });
    }
    const { deployContract } = await Promise.resolve().then(() => require("../../contract/deployment/deploy-with-abi.js"));
    return deployContract({
        account,
        client,
        chain,
        bytecode: compilerMetadata.bytecode,
        abi: compilerMetadata.abi,
        constructorParams: contractParams,
        salt,
    });
}
async function getInitializeTransaction(options) {
    const { account, client, chain, deployMetadata: metadata, initializeParams = {}, implementationContract, modules = [], } = options;
    const initializeFunction = metadata.abi.find((i) => i.type === "function" &&
        i.name ===
            (metadata.factoryDeploymentData?.implementationInitializerFunction ||
                "initialize"));
    if (!initializeFunction) {
        throw new Error(`Could not find initialize function for ${metadata.name}`);
    }
    const hasModules = initializeFunction.inputs.find((i) => i.name === "modules" || i.name === "_modules") &&
        initializeFunction.inputs.find((i) => i.name === "moduleInstallData" || i.name === "_moduleInstallData");
    if (hasModules) {
        const moduleAddresses = [];
        const moduleInstallData = [];
        for (const module of modules) {
            // deploy the module if not already deployed
            const contract = await (0, bootstrap_js_1.getOrDeployInfraContractFromMetadata)({
                client,
                chain,
                account,
                contractMetadata: module.deployMetadata,
            });
            const installFunction = module.deployMetadata.abi.find((i) => i.type === "function" && i.name === "encodeBytesOnInstall");
            moduleAddresses.push((0, address_js_1.getAddress)(contract.address));
            moduleInstallData.push(installFunction
                ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(installFunction.inputs, (0, normalizeFunctionParams_js_1.normalizeFunctionParams)(installFunction, module.initializeParams))
                : "0x");
        }
        initializeParams.modules = moduleAddresses;
        initializeParams.moduleInstallData = moduleInstallData;
    }
    const initializeTransaction = (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: (0, contract_js_1.getContract)({
            client,
            chain,
            address: implementationContract.address,
        }),
        method: initializeFunction,
        params: (0, normalizeFunctionParams_js_1.normalizeFunctionParams)(initializeFunction, initializeParams),
    });
    return initializeTransaction;
}
//# sourceMappingURL=deploy-published.js.map