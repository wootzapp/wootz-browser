"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployPublishedContract = deployPublishedContract;
const contract_js_1 = require("../../contract/contract.js");
const publisher_js_1 = require("../../contract/deployment/publisher.js");
const zkDeployContract_js_1 = require("../../contract/deployment/zksync/zkDeployContract.js");
const send_and_confirm_transaction_js_1 = require("../../transaction/actions/send-and-confirm-transaction.js");
const simulate_js_1 = require("../../transaction/actions/simulate.js");
const prepare_contract_call_js_1 = require("../../transaction/prepare-contract-call.js");
const resolve_method_js_1 = require("../../transaction/resolve-method.js");
const isZkSyncChain_js_1 = require("../../utils/any-evm/zksync/isZkSyncChain.js");
/**
 * Deploy an instance of a published contract on a given chain
 * @param options - the deploy options
 * @returns a promise that resolves to the deployed contract address
 * @example
 * ```ts
 * import { deployPublishedContract } from "thirdweb/deploys";
 *
 * const address = await deployedPublishedContract({
 *   client,
 *   chain,
 *   account,
 *   contractId: "MyPublishedContract",
 *   contractParams: [...],
 *   publisher: "0x...",
 * });
 * ```
 * @extension DEPLOY
 */
async function deployPublishedContract(options) {
    const { client, account, chain, contractId, contractParams, publisher, version, implementationConstructorParams, } = options;
    const { compilerMetadata, extendedMetadata } = await (0, publisher_js_1.fetchPublishedContractMetadata)({
        client,
        contractId: (0, isZkSyncChain_js_1.isZkSyncChain)(chain) ? `${contractId}_ZkSync` : contractId,
        publisher,
        version,
    });
    switch (extendedMetadata?.deployType) {
        case "standard": {
            return directDeploy({
                account,
                client,
                chain,
                compilerMetadata,
                contractParams,
            });
        }
        case "autoFactory": {
            const [{ deployViaAutoFactory }, { getOrDeployInfraForPublishedContract },] = await Promise.all([
                Promise.resolve().then(() => require("../../contract/deployment/deploy-via-autofactory.js")),
                Promise.resolve().then(() => require("../../contract/deployment/utils/bootstrap.js")),
            ]);
            const { cloneFactoryContract, implementationContract } = await getOrDeployInfraForPublishedContract({
                chain,
                client,
                account,
                contractId,
                constructorParams: implementationConstructorParams || [],
                publisher,
            });
            const initializeFunction = compilerMetadata.abi.find((i) => i.type === "function" &&
                i.name ===
                    (extendedMetadata.factoryDeploymentData
                        ?.implementationInitializerFunction || "initialize"));
            if (!initializeFunction) {
                throw new Error(`Could not find initialize function for ${contractId}`);
            }
            const initializeTransaction = (0, prepare_contract_call_js_1.prepareContractCall)({
                contract: (0, contract_js_1.getContract)({
                    client,
                    chain,
                    address: implementationContract.address,
                }),
                method: initializeFunction,
                params: contractParams,
            });
            return deployViaAutoFactory({
                client,
                chain,
                account,
                cloneFactoryContract,
                initializeTransaction,
            });
        }
        case "customFactory": {
            if (!extendedMetadata?.factoryDeploymentData?.customFactoryInput) {
                throw new Error("No custom factory info found");
            }
            const factoryAddress = extendedMetadata?.factoryDeploymentData?.customFactoryInput
                ?.customFactoryAddresses?.[chain.id];
            const factoryFunction = extendedMetadata.factoryDeploymentData?.customFactoryInput
                ?.factoryFunction;
            if (!factoryAddress || !factoryFunction) {
                throw new Error(`No factory address found on chain ${chain.id}`);
            }
            const factory = (0, contract_js_1.getContract)({
                client,
                chain,
                address: factoryAddress,
            });
            const deployTx = (0, prepare_contract_call_js_1.prepareContractCall)({
                contract: factory,
                method: (0, resolve_method_js_1.resolveMethod)(factoryFunction),
                params: contractParams,
            });
            // asumption here is that the factory address returns the deployed proxy address
            const address = (0, simulate_js_1.simulateTransaction)({
                transaction: deployTx,
            });
            await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
                transaction: deployTx,
                account,
            });
            return address;
        }
        case undefined: {
            // Default to standard deployment if none was specified
            return directDeploy({
                account,
                client,
                chain,
                compilerMetadata,
                contractParams,
            });
        }
        default:
            // If a deployType was specified but we don't support it, throw an error
            throw new Error(`Unsupported deploy type: ${extendedMetadata?.deployType}`);
    }
}
async function directDeploy(options) {
    const { account, client, chain, compilerMetadata, contractParams } = options;
    if ((0, isZkSyncChain_js_1.isZkSyncChain)(chain)) {
        return (0, zkDeployContract_js_1.zkDeployContract)({
            account,
            client,
            chain,
            bytecode: compilerMetadata.bytecode,
            abi: compilerMetadata.abi,
            params: contractParams,
        });
    }
    const { deployContract } = await Promise.resolve().then(() => require("../../contract/deployment/deploy-with-abi.js"));
    return deployContract({
        account,
        client,
        chain,
        bytecode: compilerMetadata.bytecode,
        constructorAbi: compilerMetadata.abi.find((i) => i.type === "constructor") || [],
        constructorParams: contractParams,
    });
}
//# sourceMappingURL=deploy-published.js.map