"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loginWithOauth = exports.loginWithOauthRedirect = void 0;
const domains_js_1 = require("../../../../../utils/domains.js");
const getLoginPath_js_1 = require("../../../core/authentication/getLoginPath.js");
const constants_js_1 = require("./constants.js");
const closeWindow = ({ isWindowOpenedByFn, win, closeOpenedWindow, }) => {
    if (isWindowOpenedByFn) {
        win?.close();
    }
    else {
        if (win && closeOpenedWindow) {
            closeOpenedWindow(win);
        }
        else if (win) {
            win.close();
        }
    }
};
const loginWithOauthRedirect = (options) => {
    const loginUrl = (0, getLoginPath_js_1.getLoginUrl)({
        ...options,
        mode: options.mode || "redirect",
    });
    if (options.mode === "redirect") {
        window.location.href = loginUrl;
    }
    else {
        window.open(loginUrl);
    }
};
exports.loginWithOauthRedirect = loginWithOauthRedirect;
const loginWithOauth = async (options) => {
    let win = options.openedWindow;
    let isWindowOpenedByFn = false;
    if (!win) {
        win = window.open((0, getLoginPath_js_1.getLoginUrl)({ ...options, mode: "popup" }), `Login to ${options.authOption}`, constants_js_1.DEFAULT_POP_UP_SIZE);
        isWindowOpenedByFn = true;
    }
    if (!win) {
        throw new Error("Something went wrong opening pop-up");
    }
    const result = await new Promise((resolve, reject) => {
        // detect when the user closes the login window
        const pollTimer = window.setInterval(async () => {
            if (win.closed) {
                clearInterval(pollTimer);
                window.removeEventListener("message", messageListener);
                reject(new Error("User closed login window"));
            }
        }, 1000);
        const messageListener = async (event) => {
            if (event.origin !== (0, domains_js_1.getThirdwebBaseUrl)("inAppWallet")) {
                return;
            }
            if (typeof event.data !== "object") {
                reject(new Error("Invalid event data"));
                return;
            }
            switch (event.data.eventType) {
                case "oauthSuccessResult": {
                    window.removeEventListener("message", messageListener);
                    clearInterval(pollTimer);
                    closeWindow({
                        isWindowOpenedByFn,
                        win,
                        closeOpenedWindow: options.closeOpenedWindow,
                    });
                    if (event.data.authResult) {
                        resolve(event.data.authResult);
                    }
                    break;
                }
                case "oauthFailureResult": {
                    window.removeEventListener("message", messageListener);
                    clearInterval(pollTimer);
                    closeWindow({
                        isWindowOpenedByFn,
                        win,
                        closeOpenedWindow: options.closeOpenedWindow,
                    });
                    reject(new Error(event.data.errorString));
                    break;
                }
                default: {
                    // no-op, DO NOT THROW HERE
                }
            }
        };
        window.addEventListener("message", messageListener);
    });
    return result;
};
exports.loginWithOauth = loginWithOauth;
//# sourceMappingURL=oauth.js.map