"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncryptionKey = getEncryptionKey;
exports.encryptShareWeb = encryptShareWeb;
exports.decryptShareWeb = decryptShareWeb;
const react_native_aes_gcm_crypto_1 = require("react-native-aes-gcm-crypto");
const react_native_quick_crypto_1 = require("react-native-quick-crypto");
const utils_1 = require("viem/utils");
const hex_js_1 = require("../../../../../utils/encoding/hex.js");
const random_js_1 = require("../../../../../utils/random.js");
const uint8_array_js_1 = require("../../../../../utils/uint8-array.js");
const ENCRYPTION_SEPARATOR = ":";
const DEPRECATED_KEY_ITERATION_COUNT = 5000000;
const CURRENT_KEY_ITERATION_COUNT = 650000;
const KEY_LENGTH = 256;
async function getEncryptionKey(pwd, salt, iterationCounts) {
    // @ts-ignore - default import buils but ts doesn't like it
    const key = react_native_quick_crypto_1.default.pbkdf2Sync(pwd, salt.buffer, iterationCounts, KEY_LENGTH, "SHA-256");
    // this produces a 256 bits length key
    // but node by default produces a 32 byte length key
    const key32 = key.slice(0, 32);
    const base64key = (0, uint8_array_js_1.uint8ArrayToBase64)(new Uint8Array(key32));
    return base64key;
}
async function encryptShareWeb(share, pwd) {
    const salt = (0, random_js_1.randomBytesBuffer)(16);
    const iterationCount = CURRENT_KEY_ITERATION_COUNT;
    const keyBase64 = await getEncryptionKey(pwd, salt, iterationCount);
    // biome-ignore lint/suspicious/noExplicitAny: Can't import the types properly
    let encryptedValue;
    try {
        // @ts-ignore - default import buils but ts doesn't like it
        encryptedValue = await react_native_aes_gcm_crypto_1.default.encrypt(share, false, keyBase64);
    }
    catch (error) {
        throw new Error(`Error encrypting share: ${error}`);
    }
    // Ref: https://github.com/craftzdog/react-native-aes-gcm-crypto/blob/master/android/src/main/java/com/reactnativeaesgcmcrypto/AesGcmCryptoModule.kt#L111
    // Cipher text is a base64 string
    const cipherTextBase64Buffer = (0, uint8_array_js_1.base64ToUint8Array)(encryptedValue.content);
    // Tag is a hex string
    const tagHexBuffer = (0, hex_js_1.hexToUint8Array)(`0x${encryptedValue.tag}`);
    const cipherTextWithTag = (0, utils_1.concat)([cipherTextBase64Buffer, tagHexBuffer]);
    // iv is a hex string
    const ivBase64 = (0, uint8_array_js_1.uint8ArrayToBase64)((0, hex_js_1.hexToUint8Array)(`0x${encryptedValue.iv}`));
    const returnValue = `${(0, uint8_array_js_1.uint8ArrayToBase64)(cipherTextWithTag)}${ENCRYPTION_SEPARATOR}${ivBase64}${ENCRYPTION_SEPARATOR}${(0, uint8_array_js_1.uint8ArrayToBase64)(salt)}${ENCRYPTION_SEPARATOR}${iterationCount}`;
    return returnValue;
}
async function decryptShareWeb(encryptedShareDetails, pwd) {
    const [encryptedShareWithTagBase64, ivBase64, saltBase64, maybeIterationCount,] = encryptedShareDetails.split(ENCRYPTION_SEPARATOR);
    let iterationCount = maybeIterationCount
        ? Number.parseInt(maybeIterationCount)
        : undefined;
    if (!iterationCount) {
        iterationCount = DEPRECATED_KEY_ITERATION_COUNT;
    }
    const key = await getEncryptionKey(pwd, 
    // biome-ignore lint/style/noNonNullAssertion: its there
    (0, uint8_array_js_1.base64ToUint8Array)(saltBase64), iterationCount);
    const encryptedShareWithTagBuffer = (0, uint8_array_js_1.base64ToUint8Array)(
    // biome-ignore lint/style/noNonNullAssertion: its there
    encryptedShareWithTagBase64);
    // The tag is a 16 bytes long hex string
    const tagBytesLength = 16;
    const cipherTextBufferLength = encryptedShareWithTagBuffer.length - tagBytesLength;
    // Get cipherText and tag from encryptedShareWithTagBuffer
    const cipherTextBuffer = encryptedShareWithTagBuffer.subarray(0, cipherTextBufferLength);
    const tagBuffer = encryptedShareWithTagBuffer.subarray(cipherTextBufferLength);
    const originalBase64CipherText = (0, uint8_array_js_1.uint8ArrayToBase64)(cipherTextBuffer);
    // converting to hex since the decrypt function expects a hex string
    // Ref: https://github.com/craftzdog/react-native-aes-gcm-crypto/blob/master/android/src/main/java/com/reactnativeaesgcmcrypto/AesGcmCryptoModule.kt#L111
    const hexStringTag = (0, hex_js_1.uint8ArrayToHex)(tagBuffer);
    // converting to hex since the decrypt function expects a hex string
    // Ref: https://github.com/craftzdog/react-native-aes-gcm-crypto/blob/master/android/src/main/java/com/reactnativeaesgcmcrypto/AesGcmCryptoModule.kt#L111
    // biome-ignore lint/style/noNonNullAssertion: it's there
    const ivBufferHex = (0, hex_js_1.uint8ArrayToHex)((0, uint8_array_js_1.base64ToUint8Array)(ivBase64));
    // @ts-ignore - default import builds but ts doesn't like it
    const normalizedShare = await react_native_aes_gcm_crypto_1.default.decrypt(originalBase64CipherText, key, ivBufferHex.slice(2), // lib expects hex with no 0x prefix
    hexStringTag.slice(2), false);
    return normalizedShare;
}
//# sourceMappingURL=encryption.js.map