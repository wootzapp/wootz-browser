"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fiatQuoteToPartialQuote = fiatQuoteToPartialQuote;
exports.FiatSteps = FiatSteps;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_icons_1 = require("@radix-ui/react-icons");
const react_1 = require("react");
const utils_js_1 = require("../../../../../../../chains/utils.js");
const addresses_js_1 = require("../../../../../../../constants/addresses.js");
const formatNumber_js_1 = require("../../../../../../../utils/formatNumber.js");
const index_js_1 = require("../../../../../../core/design-system/index.js");
const useChainQuery_js_1 = require("../../../../../../core/hooks/others/useChainQuery.js");
const Spacer_js_1 = require("../../../../components/Spacer.js");
const Spinner_js_1 = require("../../../../components/Spinner.js");
const basic_js_1 = require("../../../../components/basic.js");
const buttons_js_1 = require("../../../../components/buttons.js");
const text_js_1 = require("../../../../components/text.js");
const TokenSymbol_js_1 = require("../../../../components/token/TokenSymbol.js");
const nativeToken_js_1 = require("../../nativeToken.js");
const PayTokenIcon_js_1 = require("../PayTokenIcon.js");
const Stepper_js_1 = require("../Stepper.js");
const statusMeta_js_1 = require("../pay-transactions/statusMeta.js");
const currencies_js_1 = require("./currencies.js");
function fiatQuoteToPartialQuote(quote) {
    const data = {
        fromCurrencyAmount: quote.fromCurrencyWithFees.amount,
        fromCurrencySymbol: quote.fromCurrencyWithFees.currencySymbol,
        onRampTokenAmount: quote.onRampToken.amount,
        toTokenAmount: quote.estimatedToAmountMin,
        onRampToken: {
            chainId: quote.onRampToken.token.chainId,
            tokenAddress: quote.onRampToken.token.tokenAddress,
            name: quote.onRampToken.token.name,
            symbol: quote.onRampToken.token.symbol,
        },
        toToken: {
            chainId: quote.toToken.chainId,
            tokenAddress: quote.toToken.tokenAddress,
            name: quote.toToken.name,
            symbol: quote.toToken.symbol,
        },
    };
    return data;
}
function FiatSteps(props) {
    const statusMeta = props.status
        ? (0, statusMeta_js_1.getBuyWithFiatStatusMeta)(props.status)
        : undefined;
    const { toToken: toTokenMeta, onRampToken: onRampTokenMeta, onRampTokenAmount, fromCurrencySymbol, fromCurrencyAmount, toTokenAmount, } = props.partialQuote;
    const currency = (0, currencies_js_1.getCurrencyMeta)(fromCurrencySymbol);
    const isPartialSuccess = statusMeta?.progressStatus === "partialSuccess";
    const toChain = (0, react_1.useMemo)(() => (0, utils_js_1.getCachedChain)(toTokenMeta.chainId), [toTokenMeta.chainId]);
    const destinationChain = (0, react_1.useMemo)(() => {
        if (props.status?.status !== "NOT_FOUND" && props.status?.destination) {
            return (0, utils_js_1.getCachedChain)(props.status?.destination.token.chainId);
        }
        return undefined;
    }, [props.status]);
    const toToken = (0, react_1.useMemo)(() => {
        if (toTokenMeta.tokenAddress === addresses_js_1.NATIVE_TOKEN_ADDRESS) {
            return nativeToken_js_1.NATIVE_TOKEN;
        }
        const tokenInfo = {
            address: toTokenMeta.tokenAddress,
            name: toTokenMeta.name || "",
            symbol: toTokenMeta.symbol || "",
            // TODO: when icon is available in endpoint
            // icon: toTokenMeta.icon
        };
        return tokenInfo;
    }, [toTokenMeta]);
    const onRampChain = (0, react_1.useMemo)(() => (0, utils_js_1.getCachedChain)(onRampTokenMeta.chainId), [onRampTokenMeta.chainId]);
    const onRampToken = (0, react_1.useMemo)(() => {
        if (onRampTokenMeta.tokenAddress === addresses_js_1.NATIVE_TOKEN_ADDRESS) {
            return nativeToken_js_1.NATIVE_TOKEN;
        }
        const tokenInfo = {
            address: onRampTokenMeta.tokenAddress,
            name: onRampTokenMeta.name || "",
            symbol: onRampTokenMeta.symbol || "",
            // TODO: when icon is available in endpoint
            // icon: onRampTokenMeta.icon,
        };
        return tokenInfo;
    }, [onRampTokenMeta]);
    const onRampName = (0, useChainQuery_js_1.useChainName)(onRampChain);
    const onRampExplorers = (0, useChainQuery_js_1.useChainExplorers)(onRampChain);
    const toChainName = (0, useChainQuery_js_1.useChainName)(toChain);
    const toChainExplorers = (0, useChainQuery_js_1.useChainExplorers)(toChain);
    const destinationName = (0, useChainQuery_js_1.useChainName)(destinationChain);
    const onRampTokenInfo = ((0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [(0, formatNumber_js_1.formatNumber)(Number(onRampTokenAmount), 6), (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: onRampToken, chain: onRampChain, size: "sm", inline: true })] }) }));
    const fiatIcon = (0, jsx_runtime_1.jsx)(currency.icon, { size: index_js_1.iconSize.sm });
    const onRampTokenIcon = ((0, jsx_runtime_1.jsx)(PayTokenIcon_js_1.PayTokenIcon, { token: onRampToken, chain: onRampChain, size: "sm", client: props.client }));
    const toTokenIcon = ((0, jsx_runtime_1.jsx)(PayTokenIcon_js_1.PayTokenIcon, { token: toToken, chain: toChain, size: "sm", client: props.client }));
    const onRampChainInfo = (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", children: onRampName.name });
    const partialSuccessToTokenInfo = props.status?.status === "CRYPTO_SWAP_FALLBACK" &&
        props.status.destination ? ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "secondaryText", size: "sm", inline: true, style: {
                    textDecoration: "line-through",
                }, children: [(0, formatNumber_js_1.formatNumber)(Number(toTokenAmount), 6), (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "secondaryText" })] }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "danger", size: "sm", inline: true, children: [(0, formatNumber_js_1.formatNumber)(Number(props.status.destination.amount), 6), (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: {
                            address: props.status.destination.token.tokenAddress,
                            name: props.status.destination.token.name || "",
                            symbol: props.status.destination.token.symbol || "",
                        }, chain: toChain, size: "sm", inline: true, color: "danger" })] })] })) : null;
    const toTokenInfo = partialSuccessToTokenInfo || ((0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [(0, formatNumber_js_1.formatNumber)(Number(toTokenAmount), 6), (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true })] }));
    const partialSuccessToChainInfo = props.status?.status === "CRYPTO_SWAP_FALLBACK" &&
        props.status.destination &&
        props.status.destination.token.chainId !==
            props.status.quote.toToken.chainId ? ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", inline: true, style: {
                    textDecoration: "line-through",
                }, children: toChainName.name }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", inline: true, children: destinationName.name })] })) : null;
    const toTokehChainInfo = partialSuccessToChainInfo || ((0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", children: toChainName.name }));
    const onRampTxHash = props.status?.status !== "NOT_FOUND"
        ? props.status?.source?.transactionHash
        : undefined;
    const toTokenTxHash = props.status?.status !== "NOT_FOUND"
        ? props.status?.destination?.transactionHash
        : undefined;
    const showContinueBtn = !props.status ||
        props.status.status === "CRYPTO_SWAP_REQUIRED" ||
        props.status.status === "CRYPTO_SWAP_FAILED";
    function getStep1State() {
        if (!statusMeta) {
            if (props.step === 2) {
                return "completed";
            }
            return "actionRequired";
        }
        if (statusMeta.step === 2) {
            return "completed";
        }
        return statusMeta.progressStatus;
    }
    function getStep2State() {
        if (!statusMeta) {
            if (props.step === 2) {
                return "actionRequired";
            }
            return undefined;
        }
        if (statusMeta.step === 2) {
            return statusMeta.progressStatus;
        }
        return undefined;
    }
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(PaymentStep, { title: (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "md", children: ["Get", (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: onRampToken, chain: onRampChain, size: "md", inline: true }), "with ", props.partialQuote.fromCurrencySymbol] }), step: 1, from: {
                    icon: fiatIcon,
                    primaryText: ((0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "sm", children: [(0, formatNumber_js_1.formatNumber)(Number(fromCurrencyAmount), 6), " ", fromCurrencySymbol] })),
                }, to: {
                    icon: onRampTokenIcon,
                    primaryText: onRampTokenInfo,
                    secondaryText: onRampChainInfo,
                }, state: getStep1State(), explorer: onRampExplorers.explorers[0]?.url && onRampTxHash
                    ? {
                        label: "View on Explorer",
                        url: `${onRampExplorers.explorers[0]?.url}/tx/${onRampTxHash}`,
                    }
                    : undefined }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(PaymentStep, { title: (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "primaryText", size: "md", children: ["Convert", (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: onRampToken, chain: onRampChain, size: "md", inline: true }), "to ", (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: toToken, chain: toChain, size: "md", inline: true })] }), step: 2, from: {
                    icon: onRampTokenIcon,
                    primaryText: onRampTokenInfo,
                    secondaryText: onRampChainInfo,
                }, to: {
                    icon: toTokenIcon,
                    primaryText: toTokenInfo,
                    secondaryText: toTokehChainInfo,
                }, state: getStep2State(), explorer: toChainExplorers.explorers[0]?.url && toTokenTxHash
                    ? {
                        label: "View on Explorer",
                        url: `${toChainExplorers.explorers[0].url}/tx/${toTokenTxHash}`,
                    }
                    : undefined }), isPartialSuccess &&
                props.status &&
                props.status.status !== "NOT_FOUND" &&
                props.status.source &&
                props.status.destination && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "danger", size: "sm", center: true, children: ["Expected ", props.status.source?.token.symbol, ", Got", props.status.destination?.token.symbol, " instead"] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" })] })), showContinueBtn && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", onClick: props.onContinue, fullWidth: true, children: "Continue" })] }))] }));
}
function PaymentStep(props) {
    return ((0, jsx_runtime_1.jsxs)(StepContainer, { state: props.state, children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "sm", children: ["Step ", props.step] }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), props.title, (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsx)(basic_js_1.Line, {}), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(PaymentSubStep, { ...props.from }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { color: "borderColor", style: {
                    paddingLeft: "18px",
                    position: "relative",
                    marginBlock: "3px",
                }, children: [(0, jsx_runtime_1.jsx)("div", { style: {
                            height: "18px",
                            width: "2px",
                            backgroundColor: "currentColor",
                            transform: "translateX(-50%)",
                        } }), (0, jsx_runtime_1.jsx)(react_icons_1.TriangleDownIcon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm, style: {
                            position: "absolute",
                            bottom: "0",
                            transform: "translate(-50%, 50%)",
                        } })] }), (0, jsx_runtime_1.jsx)(PaymentSubStep, { ...props.to }), props.explorer && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsxs)(buttons_js_1.ButtonLink, { variant: "outline", fullWidth: true, href: props.explorer.url, style: {
                            fontSize: index_js_1.fontSize.xs,
                            padding: index_js_1.spacing.xs,
                        }, gap: "xxs", target: "_blank", children: [props.explorer.label, (0, jsx_runtime_1.jsx)(react_icons_1.ExternalLinkIcon, { width: index_js_1.iconSize.xs, height: index_js_1.iconSize.xs })] })] }))] }));
}
function PaymentSubStep(props) {
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", center: "y", style: {
            flexWrap: "nowrap",
        }, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "xs", borderColor: "borderColor", flex: "row", center: "both", style: {
                    borderStyle: "solid",
                    borderWidth: "1.5px",
                    borderRadius: index_js_1.radius.lg,
                }, children: props.icon }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "xxs", children: [props.primaryText, props.secondaryText] })] }));
}
function StepContainer(props) {
    let color = "borderColor";
    let text;
    if (props.state === "pending") {
        text = "Pending";
        color = "accentText";
    }
    else if (props.state === "actionRequired") {
        color = "accentText";
    }
    else if (props.state === "completed") {
        text = "Completed";
        color = "success";
    }
    else if (props.state === "failed") {
        color = "danger";
        text = "Failed";
    }
    else if (props.state === "partialSuccess") {
        color = "danger";
        text = "Incomplete";
    }
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { bg: "tertiaryBg", borderColor: color === "success" ? "borderColor" : color, py: "sm", px: "md", style: {
            borderRadius: index_js_1.radius.lg,
            alignItems: "flex-start",
            borderWidth: "1px",
            borderStyle: "solid",
            position: "relative",
        }, children: [props.children, (0, jsx_runtime_1.jsxs)("div", { style: {
                    position: "absolute",
                    right: index_js_1.spacing.sm,
                    top: index_js_1.spacing.sm,
                    display: "flex",
                    gap: index_js_1.spacing.xs,
                    alignItems: "center",
                }, children: [props.state && text && ((0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: color, children: text })), (props.state === "actionRequired" || props.state === "completed") && ((0, jsx_runtime_1.jsx)(Stepper_js_1.StepIcon, { isActive: props.state === "actionRequired", isDone: props.state === "completed" })), props.state === "pending" && (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { color: "accentText", size: "sm" }), props.state === "failed" && ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { color: "danger", flex: "row", center: "both", children: (0, jsx_runtime_1.jsx)(react_icons_1.Cross1Icon, { width: index_js_1.iconSize.sm, height: index_js_1.iconSize.sm }) }))] })] }));
}
//# sourceMappingURL=FiatSteps.js.map