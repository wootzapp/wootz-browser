"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BuyScreen;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_icons_1 = require("@radix-ui/react-icons");
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const track_js_1 = require("../../../../../../analytics/track.js");
const addresses_js_1 = require("../../../../../../constants/addresses.js");
const isSwapRequiredPostOnramp_js_1 = require("../../../../../../pay/buyWithFiat/isSwapRequiredPostOnramp.js");
const formatNumber_js_1 = require("../../../../../../utils/formatNumber.js");
const index_js_1 = require("../../../../../core/design-system/index.js");
const useWalletBalance_js_1 = require("../../../../../core/hooks/others/useWalletBalance.js");
const useBuyWithCryptoQuote_js_1 = require("../../../../../core/hooks/pay/useBuyWithCryptoQuote.js");
const useBuyWithFiatQuote_js_1 = require("../../../../../core/hooks/pay/useBuyWithFiatQuote.js");
const useActiveAccount_js_1 = require("../../../../../core/hooks/wallets/useActiveAccount.js");
const invalidateWalletBalance_js_1 = require("../../../../../core/providers/invalidateWalletBalance.js");
const LoadingScreen_js_1 = require("../../../../wallets/shared/LoadingScreen.js");
const ChainName_js_1 = require("../../../components/ChainName.js");
const Drawer_js_1 = require("../../../components/Drawer.js");
const Spacer_js_1 = require("../../../components/Spacer.js");
const Spinner_js_1 = require("../../../components/Spinner.js");
const SwitchNetwork_js_1 = require("../../../components/SwitchNetwork.js");
const basic_js_1 = require("../../../components/basic.js");
const buttons_js_1 = require("../../../components/buttons.js");
const text_js_1 = require("../../../components/text.js");
const TokenSymbol_js_1 = require("../../../components/token/TokenSymbol.js");
const ConnectButton_js_1 = require("../../ConnectButton.js");
const NetworkSelector_js_1 = require("../../NetworkSelector.js");
const CoinsIcon_js_1 = require("../../icons/CoinsIcon.js");
const TokenSelector_js_1 = require("../TokenSelector.js");
const WalletSwitcherConnectionScreen_js_1 = require("../WalletSwitcherConnectionScreen.js");
const nativeToken_js_1 = require("../nativeToken.js");
const DirectPaymentModeScreen_js_1 = require("./DirectPaymentModeScreen.js");
const EstimatedTimeAndFees_js_1 = require("./EstimatedTimeAndFees.js");
const PayTokenIcon_js_1 = require("./PayTokenIcon.js");
const PayWIthCreditCard_js_1 = require("./PayWIthCreditCard.js");
const TransactionModeScreen_js_1 = require("./TransactionModeScreen.js");
const WalletSelectorButton_js_1 = require("./WalletSelectorButton.js");
const CurrencySelection_js_1 = require("./fiat/CurrencySelection.js");
const FiatFlow_js_1 = require("./fiat/FiatFlow.js");
const useEnabledPaymentMethods_js_1 = require("./main/useEnabledPaymentMethods.js");
const useUISelectionStates_js_1 = require("./main/useUISelectionStates.js");
const openOnRamppopup_js_1 = require("./openOnRamppopup.js");
const BuyTokenInput_js_1 = require("./swap/BuyTokenInput.js");
const Fees_js_1 = require("./swap/Fees.js");
const PayWithCrypto_js_1 = require("./swap/PayWithCrypto.js");
const SwapFlow_js_1 = require("./swap/SwapFlow.js");
const TransferFlow_js_1 = require("./swap/TransferFlow.js");
const WalletSwitcherDrawerContent_js_1 = require("./swap/WalletSwitcherDrawerContent.js");
const pendingSwapTx_js_1 = require("./swap/pendingSwapTx.js");
const useSwapSupportedChains_js_1 = require("./swap/useSwapSupportedChains.js");
const usePayerSetup_js_1 = require("./usePayerSetup.js");
/**
 * @internal
 */
function BuyScreen(props) {
    const isTestMode = props.payOptions.buyWithCrypto
        ? props.payOptions.buyWithCrypto.testMode
        : undefined;
    const supportedDestinationsQuery = (0, useSwapSupportedChains_js_1.useBuySupportedDestinations)(props.client, isTestMode);
    if (!supportedDestinationsQuery.data) {
        return (0, jsx_runtime_1.jsx)(LoadingScreen_js_1.LoadingScreen, {});
    }
    return ((0, jsx_runtime_1.jsx)(BuyScreenContent, { ...props, supportedDestinations: supportedDestinationsQuery.data }));
}
/**
 * @internal
 */
function BuyScreenContent(props) {
    const { client, supportedDestinations, connectLocale, payOptions } = props;
    const activeAccount = (0, useActiveAccount_js_1.useActiveAccount)();
    const { payer, setPayer } = (0, usePayerSetup_js_1.usePayerSetup)();
    const [screen, setScreen] = (0, react_1.useState)({
        id: "main",
    });
    const { tokenAmount, setTokenAmount, toChain, setToChain, deferredTokenAmount, toToken, setToToken, } = (0, useUISelectionStates_js_1.useToTokenSelectionStates)({
        payOptions,
        supportedDestinations,
    });
    const [hasEditedAmount, setHasEditedAmount] = (0, react_1.useState)(false);
    const onDone = (0, react_1.useCallback)(() => {
        setScreen({ id: "main" });
        props.onDone();
    }, [props.onDone]);
    // check if the screen is expanded or not
    // update supportedSources whenever toToken or toChain is updated
    const supportedSourcesQuery = (0, useSwapSupportedChains_js_1.useBuySupportedSources)({
        client: props.client,
        destinationChainId: toChain.id,
        destinationTokenAddress: (0, nativeToken_js_1.isNativeToken)(toToken)
            ? addresses_js_1.NATIVE_TOKEN_ADDRESS
            : toToken.address,
    });
    const destinationSupportedTokens = (0, react_1.useMemo)(() => {
        return createSupportedTokens(supportedDestinations, payOptions, props.supportedTokens);
    }, [props.supportedTokens, supportedDestinations, payOptions]);
    const sourceSupportedTokens = (0, react_1.useMemo)(() => {
        if (!supportedSourcesQuery.data) {
            return undefined;
        }
        const supportedSources = supportedSourcesQuery.data;
        return createSupportedTokens(supportedSources, payOptions, props.supportedTokens);
    }, [props.supportedTokens, supportedSourcesQuery.data, payOptions]);
    const { fromChain, setFromChain, fromToken, setFromToken } = (0, useUISelectionStates_js_1.useFromTokenSelectionStates)({
        payOptions,
        supportedSources: supportedSourcesQuery.data || [],
    });
    const { selectedCurrency, setSelectedCurrency } = (0, useUISelectionStates_js_1.useFiatCurrencySelectionStates)({
        payOptions,
    });
    const enabledPaymentMethods = (0, useEnabledPaymentMethods_js_1.useEnabledPaymentMethods)({
        payOptions: props.payOptions,
        supportedDestinations: props.supportedDestinations,
        toChain: toChain,
        toToken: toToken,
    });
    const payDisabled = enabledPaymentMethods.showPaymentSelection === false &&
        enabledPaymentMethods.buyWithCryptoEnabled === false &&
        enabledPaymentMethods.buyWithFiatEnabled === false;
    // screens ----------------------------
    const queryClient = (0, react_query_1.useQueryClient)();
    const onSwapSuccess = (0, react_1.useCallback)((_status) => {
        props.payOptions.onPurchaseSuccess?.({
            type: "crypto",
            status: _status,
        });
        (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient);
    }, [props.payOptions.onPurchaseSuccess, queryClient]);
    const onFiatSuccess = (0, react_1.useCallback)((_status) => {
        props.payOptions.onPurchaseSuccess?.({
            type: "fiat",
            status: _status,
        });
        (0, invalidateWalletBalance_js_1.invalidateWalletBalance)(queryClient);
    }, [props.payOptions.onPurchaseSuccess, queryClient]);
    if (screen.id === "connect-payer-wallet") {
        return ((0, jsx_runtime_1.jsx)(WalletSwitcherConnectionScreen_js_1.WalletSwitcherConnectionScreen, { accountAbstraction: props.connectOptions?.accountAbstraction, appMetadata: props.connectOptions?.appMetadata, chain: props.connectOptions?.chain, chains: props.connectOptions?.chains, client: props.client, connectLocale: props.connectLocale, isEmbed: props.isEmbed, onBack: () => setScreen(screen.backScreen), onSelect: (w) => {
                const account = w.getAccount();
                const chain = w.getChain();
                if (w && account && chain) {
                    setPayer({
                        account,
                        chain,
                        wallet: w,
                    });
                }
            }, hiddenWallets: props.hiddenWallets, recommendedWallets: props.connectOptions?.recommendedWallets, showAllWallets: props.connectOptions?.showAllWallets === undefined
                ? true
                : props.connectOptions?.showAllWallets, walletConnect: props.connectOptions?.walletConnect, wallets: props.connectOptions?.wallets?.filter((w) => w.id !== "inApp") }));
    }
    if (screen.id === "swap-flow" && payer) {
        return ((0, jsx_runtime_1.jsx)(SwapFlow_js_1.SwapFlow, { title: props.title, transactionMode: payOptions.mode === "transaction", isEmbed: props.isEmbed, client: client, onBack: () => {
                setScreen({
                    id: "buy-with-crypto",
                });
            }, buyWithCryptoQuote: screen.quote, payer: payer, isFiatFlow: false, onDone: onDone, onTryAgain: () => {
                setScreen({
                    id: "buy-with-crypto",
                });
            }, onSuccess: onSwapSuccess }));
    }
    if (screen.id === "fiat-flow" && payer) {
        return ((0, jsx_runtime_1.jsx)(FiatFlow_js_1.FiatFlow, { title: props.title, transactionMode: payOptions.mode === "transaction", quote: screen.quote, onBack: () => {
                setScreen({
                    id: "buy-with-fiat",
                });
            }, client: client, testMode: props.payOptions.buyWithFiat !== false &&
                props.payOptions.buyWithFiat?.testMode === true, theme: typeof props.theme === "string" ? props.theme : props.theme.type, openedWindow: screen.openedWindow, onDone: onDone, isEmbed: props.isEmbed, payer: payer, onSuccess: onFiatSuccess }));
    }
    if (screen.id === "transfer-flow" && payer && activeAccount) {
        const goBack = () => setScreen({ id: "buy-with-crypto" });
        // TODO (pay) pass it via screen props
        const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;
        const receiverAddress = defaultRecipientAddress || activeAccount.address;
        return ((0, jsx_runtime_1.jsx)(TransferFlow_js_1.TransferFlow, { title: props.title, onBack: goBack, payer: payer, client: props.client, chain: toChain, token: toToken, tokenAmount: tokenAmount, receiverAddress: receiverAddress, transactionMode: props.payOptions.mode === "transaction", isEmbed: props.isEmbed, onDone: onDone, onTryAgain: () => {
                setScreen({
                    id: "buy-with-crypto",
                });
            }, onSuccess: onSwapSuccess }));
    }
    if (screen.id === "select-currency") {
        const goBack = () => setScreen(screen.backScreen);
        return ((0, jsx_runtime_1.jsx)(CurrencySelection_js_1.CurrencySelection, { onSelect: (currency) => {
                goBack();
                setSelectedCurrency(currency);
            }, onBack: goBack }));
    }
    if (screen.id === "select-to-token") {
        const chains = supportedDestinations.map((x) => x.chain);
        const goBack = () => setScreen(screen.backScreen);
        const allowEdits = payOptions?.prefillBuy
            ?.allowEdits;
        // if token selection is disabled - only show network selector screen
        if (allowEdits?.token === false) {
            return ((0, jsx_runtime_1.jsx)(ChainSelectionScreen, { chains: chains, client: props.client, connectLocale: props.connectLocale, setChain: setToChain, goBack: goBack }));
        }
        return ((0, jsx_runtime_1.jsx)(TokenSelector_js_1.TokenSelector, { onBack: goBack, tokenList: ((toChain?.id ? destinationSupportedTokens[toChain.id] : undefined) ||
                []).filter((x) => x.address !== addresses_js_1.NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {
                setToToken(tokenInfo);
                goBack();
            }, chain: toChain, chainSelection: 
            // hide chain selection if it's disabled
            allowEdits?.chain !== false
                ? {
                    chains: chains,
                    select: (c) => {
                        setToChain(c);
                    },
                }
                : undefined, connectLocale: connectLocale, client: client, modalTitle: props.title }));
    }
    if (screen.id === "select-from-token" &&
        supportedSourcesQuery.data &&
        sourceSupportedTokens) {
        const chains = supportedSourcesQuery.data.map((x) => x.chain);
        const goBack = () => setScreen(screen.backScreen);
        // if token selection is disabled - only show network selector screen
        if (payOptions.buyWithCrypto !== false &&
            payOptions.buyWithCrypto?.prefillSource?.allowEdits?.token === false) {
            return ((0, jsx_runtime_1.jsx)(ChainSelectionScreen, { chains: chains, client: props.client, connectLocale: props.connectLocale, setChain: setFromChain, goBack: goBack }));
        }
        return ((0, jsx_runtime_1.jsx)(TokenSelector_js_1.TokenSelector, { onBack: goBack, tokenList: ((fromChain?.id ? sourceSupportedTokens[fromChain.id] : undefined) ||
                []).filter((x) => x.address !== addresses_js_1.NATIVE_TOKEN_ADDRESS), onTokenSelect: (tokenInfo) => {
                setFromToken(tokenInfo);
                goBack();
            }, chain: fromChain, chainSelection: 
            // hide chain selection if it's disabled
            payOptions.buyWithCrypto !== false &&
                payOptions.buyWithCrypto?.prefillSource?.allowEdits?.chain !== false
                ? {
                    chains: supportedSourcesQuery.data.map((x) => x.chain),
                    select: (c) => setFromChain(c),
                }
                : undefined, connectLocale: connectLocale, client: client, modalTitle: "Pay with" }));
    }
    return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { animate: "fadein", children: (0, jsx_runtime_1.jsxs)("div", { children: [screen.id === "main" && ((0, jsx_runtime_1.jsx)(MainScreen, { title: props.title, payerAccount: payer?.account, client: client, onSelectBuyToken: () => setScreen({ id: "select-to-token", backScreen: screen }), payOptions: payOptions, setTokenAmount: setTokenAmount, setToChain: setToChain, setToToken: setToToken, setFromChain: setFromChain, setFromToken: setFromToken, toChain: toChain, toToken: toToken, tokenAmount: tokenAmount, connectOptions: props.connectOptions, setScreen: setScreen, supportedDestinations: supportedDestinations, onBack: props.onBack, theme: props.theme, hasEditedAmount: hasEditedAmount, setHasEditedAmount: setHasEditedAmount, enabledPaymentMethods: enabledPaymentMethods })), (screen.id === "select-payment-method" ||
                    screen.id === "select-wallet" ||
                    screen.id === "buy-with-crypto" ||
                    screen.id === "buy-with-fiat") &&
                    payer && ((0, jsx_runtime_1.jsxs)(TokenSelectedLayout, { title: props.title, selectedChain: toChain, selectedToken: toToken, tokenAmount: tokenAmount, client: client, onBack: () => {
                        if (enabledPaymentMethods.showPaymentSelection &&
                            (screen.id === "select-wallet" ||
                                screen.id === "buy-with-fiat")) {
                            setScreen({ id: "select-payment-method" });
                        }
                        else if (screen.id === "buy-with-crypto") {
                            setScreen({ id: "select-wallet" });
                        }
                        else {
                            setScreen({ id: "main" });
                        }
                    }, children: [screen.id === "select-payment-method" && ((0, jsx_runtime_1.jsx)(PaymentMethodSelection, { mode: payOptions.mode, client: client, walletAddress: payer.account.address, walletType: payer.wallet.id, setScreen: (id) => setScreen({ id }) })), screen.id === "select-wallet" && ((0, jsx_runtime_1.jsx)(WalletSwitcherDrawerContent_js_1.WalletSwitcherDrawerContent, { client: client, hiddenWallets: props.hiddenWallets, onSelect: (w) => {
                                const chain = w.getChain();
                                const account = w.getAccount();
                                if (chain && account) {
                                    setPayer({
                                        account,
                                        chain,
                                        wallet: w,
                                    });
                                    setScreen({ id: "buy-with-crypto" });
                                }
                            }, showAllWallets: !!props.connectOptions?.showAllWallets, wallets: props.connectOptions?.wallets, onBack: () => {
                                // no-op
                            }, onConnect: () => {
                                setScreen({
                                    id: "connect-payer-wallet",
                                    backScreen: {
                                        id: "select-wallet",
                                    },
                                });
                            }, selectedAddress: payer.account.address })), screen.id === "buy-with-crypto" && activeAccount && ((0, jsx_runtime_1.jsx)(SwapScreenContent, { setScreen: setScreen, tokenAmount: deferredTokenAmount, toChain: toChain, toToken: toToken, fromChain: fromChain, fromToken: fromToken, showFromTokenSelector: () => {
                                setScreen({
                                    id: "select-from-token",
                                    backScreen: screen,
                                });
                            }, payer: payer, client: client, isEmbed: props.isEmbed, onDone: onDone, payOptions: payOptions, connectLocale: connectLocale, connectOptions: props.connectOptions, setPayer: setPayer, 
                            // pass it even though we are passing payer, because payer might be different
                            activeAccount: activeAccount, setTokenAmount: setTokenAmount, setHasEditedAmount: setHasEditedAmount, disableTokenSelection: payDisabled === true ||
                                (payOptions.buyWithCrypto !== false &&
                                    payOptions.buyWithCrypto?.prefillSource?.allowEdits
                                        ?.chain === false &&
                                    payOptions.buyWithCrypto?.prefillSource?.allowEdits
                                        ?.token === false) })), screen.id === "buy-with-fiat" && ((0, jsx_runtime_1.jsx)(FiatScreenContent, { setScreen: setScreen, tokenAmount: deferredTokenAmount, toChain: toChain, toToken: toToken, selectedCurrency: selectedCurrency, client: client, isEmbed: props.isEmbed, onDone: onDone, payOptions: payOptions, theme: props.theme, showCurrencySelector: () => {
                                setScreen({
                                    id: "select-currency",
                                    backScreen: screen,
                                });
                            }, payer: payer, setTokenAmount: setTokenAmount, setHasEditedAmount: setHasEditedAmount }))] }))] }) }));
}
function SelectedTokenInfo(props) {
    return ((0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", center: "y", style: {
                justifyContent: "space-between",
            }, children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", center: "y", children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "primaryText", "data-testid": "tokenAmount", size: "xl", children: (0, formatNumber_js_1.formatNumber)(Number(props.tokenAmount), 6) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xxs", center: "y", children: [(0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: props.selectedToken, chain: props.selectedChain, size: "md", color: "secondaryText" }), (0, jsx_runtime_1.jsx)(PayTokenIcon_js_1.PayTokenIcon, { chain: props.selectedChain, client: props.client, size: "sm", token: props.selectedToken })] })] }), (0, jsx_runtime_1.jsx)(ChainName_js_1.ChainName, { chain: props.selectedChain, client: props.client, size: "sm", short: true })] }) }));
}
function MainScreen(props) {
    const { setTokenAmount, setToChain, setToToken, setFromChain, setFromToken, payerAccount, client, tokenAmount, payOptions, toToken, toChain, supportedDestinations, enabledPaymentMethods, } = props;
    const { showPaymentSelection, buyWithCryptoEnabled, buyWithFiatEnabled } = enabledPaymentMethods;
    const disableContinue = !tokenAmount;
    switch (payOptions.mode) {
        case "transaction": {
            return ((0, jsx_runtime_1.jsx)(TransactionModeScreen_js_1.TransactionModeScreen, { supportedDestinations: supportedDestinations, payUiOptions: payOptions, payerAccount: payerAccount, connectOptions: props.connectOptions, client: client, onContinue: (tokenAmount, toChain, toToken) => {
                    setTokenAmount(tokenAmount);
                    setToChain(toChain);
                    setFromChain(toChain);
                    setFromToken(toToken);
                    setToToken(toToken);
                    if (showPaymentSelection) {
                        props.setScreen({ id: "select-payment-method" });
                    }
                    else if (buyWithCryptoEnabled) {
                        props.setScreen({ id: "select-wallet" });
                    }
                    else if (buyWithFiatEnabled) {
                        props.setScreen({ id: "buy-with-fiat" });
                    }
                    else {
                        // default to buy with crypto with connected wallet if chain not supported by pay
                        props.setScreen({ id: "select-wallet" });
                    }
                } }));
        }
        case "direct_payment": {
            return ((0, jsx_runtime_1.jsx)(DirectPaymentModeScreen_js_1.DirectPaymentModeScreen, { client: client, payUiOptions: payOptions, payerAccount: payerAccount, connectOptions: props.connectOptions, supportedDestinations: supportedDestinations, onContinue: (tokenAmount, toChain, toToken) => {
                    setTokenAmount(tokenAmount);
                    setToChain(toChain);
                    setFromChain(toChain);
                    setFromToken(toToken);
                    setToToken(toToken);
                    if (showPaymentSelection) {
                        props.setScreen({ id: "select-payment-method" });
                    }
                    else if (buyWithCryptoEnabled) {
                        props.setScreen({ id: "buy-with-crypto" });
                    }
                    else if (buyWithFiatEnabled) {
                        props.setScreen({ id: "buy-with-fiat" });
                    }
                    else {
                        // default to buy with crypto with connected wallet if chain not supported by pay
                        props.setScreen({ id: "select-wallet" });
                    }
                } }));
        }
        default: {
            return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(BuyTokenInput_js_1.BuyTokenInput, { value: tokenAmount, onChange: async (value) => {
                            props.setHasEditedAmount(true);
                            setTokenAmount(value);
                        }, freezeAmount: payOptions.prefillBuy?.allowEdits?.amount === false, freezeChainAndToken: payOptions.prefillBuy?.allowEdits?.chain === false &&
                            payOptions.prefillBuy?.allowEdits?.token === false, token: toToken, chain: toChain, onSelectToken: props.onSelectBuyToken, client: props.client }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", children: !payerAccount ? ((0, jsx_runtime_1.jsx)("div", { children: (0, jsx_runtime_1.jsx)(ConnectButton_js_1.ConnectButton, { ...props.connectOptions, client: props.client, theme: props.theme, connectButton: {
                                    style: {
                                        width: "100%",
                                    },
                                } }) })) : ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, disabled: disableContinue, "data-disabled": disableContinue, onClick: () => {
                                if (showPaymentSelection) {
                                    props.setScreen({ id: "select-payment-method" });
                                }
                                else if (buyWithCryptoEnabled) {
                                    props.setScreen({ id: "buy-with-crypto" });
                                }
                                else if (buyWithFiatEnabled) {
                                    props.setScreen({ id: "buy-with-fiat" });
                                }
                                else {
                                    console.error("No payment method enabled");
                                }
                            }, children: "Continue" })) })] }));
        }
    }
}
function TokenSelectedLayout(props) {
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { p: "lg", children: (0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: props.title, onBack: props.onBack }) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { px: "lg", style: {
                    paddingBottom: index_js_1.spacing.lg,
                }, children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xs" }), (0, jsx_runtime_1.jsx)(SelectedTokenInfo, { selectedToken: props.selectedToken, selectedChain: props.selectedChain, tokenAmount: props.tokenAmount, client: props.client }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(basic_js_1.Line, {}), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", children: " Pay with " }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), props.children] })] }));
}
function PaymentMethodSelection(props) {
    return ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { animate: "fadein", children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "sm", children: [(0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { variant: "outline", bg: "tertiaryBg", onClick: () => {
                        (0, track_js_1.trackPayEvent)({
                            event: `pay_with_credit_card_${props.mode || "unknown"}_mode`,
                            client: props.client,
                            walletAddress: props.walletAddress,
                            walletType: props.walletType,
                        });
                        props.setScreen("buy-with-fiat");
                    }, gap: "sm", style: {
                        justifyContent: "flex-start",
                        textAlign: "left",
                    }, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { color: "secondaryText", flex: "row", center: "both", children: (0, jsx_runtime_1.jsx)(react_icons_1.IdCardIcon, { style: {
                                    width: index_js_1.iconSize.md,
                                    height: index_js_1.iconSize.md,
                                } }) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "xxs", children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "md", color: "primaryText", children: "Credit Card" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", children: "Securely pay with credit card" })] })] }), (0, jsx_runtime_1.jsxs)(buttons_js_1.Button, { variant: "outline", bg: "tertiaryBg", onClick: () => {
                        (0, track_js_1.trackPayEvent)({
                            event: `pay_with_crypto_${props.mode || "unknown"}_mode`,
                            client: props.client,
                            walletAddress: props.walletAddress,
                            walletType: props.walletType,
                        });
                        props.setScreen("select-wallet");
                    }, style: {
                        justifyContent: "flex-start",
                    }, gap: "sm", children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { color: "secondaryText", flex: "row", center: "both", children: (0, jsx_runtime_1.jsx)(CoinsIcon_js_1.CoinsIcon, { size: index_js_1.iconSize.md }) }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "xxs", children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "md", color: "primaryText", children: "Crypto" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", children: "Pay with your connected wallet" })] })] })] }) }));
}
function SwapScreenContent(props) {
    const { setScreen, payer, client, toChain, tokenAmount, toToken, fromChain, fromToken, showFromTokenSelector, payOptions, disableTokenSelection, } = props;
    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;
    const receiverAddress = defaultRecipientAddress || props.activeAccount.address;
    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = (0, Drawer_js_1.useDrawer)();
    const [drawerScreen, setDrawerScreen] = (0, react_1.useState)("fees");
    const fromTokenBalanceQuery = (0, useWalletBalance_js_1.useWalletBalance)({
        address: payer.account.address,
        chain: fromChain,
        tokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken) ? undefined : fromToken.address,
        client,
    });
    const fromTokenId = (0, nativeToken_js_1.isNativeToken)(fromToken)
        ? addresses_js_1.NATIVE_TOKEN_ADDRESS
        : fromToken.address.toLowerCase();
    const toTokenId = (0, nativeToken_js_1.isNativeToken)(toToken)
        ? addresses_js_1.NATIVE_TOKEN_ADDRESS
        : toToken.address.toLowerCase();
    const swapRequired = !!tokenAmount &&
        !(fromChain.id === toChain.id && fromTokenId === toTokenId);
    const quoteParams = swapRequired
        ? {
            // wallets
            fromAddress: payer.account.address,
            toAddress: receiverAddress,
            // from
            fromChainId: fromChain.id,
            fromTokenAddress: (0, nativeToken_js_1.isNativeToken)(fromToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : fromToken.address,
            // to
            toChainId: toChain.id,
            toTokenAddress: (0, nativeToken_js_1.isNativeToken)(toToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: tokenAmount,
            client,
            purchaseData: payOptions.purchaseData,
        }
        : undefined;
    const quoteQuery = (0, useBuyWithCryptoQuote_js_1.useBuyWithCryptoQuote)(quoteParams, {
        // refetch every 30 seconds
        staleTime: 30 * 1000,
        refetchInterval: 30 * 1000,
        gcTime: 30 * 1000,
    });
    const sourceTokenAmount = swapRequired
        ? quoteQuery.data?.swapDetails.fromAmount
        : tokenAmount;
    const isNotEnoughBalance = !!sourceTokenAmount &&
        !!fromTokenBalanceQuery.data &&
        Number(fromTokenBalanceQuery.data.displayValue) < Number(sourceTokenAmount);
    const disableContinue = (swapRequired && !quoteQuery.data) || isNotEnoughBalance;
    const switchChainRequired = props.payer.chain.id !== fromChain.id;
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    function getErrorMessage(err) {
        const defaultMessage = "Unable to get price quote";
        try {
            if (err.error.code === "MINIMUM_PURCHASE_AMOUNT") {
                const obj = err.error;
                const minAmountToken = obj.data.minimumAmountEth;
                return {
                    minAmount: (0, formatNumber_js_1.formatNumber)(Number(minAmountToken), 6),
                };
            }
        }
        catch { }
        return {
            msg: [defaultMessage],
        };
    }
    const errorMsg = !quoteQuery.isLoading && quoteQuery.error
        ? getErrorMessage(quoteQuery.error)
        : undefined;
    function showSwapFlow() {
        if ((props.payOptions.mode === "direct_payment" ||
            props.payOptions.mode === "fund_wallet") &&
            !isNotEnoughBalance &&
            !swapRequired) {
            // same currency, just direct transfer
            setScreen({
                id: "transfer-flow",
            });
        }
        else if (props.payOptions.mode === "transaction" &&
            !isNotEnoughBalance &&
            !swapRequired) {
            if (payer.account.address !== receiverAddress) {
                // needs transfer from another wallet before executing the transaction
                setScreen({
                    id: "transfer-flow",
                });
            }
            else {
                // has enough balance to just do the transaction directly
                props.onDone();
            }
            return;
        }
        if (!quoteQuery.data) {
            return;
        }
        setScreen({
            id: "swap-flow",
            quote: quoteQuery.data,
        });
    }
    function showFees() {
        if (!quoteQuery.data) {
            return;
        }
        setIsOpen(true);
        setDrawerScreen("fees");
    }
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "md", animate: "fadein", children: [isOpen && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Drawer_js_1.DrawerOverlay, { ref: drawerOverlayRef }), (0, jsx_runtime_1.jsx)(Drawer_js_1.Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: drawerScreen === "fees" && quoteQuery.data && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "lg", color: "primaryText", children: "Fees" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(Fees_js_1.SwapFees, { quote: quoteQuery.data })] })) })] })), (0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(WalletSelectorButton_js_1.WalletSelectorButton, { client: props.client, onClick: () => {
                            setScreen({ id: "select-wallet" });
                        }, address: props.payer.account.address, walletId: props.payer.wallet.id, containerStyle: {
                            borderBottomRightRadius: 0,
                            borderBottomLeftRadius: 0,
                        } }), (0, jsx_runtime_1.jsx)(PayWithCrypto_js_1.PayWithCrypto, { value: sourceTokenAmount || "", onSelectToken: showFromTokenSelector, chain: fromChain, token: fromToken, isLoading: quoteQuery.isLoading && !sourceTokenAmount, client: client, freezeChainAndTokenSelection: disableTokenSelection, payerAccount: props.payer.account, swapRequired: swapRequired }), swapRequired && ((0, jsx_runtime_1.jsx)(EstimatedTimeAndFees_js_1.EstimatedTimeAndFees, { quoteIsLoading: quoteQuery.isLoading, estimatedSeconds: quoteQuery.data?.swapDetails.estimated.durationSeconds, onViewFees: showFees })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] }), errorMsg && ((0, jsx_runtime_1.jsxs)("div", { children: [errorMsg.minAmount && ((0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "danger", size: "sm", center: true, multiline: true, children: ["Minimum amount is ", errorMsg.minAmount, (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "danger" })] })), errorMsg.msg?.map((msg) => ((0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", center: true, multiline: true, children: msg }, msg)))] })), !errorMsg && isNotEnoughBalance && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", center: true, multiline: true, children: "Not enough funds." }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", center: true, multiline: true, children: "Try a different wallet or token." })] })), errorMsg?.minAmount ? ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, onClick: () => {
                    props.setTokenAmount(String(errorMsg.minAmount));
                    props.setHasEditedAmount(true);
                }, children: "Set Minimum" })) : switchChainRequired &&
                !quoteQuery.isLoading &&
                !isNotEnoughBalance &&
                !quoteQuery.error ? ((0, jsx_runtime_1.jsx)(SwitchNetwork_js_1.SwitchNetworkButton, { variant: "accent", fullWidth: true, switchChain: async () => {
                    await props.payer.wallet.switchChain(fromChain);
                } })) : ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: disableContinue ? "outline" : "accent", fullWidth: true, "data-disabled": disableContinue, disabled: disableContinue, onClick: async () => {
                    if (!disableContinue) {
                        showSwapFlow();
                    }
                }, gap: "xs", children: quoteQuery.isLoading ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Getting price quote", (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "accentText" })] })) : ("Continue") }))] }));
}
function FiatScreenContent(props) {
    const { toToken, tokenAmount, payer, client, setScreen, toChain, showCurrencySelector, selectedCurrency, } = props;
    const defaultRecipientAddress = props.payOptions?.paymentInfo?.sellerAddress;
    const receiverAddress = defaultRecipientAddress || props.payer.account.address;
    const { drawerRef, drawerOverlayRef, isOpen, setIsOpen } = (0, Drawer_js_1.useDrawer)();
    const [drawerScreen, setDrawerScreen] = (0, react_1.useState)("fees");
    const buyWithFiatOptions = props.payOptions.buyWithFiat;
    const fiatQuoteQuery = (0, useBuyWithFiatQuote_js_1.useBuyWithFiatQuote)(buyWithFiatOptions !== false && tokenAmount
        ? {
            fromCurrencySymbol: selectedCurrency.shorthand,
            toChainId: toChain.id,
            toAddress: receiverAddress,
            toTokenAddress: (0, nativeToken_js_1.isNativeToken)(toToken)
                ? addresses_js_1.NATIVE_TOKEN_ADDRESS
                : toToken.address,
            toAmount: tokenAmount,
            client,
            isTestMode: buyWithFiatOptions?.testMode,
            purchaseData: props.payOptions.purchaseData,
            fromAddress: payer.account.address,
            preferredProvider: buyWithFiatOptions?.preferredProvider,
        }
        : undefined);
    function handleSubmit() {
        if (!fiatQuoteQuery.data) {
            return;
        }
        const hasTwoSteps = (0, isSwapRequiredPostOnramp_js_1.isSwapRequiredPostOnramp)(fiatQuoteQuery.data);
        let openedWindow = null;
        if (!hasTwoSteps) {
            openedWindow = (0, openOnRamppopup_js_1.openOnrampPopup)(fiatQuoteQuery.data.onRampLink, typeof props.theme === "string" ? props.theme : props.theme.type);
            (0, pendingSwapTx_js_1.addPendingTx)({
                type: "fiat",
                intentId: fiatQuoteQuery.data.intentId,
            });
        }
        setScreen({
            id: "fiat-flow",
            quote: fiatQuoteQuery.data,
            openedWindow,
        });
    }
    function showFees() {
        if (!fiatQuoteQuery.data) {
            return;
        }
        setDrawerScreen("fees");
        setIsOpen(true);
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    function getErrorMessage(err) {
        const defaultMessage = "Unable to get price quote";
        try {
            if (err.error.code === "MINIMUM_PURCHASE_AMOUNT") {
                const obj = err.error;
                const minAmountToken = obj.data.minimumAmountEth;
                return {
                    minAmount: (0, formatNumber_js_1.formatNumber)(Number(minAmountToken), 6),
                };
            }
        }
        catch { }
        return {
            msg: [defaultMessage],
        };
    }
    const disableSubmit = !fiatQuoteQuery.data;
    const errorMsg = !fiatQuoteQuery.isLoading && fiatQuoteQuery.error
        ? getErrorMessage(fiatQuoteQuery.error)
        : undefined;
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "md", animate: "fadein", children: [isOpen && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Drawer_js_1.DrawerOverlay, { ref: drawerOverlayRef }), (0, jsx_runtime_1.jsx)(Drawer_js_1.Drawer, { ref: drawerRef, close: () => setIsOpen(false), children: drawerScreen === "fees" && fiatQuoteQuery.data && ((0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "lg", color: "primaryText", children: "Fees" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(Fees_js_1.FiatFees, { quote: fiatQuoteQuery.data })] })) })] })), (0, jsx_runtime_1.jsxs)("div", { children: [(0, jsx_runtime_1.jsx)(PayWIthCreditCard_js_1.PayWithCreditCard, { isLoading: fiatQuoteQuery.isLoading, value: fiatQuoteQuery.data?.fromCurrencyWithFees.amount, client: client, currency: selectedCurrency, onSelectCurrency: showCurrencySelector }), (0, jsx_runtime_1.jsx)(EstimatedTimeAndFees_js_1.EstimatedTimeAndFees, { quoteIsLoading: fiatQuoteQuery.isLoading, estimatedSeconds: fiatQuoteQuery.data?.estimatedDurationSeconds, onViewFees: showFees }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" })] }), errorMsg && ((0, jsx_runtime_1.jsxs)("div", { children: [errorMsg.minAmount && ((0, jsx_runtime_1.jsxs)(text_js_1.Text, { color: "danger", size: "sm", center: true, multiline: true, children: ["Minimum amount is ", errorMsg.minAmount, (0, jsx_runtime_1.jsx)(TokenSymbol_js_1.TokenSymbol, { token: toToken, chain: toChain, size: "sm", inline: true, color: "danger" })] })), errorMsg.msg?.map((msg) => ((0, jsx_runtime_1.jsx)(text_js_1.Text, { color: "danger", size: "sm", center: true, multiline: true, children: msg }, msg)))] })), errorMsg?.minAmount ? ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, onClick: () => {
                    props.setTokenAmount(String(errorMsg.minAmount));
                    props.setHasEditedAmount(true);
                }, children: "Set Minimum" })) : ((0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: disableSubmit ? "outline" : "accent", "data-disabled": disableSubmit, disabled: disableSubmit, fullWidth: true, onClick: handleSubmit, gap: "xs", children: fiatQuoteQuery.isLoading ? ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["Getting price quote", (0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "sm", color: "accentText" })] })) : ("Continue") }))] }));
}
function createSupportedTokens(data, payOptions, supportedTokensOverrides) {
    const tokens = {};
    const isBuyWithFiatDisabled = payOptions.buyWithFiat === false;
    const isBuyWithCryptoDisabled = payOptions.buyWithCrypto === false;
    // FIXME (pay) when buywithFiat is disabled, missing a bunch of tokens on base??
    for (const x of data) {
        tokens[x.chain.id] = x.tokens.filter((t) => {
            // it token supports both - include it
            if (t.buyWithCryptoEnabled && t.buyWithFiatEnabled) {
                return true;
            }
            // if buyWithFiat is disabled, and buyWithCrypto is not supported by token - exclude the token
            if (!t.buyWithCryptoEnabled && isBuyWithFiatDisabled) {
                return false;
            }
            // if buyWithCrypto is disabled, and buyWithFiat is not supported by token - exclude the token
            if (!t.buyWithFiatEnabled && isBuyWithCryptoDisabled) {
                return false;
            }
            return true; // include the token
        });
    }
    // override with props.supportedTokens
    if (supportedTokensOverrides) {
        for (const k in supportedTokensOverrides) {
            const key = Number(k);
            const tokenList = supportedTokensOverrides[key];
            if (tokenList) {
                tokens[key] = tokenList;
            }
        }
    }
    return tokens;
}
function ChainSelectionScreen(props) {
    return ((0, jsx_runtime_1.jsx)(NetworkSelector_js_1.NetworkSelectorContent, { client: props.client, connectLocale: props.connectLocale, showTabs: false, onBack: props.goBack, chains: props.chains, closeModal: props.goBack, networkSelector: {
            renderChain(renderChainProps) {
                return ((0, jsx_runtime_1.jsx)(NetworkSelector_js_1.ChainButton, { chain: renderChainProps.chain, confirming: false, switchingFailed: false, onClick: () => {
                        props.setChain(renderChainProps.chain);
                        props.goBack();
                    }, client: props.client, connectLocale: props.connectLocale }));
            },
        } }));
}
//# sourceMappingURL=BuyScreen.js.map