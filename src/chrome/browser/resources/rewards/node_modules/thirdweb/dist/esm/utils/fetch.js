import { version } from "../version.js";
import { LruMap } from "./caching/lru.js";
import { detectOS, detectPlatform, } from "./detect-platform.js";
import { isJWT } from "./jwt/is-jwt.js";
const DEFAULT_REQUEST_TIMEOUT = 60000;
/**
 * @internal
 */
export function getClientFetch(client, ecosystem) {
    /**
     * @internal
     */
    async function fetchWithHeaders(url, init) {
        const { requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT, ...restInit } = init || {};
        let headers = restInit.headers ? new Headers(restInit.headers) : undefined;
        // check if we are making a request to a thirdweb service (we don't want to send any headers to non-thirdweb services)
        if (isThirdwebUrl(url)) {
            if (!headers) {
                headers = new Headers();
            }
            // auth token if secret key === jwt
            const authToken = client.secretKey && isJWT(client.secretKey)
                ? client.secretKey
                : undefined;
            // secret key if secret key !== jwt
            const secretKey = client.secretKey && !isJWT(client.secretKey)
                ? client.secretKey
                : undefined;
            const clientId = client.clientId;
            // if we have an auth token set, use that (thirdweb.com/dashboard sets this for the user)
            // pay urls should never send the auth token, because we always want the "developer" to be the one making the request, not the "end user"
            if (authToken && !isPayUrl(url)) {
                headers.set("authorization", `Bearer ${authToken}`);
            }
            else if (secretKey) {
                headers.set("x-secret-key", secretKey);
            }
            else if (clientId) {
                headers.set("x-client-id", clientId);
            }
            if (ecosystem) {
                headers.set("x-ecosystem-id", ecosystem.id);
                if (ecosystem.partnerId) {
                    headers.set("x-ecosystem-partner-id", ecosystem.partnerId);
                }
            }
            // this already internally caches
            for (const [key, value] of getPlatformHeaders()) {
                headers.set(key, value);
            }
        }
        let controller;
        let abortTimeout;
        if (requestTimeoutMs) {
            controller = new AbortController();
            abortTimeout = setTimeout(() => {
                controller?.abort();
            }, requestTimeoutMs);
        }
        return fetch(url, {
            ...restInit,
            headers,
            signal: controller?.signal,
        }).finally(() => {
            if (abortTimeout) {
                clearTimeout(abortTimeout);
            }
        });
    }
    return fetchWithHeaders;
}
// NOTE: these all start with "." because we want to make sure we don't match (for example) "otherthirdweb.com"
const THIRDWEB_DOMAINS = [
    ".thirdweb.com",
    ".ipfscdn.io",
    // dev domains
    ".thirdweb.dev",
    ".thirdweb-dev.com",
];
export const IS_THIRDWEB_URL_CACHE = new LruMap(4096);
/**
 * @internal
 */
export function isThirdwebUrl(url) {
    if (IS_THIRDWEB_URL_CACHE.has(url)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return IS_THIRDWEB_URL_CACHE.get(url);
    }
    try {
        const { hostname } = new URL(url);
        try {
            // special case for localhost in development only
            if (process.env.NODE_ENV === "development" ||
                process.env.NODE_ENV === "test") {
                if (hostname === "localhost") {
                    IS_THIRDWEB_URL_CACHE.set(url, true);
                    return true;
                }
            }
        }
        catch { }
        const is = THIRDWEB_DOMAINS.some((domain) => hostname.endsWith(domain));
        IS_THIRDWEB_URL_CACHE.set(url, is);
        return is;
    }
    catch {
        IS_THIRDWEB_URL_CACHE.set(url, false);
        return false;
    }
}
function isPayUrl(url) {
    try {
        const { hostname } = new URL(url);
        // pay service hostname always starts with "pay."
        return hostname.startsWith("pay.");
    }
    catch {
        return false;
    }
}
const SDK_NAME = "unified-sdk";
let previousPlatform;
/**
 * @internal
 */
export function getPlatformHeaders() {
    if (previousPlatform) {
        return previousPlatform;
    }
    let os = null;
    if (typeof navigator !== "undefined") {
        os = detectOS(navigator.userAgent);
    }
    let bundleId = undefined;
    if (typeof globalThis !== "undefined" && "Application" in globalThis) {
        // shims use wallet connect RN module which injects Application info in globalThis
        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
        bundleId = globalThis.Application.applicationId;
    }
    previousPlatform = Object.entries({
        "x-sdk-platform": detectPlatform(),
        "x-sdk-version": version,
        "x-sdk-os": os ? parseOs(os) : "unknown",
        "x-sdk-name": SDK_NAME,
        ...(bundleId ? { "x-bundle-id": bundleId } : {}),
    });
    return previousPlatform;
}
/**
 * @internal
 */
function parseOs(os) {
    const osLowerCased = os.toLowerCase();
    if (osLowerCased.startsWith("win")) {
        return "win";
    }
    // we do NOT use the lowercase here
    switch (os) {
        case "Mac OS":
            return "mac";
        case "iOS":
            return "ios";
        case "Android OS":
            return "android";
        default:
            // if we somehow fall through here, just replace all spaces with underscores and send it
            return osLowerCased.replace(/\s/gi, "_");
    }
}
//# sourceMappingURL=fetch.js.map