"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClientFetch = getClientFetch;
exports.isThirdwebUrl = isThirdwebUrl;
exports.getPlatformHeaders = getPlatformHeaders;
const version_js_1 = require("../version.js");
const lru_js_1 = require("./caching/lru.js");
const detect_platform_js_1 = require("./detect-platform.js");
const DEFAULT_REQUEST_TIMEOUT = 60000;
const FETCH_CACHE = new WeakMap();
/**
 * @internal
 */
function getClientFetch(client, ecosystem) {
    if (FETCH_CACHE.has({ client, ecosystem })) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return FETCH_CACHE.get({ client, ecosystem });
    }
    /**
     * @internal
     */
    async function fetchWithHeaders(url, init) {
        const { requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT, ...restInit } = init || {};
        let headers = restInit.headers ? new Headers(restInit.headers) : undefined;
        // check if we are making a request to a thirdweb service (we don't want to send any headers to non-thirdweb services)
        if (isThirdwebUrl(url)) {
            if (!headers) {
                headers = new Headers();
            }
            const authToken = getTWAuthToken();
            // if we have an auth token set, use that (thirdweb.com/dashboard sets this for the user)
            // pay urls should never send the auth token, because we always want the "developer" to be the one making the request, not the "end user"
            if (authToken && !isPayUrl(url)) {
                headers.set("authorization", `Bearer ${authToken}`);
            }
            else if (client.secretKey) {
                headers.set("x-secret-key", client.secretKey);
            }
            else if (client.clientId) {
                headers.set("x-client-id", client.clientId);
            }
            if (ecosystem) {
                headers.set("x-ecosystem-id", ecosystem.id);
                if (ecosystem.partnerId) {
                    headers.set("x-ecosystem-partner-id", ecosystem.partnerId);
                }
            }
            // this already internally caches
            for (const [key, value] of getPlatformHeaders()) {
                headers.set(key, value);
            }
        }
        let controller;
        let abortTimeout;
        if (requestTimeoutMs) {
            controller = new AbortController();
            abortTimeout = setTimeout(() => {
                controller?.abort();
            }, requestTimeoutMs);
        }
        return fetch(url, {
            ...restInit,
            headers,
            signal: controller?.signal,
        }).finally(() => {
            if (abortTimeout) {
                clearTimeout(abortTimeout);
            }
        });
    }
    FETCH_CACHE.set({ client, ecosystem }, fetchWithHeaders);
    return fetchWithHeaders;
}
// NOTE: these all start with "." because we want to make sure we don't match (for example) "otherthirdweb.com"
const THIRDWEB_DOMAINS = [
    ".thirdweb.com",
    ".ipfscdn.io",
    // dev domains
    ".thirdweb.dev",
    ".thirdweb-dev.com",
];
const IS_THIRDWEB_URL_CACHE = new lru_js_1.LruMap(4096);
/**
 * @internal
 */
function isThirdwebUrl(url) {
    if (IS_THIRDWEB_URL_CACHE.has(url)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return IS_THIRDWEB_URL_CACHE.get(url);
    }
    try {
        const { hostname } = new URL(url);
        try {
            // special case for localhost in development only
            if (process.env.NODE_ENV === "development" ||
                process.env.NODE_ENV === "test") {
                if (hostname === "localhost") {
                    IS_THIRDWEB_URL_CACHE.set(url, true);
                    return true;
                }
            }
        }
        catch { }
        const is = THIRDWEB_DOMAINS.some((domain) => hostname.endsWith(domain));
        IS_THIRDWEB_URL_CACHE.set(url, is);
        return is;
    }
    catch {
        IS_THIRDWEB_URL_CACHE.set(url, false);
        return false;
    }
}
function isPayUrl(url) {
    try {
        const { hostname } = new URL(url);
        // pay service hostname always starts with "pay."
        return hostname.startsWith("pay.");
    }
    catch {
        return false;
    }
}
const SDK_NAME = "unified-sdk";
let previousPlatform;
/**
 * @internal
 */
function getPlatformHeaders() {
    if (previousPlatform) {
        return previousPlatform;
    }
    let os = null;
    if (typeof navigator !== "undefined") {
        os = (0, detect_platform_js_1.detectOS)(navigator.userAgent);
    }
    let bundleId = undefined;
    if (typeof globalThis !== "undefined" && "Application" in globalThis) {
        // shims use wallet connect RN module which injects Application info in globalThis
        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
        bundleId = globalThis.Application.applicationId;
    }
    previousPlatform = Object.entries({
        "x-sdk-platform": (0, detect_platform_js_1.detectPlatform)(),
        "x-sdk-version": version_js_1.version,
        "x-sdk-os": os ? parseOs(os) : "unknown",
        "x-sdk-name": SDK_NAME,
        ...(bundleId ? { "x-bundle-id": bundleId } : {}),
    });
    return previousPlatform;
}
/**
 * @internal
 */
function parseOs(os) {
    const osLowerCased = os.toLowerCase();
    if (osLowerCased.startsWith("win")) {
        return "win";
    }
    // we do NOT use the lowercase here
    switch (os) {
        case "Mac OS":
            return "mac";
        case "iOS":
            return "ios";
        case "Android OS":
            return "android";
        default:
            // if we somehow fall through here, just replace all spaces with underscores and send it
            return osLowerCased.replace(/\s/gi, "_");
    }
}
function getTWAuthToken() {
    if (typeof globalThis !== "undefined" &&
        "TW_AUTH_TOKEN" in globalThis &&
        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
        typeof globalThis.TW_AUTH_TOKEN === "string") {
        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
        return globalThis.TW_AUTH_TOKEN;
    }
    return null;
}
//# sourceMappingURL=fetch.js.map