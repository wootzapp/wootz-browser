"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setUpNewUserWallet = setUpNewUserWallet;
exports.storeShares = storeShares;
const secp256k1_1 = require("@noble/curves/secp256k1");
const utils_1 = require("viem/utils");
const hex_js_1 = require("../../../../../utils/encoding/hex.js");
const fetchers_js_1 = require("../api/fetchers.js");
const logout_js_1 = require("../auth/logout.js");
const constants_js_1 = require("../constants.js");
const errors_js_1 = require("../errors.js");
const local_js_1 = require("../storage/local.js");
const encryption_js_1 = require("./encryption.js");
async function setUpNewUserWallet(recoveryCode, client) {
    try {
        return await generateWallet({
            client,
            recoveryCode: recoveryCode,
        });
    }
    catch (e) {
        // we log user out so they aren't in the weird state where they are logged in but the wallet is not initialized
        await (0, logout_js_1.logoutUser)(client.clientId);
        throw new Error(`Error creating new ews account. Please try signing in again. Original Error: ${e}`);
    }
}
// Wallet Creation
async function generateWallet({ client, recoveryCode, }) {
    const walletDetails = await createWalletShares();
    const maybeDeviceShare = await storeShares({
        client,
        walletAddress: walletDetails.publicAddress,
        authShare: walletDetails.shares[constants_js_1.AUTH_SHARE_INDEX],
        deviceShare: walletDetails.shares[constants_js_1.DEVICE_SHARE_INDEX],
        recoveryShares: [
            {
                // biome-ignore lint/style/noNonNullAssertion: its there
                share: walletDetails.shares[constants_js_1.RECOVERY_SHARE_INDEX],
                recoveryCode,
            },
        ],
    });
    if (!maybeDeviceShare?.deviceShareStored) {
        throw new Error(constants_js_1.DEVICE_SHARE_MISSING_MESSAGE);
    }
    return {
        walletAddress: walletDetails.publicAddress,
        deviceShareStored: maybeDeviceShare?.deviceShareStored,
        isIframeStorageEnabled: false,
        recoveryCode,
    };
}
async function createWalletShares() {
    const privateKey = (0, hex_js_1.toHex)(secp256k1_1.secp256k1.utils.randomPrivateKey());
    const privateKeyHex = (0, hex_js_1.stringToHex)(`thirdweb_${privateKey}`).slice(2);
    const publicKey = (0, hex_js_1.toHex)(secp256k1_1.secp256k1.getPublicKey(privateKey.slice(2), false));
    const address = (0, utils_1.publicKeyToAddress)(publicKey);
    const sss = await Promise.resolve().then(() => require("./sss.js"));
    const [share1, share2, share3] = sss.secrets.share(privateKeyHex, 3, 2, undefined);
    if (!share1 || !share2 || !share3) {
        throw new Error("Error splitting private key into shares");
    }
    return {
        publicAddress: address,
        shares: [share1, share2, share3],
    };
}
/**
 * Store user's wallet shares. Encrypts authShare and recoveryShare as given clientSide as well.
 * @param walletAddress - the user's wallet address. Note that for each logged in user and clientId, we have a single walletAddress. This will error if we attempt to store shares for user's with an existing wallet different from the walletAddress
 * @param authShare - the *unencrypted* authShare for the user
 * @param recoveryShare - the *unencrypted* recovery share for the user
 * @throws if another walletAddress already exists
 */
async function storeShares({ client, walletAddress, authShare, deviceShare, recoveryShares, }) {
    let maybeEncryptedRecoveryShares;
    if (recoveryShares?.length) {
        maybeEncryptedRecoveryShares = await Promise.all(recoveryShares.map(async (recoveryShare) => {
            return {
                share: await (0, encryption_js_1.encryptShareWeb)(recoveryShare.share, recoveryShare.recoveryCode),
                isClientEncrypted: true,
            };
        }));
    }
    await (0, fetchers_js_1.storeUserShares)({
        authShare,
        client,
        maybeEncryptedRecoveryShares,
        walletAddress,
    });
    try {
        if (deviceShare) {
            const deviceShareStored = await (0, local_js_1.setDeviceShare)({
                deviceShare,
                clientId: client.clientId,
            });
            return { deviceShareStored };
        }
        return undefined;
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from the ews store user share API", e));
    }
}
//# sourceMappingURL=creation.js.map