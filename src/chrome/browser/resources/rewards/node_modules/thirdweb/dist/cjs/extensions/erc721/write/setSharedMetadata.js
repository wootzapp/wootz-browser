"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSetSharedMetadataSupported = void 0;
exports.setSharedMetadata = setSharedMetadata;
const setSharedMetadata_js_1 = require("../__generated__/ISharedMetadata/write/setSharedMetadata.js");
var setSharedMetadata_js_2 = require("../__generated__/ISharedMetadata/write/setSharedMetadata.js");
Object.defineProperty(exports, "isSetSharedMetadataSupported", { enumerable: true, get: function () { return setSharedMetadata_js_2.isSetSharedMetadataSupported; } });
/**
 * Sets the shared metadata for a OpenEdition contract.
 * @param options - The options for the transaction.
 * @returns The prepared transaction.
 * @extension ERC721
 */
function setSharedMetadata(options) {
    return (0, setSharedMetadata_js_1.setSharedMetadata)({
        contract: options.contract,
        asyncParams: async () => {
            if (!options.nft.name) {
                throw new Error("NFT name is required");
            }
            const batch = [
                // image URI resolution
                (async () => {
                    if (!options.nft.image) {
                        return "";
                    }
                    if (typeof options.nft.image === "string") {
                        return options.nft.image;
                    }
                    const { upload } = await Promise.resolve().then(() => require("../../../storage/upload.js"));
                    return await upload({
                        client: options.contract.client,
                        files: [options.nft.image],
                    });
                })(),
                // animation URI resolution
                (async () => {
                    if (!options.nft.animation_url) {
                        return "";
                    }
                    if (typeof options.nft.animation_url === "string") {
                        return options.nft.animation_url;
                    }
                    const { upload } = await Promise.resolve().then(() => require("../../../storage/upload.js"));
                    return await upload({
                        client: options.contract.client,
                        files: [options.nft.animation_url],
                    });
                })(),
            ];
            const [imageURI, animationURI] = await Promise.all(batch);
            return {
                metadata: {
                    name: options.nft.name,
                    description: sanitizeJSONString(options.nft.description) ?? "",
                    imageURI: imageURI ?? "",
                    animationURI: animationURI ?? "",
                },
            };
        },
    });
}
function sanitizeJSONString(val) {
    if (!val) {
        return val;
    }
    const sanitized = JSON.stringify(val);
    return sanitized.slice(1, sanitized.length - 1);
}
//# sourceMappingURL=setSharedMetadata.js.map