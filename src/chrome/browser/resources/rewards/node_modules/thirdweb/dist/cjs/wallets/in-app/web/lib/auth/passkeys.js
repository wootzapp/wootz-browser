"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasskeyWebClient = void 0;
exports.hasStoredPasskey = hasStoredPasskey;
const webauthn_1 = require("@passwordless-id/webauthn");
const webStorage_js_1 = require("../../../../../utils/storage/webStorage.js");
const uint8_array_js_1 = require("../../../../../utils/uint8-array.js");
const client_scoped_storage_js_1 = require("../../../core/authentication/client-scoped-storage.js");
class PasskeyWebClient {
    isAvailable() {
        return webauthn_1.client.isAvailable();
    }
    async register(args) {
        const { name, challenge, rp } = args;
        const registration = await webauthn_1.client.register(name, challenge, {
            authenticatorType: "auto",
            userVerification: "required",
            domain: rp.id,
            attestation: true,
            debug: false,
        });
        const clientDataB64 = (0, uint8_array_js_1.base64UrlToBase64)(registration.clientData);
        const clientDataParsed = JSON.parse((0, uint8_array_js_1.base64ToString)(clientDataB64));
        return {
            authenticatorData: registration.authenticatorData,
            credentialId: registration.credential.id,
            clientData: registration.clientData,
            credential: {
                publicKey: registration.credential.publicKey,
                algorithm: registration.credential.algorithm,
            },
            origin: clientDataParsed.origin,
        };
    }
    async authenticate(args) {
        const { credentialId, challenge, rp } = args;
        const result = await webauthn_1.client.authenticate(credentialId ? [credentialId] : [], challenge, {
            authenticatorType: "auto",
            userVerification: "required",
            domain: rp.id,
        });
        const clientDataB64 = (0, uint8_array_js_1.base64UrlToBase64)(result.clientData);
        const clientDataParsed = JSON.parse((0, uint8_array_js_1.base64ToString)(clientDataB64));
        return {
            authenticatorData: result.authenticatorData,
            credentialId: result.credentialId,
            clientData: result.clientData,
            signature: result.signature,
            origin: clientDataParsed.origin,
        };
    }
}
exports.PasskeyWebClient = PasskeyWebClient;
/**
 * Returns whether this device has a stored passkey ready to be used for sign-in
 * @param client - the thirdweb client
 * @returns whether the device has a stored passkey
 * @walletUtils
 */
async function hasStoredPasskey(client, ecosystemId) {
    const storage = new client_scoped_storage_js_1.ClientScopedStorage({
        storage: webStorage_js_1.webLocalStorage, // TODO (passkey) react native variant of this fn
        clientId: client.clientId,
        ecosystemId: ecosystemId,
    });
    const credId = await storage.getPasskeyCredentialId();
    return !!credId;
}
//# sourceMappingURL=passkeys.js.map