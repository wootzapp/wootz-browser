"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useContractEvents = useContractEvents;
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const get_events_js_1 = require("../../../../event/actions/get-events.js");
const watch_events_js_1 = require("../../../../event/actions/watch-events.js");
const eth_blockNumber_js_1 = require("../../../../rpc/actions/eth_blockNumber.js");
const rpc_js_1 = require("../../../../rpc/rpc.js");
/**
 * Watches contract events and returns the parsed logs.
 * @param options - The options for watching contract events.
 * @param options.contract - The contract to watch events for.
 * @param options.events - The events to watch. Shuould be an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).
 * @param options.blockRange - The number of blocks to search for events.
 * @param options.enabled - Whether to enable the query.
 * @param options.watch - Whether to watch for new events.
 * @returns The contract events of the watched contract events.
 * @example
 *
 * ### Using event extensions
 *
 * The `thirdweb/extesions` export contains event definitions for many popular contracts.
 * You can use these event definitions to watch for specific events with a type-safe API.
 *
 * ```jsx
 * import { useContractEvents } from "thirdweb/react";
 * import { tokensClaimedEvent } from "thirdweb/extensions/erc721";
 *
 * const account = useActiveAccount();
 * const contractEvents = useContractEvents({
 *  contract,
 *  events: [tokensClaimedEvent({ claimer: account?.address })],
 * });
 * ```
 *
 * ### Using custom events
 *
 * You can also watch for custom events by passing an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).
 *
 * ```jsx
 * import { useContractEvents } from "thirdweb/react";
 * import { prepareEvent } from "thirdweb";
 *
 * const myEvent = prepareEvent({
 *  signature: "event MyEvent(uint256 myArg)",
 * });
 *
 * const contractEvents = useContractEvents({
 *  contract,
 *  events: [myEvent],
 * });
 * ```
 *
 * @contract
 */
function useContractEvents(options) {
    const { contract, events, blockRange = 2000, enabled = true, watch = true, } = options;
    const latestBlockNumber = (0, react_1.useRef)(); // We use this to keep track of the latest block number when new pollers are spawned
    const queryClient = (0, react_query_1.useQueryClient)();
    const eventsKey = (0, react_1.useMemo)(() => events?.reduce((acc, curr) => {
        // we can use the event hash as a unique identifier?
        return `${acc}${curr.hash}_`;
    }, "") || "__all__", [events]);
    const queryKey = (0, react_1.useMemo)(() => [contract.chain.id, contract.address, "logs", eventsKey], [contract.address, contract.chain, eventsKey]);
    const query = (0, react_query_1.useQuery)({
        queryKey,
        queryFn: async () => {
            const rpcRequest = (0, rpc_js_1.getRpcClient)(contract);
            const currentBlockNumber = await (0, eth_blockNumber_js_1.eth_blockNumber)(rpcRequest);
            latestBlockNumber.current = currentBlockNumber;
            const initialEvents = await (0, get_events_js_1.getContractEvents)({
                contract,
                events: events,
                fromBlock: currentBlockNumber - BigInt(blockRange),
            });
            return initialEvents;
        },
        enabled,
    });
    (0, react_1.useEffect)(() => {
        if (!enabled || !watch) {
            // don't watch if not enabled or if watch is false
            return;
        }
        // the return is important here because it will unwatch the events
        return (0, watch_events_js_1.watchContractEvents)({
            contract,
            onEvents: (newEvents) => {
                if (newEvents.length > 0 && newEvents[0]) {
                    latestBlockNumber.current = newEvents[0].blockNumber; // Update the latest block number to avoid duplicate events if a new poller is spawned during this block
                }
                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
                queryClient.setQueryData(queryKey, (oldEvents = []) => [
                    ...oldEvents,
                    ...newEvents,
                ]);
            },
            events,
            latestBlockNumber: latestBlockNumber.current,
        });
    }, [contract, enabled, events, queryClient, queryKey, watch]);
    return query;
}
//# sourceMappingURL=useContractEvents.js.map