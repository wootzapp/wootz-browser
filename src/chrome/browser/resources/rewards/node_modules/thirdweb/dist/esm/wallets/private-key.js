import { secp256k1 } from "@noble/curves/secp256k1";
import { publicKeyToAddress } from "viem/utils";
import { getCachedChain } from "../chains/utils.js";
import { eth_sendRawTransaction } from "../rpc/actions/eth_sendRawTransaction.js";
import { getRpcClient } from "../rpc/rpc.js";
import { signTransaction } from "../transaction/actions/sign-transaction.js";
import { toHex } from "../utils/encoding/hex.js";
import { signMessage } from "../utils/signatures/sign-message.js";
import { signTypedData } from "../utils/signatures/sign-typed-data.js";
/**
 * Get an `Account` object from a private key.
 * @param options - The options for `privateKeyToAccount`
 * Refer to the type [`PrivateKeyToAccountOptions`](https://portal.thirdweb.com/references/typescript/v5/PrivateKeyToAccountOptions)
 * @returns The `Account` object that represents the private key
 * @example
 * ```ts
 * import { privateKeyToAccount } from "thirdweb/wallets"
 *
 * const wallet = privateKeyToAccount({
 *  client,
 *  privateKey: "...",
 * });
 * ```
 * @wallet
 */
export function privateKeyToAccount(options) {
    const { client } = options;
    const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
    const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
    const address = publicKeyToAddress(publicKey); // TODO: Implement publicKeyToAddress natively (will need checksumAddress downstream)
    const account = {
        address,
        sendTransaction: async (
        // TODO: figure out how we would pass our "chain" object in here?
        // maybe we *do* actually have to take in a tx object instead of the raw tx?
        tx) => {
            const rpcRequest = getRpcClient({
                client: client,
                chain: getCachedChain(tx.chainId),
            });
            const signedTx = signTransaction({
                transaction: tx,
                privateKey,
            });
            const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
            return {
                transactionHash,
            };
        },
        signMessage: async ({ message }) => {
            return signMessage({
                message,
                privateKey,
            });
        },
        signTypedData: async (_typedData) => {
            return signTypedData({
                ..._typedData,
                privateKey,
            });
        },
        signTransaction: async (tx) => {
            return signTransaction({
                transaction: tx,
                privateKey,
            });
        },
    };
    return account;
}
//# sourceMappingURL=private-key.js.map