import { cacheChains } from "../../chains/utils.js";
import { hasSmartAccount } from "../../react/core/utils/isSmartWallet.js";
import { computedStore } from "../../reactive/computedStore.js";
import { effect } from "../../reactive/effect.js";
import { createStore } from "../../reactive/store.js";
import { deleteConnectParamsFromStorage } from "../../utils/storage/walletStorage.js";
import { smartWallet } from "../smart/smart-wallet.js";
const CONNECTED_WALLET_IDS = "thirdweb:connected-wallet-ids";
const LAST_ACTIVE_EOA_ID = "thirdweb:active-wallet-id";
const LAST_ACTIVE_CHAIN = "thirdweb:active-chain";
/**
 * Create a connection manager for Wallet connections
 * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)
 * @example
 * ```ts
 * const manager = createConnectionManager();
 * ```
 * @returns A connection manager object
 * @walletUtils
 */
export function createConnectionManager(storage) {
    // stores
    // active wallet/account
    const activeWalletStore = createStore(undefined);
    const activeAccountStore = createStore(undefined);
    const activeWalletChainStore = createStore(undefined);
    const activeWalletConnectionStatusStore = createStore("disconnected");
    const definedChainsStore = createStore(new Map());
    // update global cachedChains when defined Chains store updates
    effect(() => {
        cacheChains([...definedChainsStore.getValue().values()]);
    }, [definedChainsStore]);
    // change the active chain object to use the defined chain object
    effect(() => {
        const chainVal = activeWalletChainStore.getValue();
        if (!chainVal) {
            return;
        }
        const definedChain = definedChainsStore.getValue().get(chainVal.id);
        if (!definedChain || definedChain === chainVal) {
            return;
        }
        // update active chain store
        activeWalletChainStore.setValue(definedChain);
    }, [definedChainsStore, activeWalletChainStore]);
    // other connected accounts
    const walletIdToConnectedWalletMap = createStore(new Map());
    const isAutoConnecting = createStore(false);
    const connectedWallets = computedStore(() => {
        return Array.from(walletIdToConnectedWalletMap.getValue().values());
    }, [walletIdToConnectedWalletMap]);
    // actions
    const addConnectedWallet = (wallet) => {
        const oldValue = walletIdToConnectedWalletMap.getValue();
        if (oldValue.has(wallet.id)) {
            return;
        }
        const newValue = new Map(oldValue);
        newValue.set(wallet.id, wallet);
        walletIdToConnectedWalletMap.setValue(newValue);
    };
    const removeConnectedWallet = (wallet) => {
        const oldValue = walletIdToConnectedWalletMap.getValue();
        const newValue = new Map(oldValue);
        newValue.delete(wallet.id);
        walletIdToConnectedWalletMap.setValue(newValue);
    };
    const onWalletDisconnect = (wallet) => {
        deleteConnectParamsFromStorage(storage, wallet.id);
        removeConnectedWallet(wallet);
        // if disconnecting the active wallet
        if (activeWalletStore.getValue() === wallet) {
            storage.removeItem(LAST_ACTIVE_EOA_ID);
            activeAccountStore.setValue(undefined);
            activeWalletChainStore.setValue(undefined);
            activeWalletStore.setValue(undefined);
            activeWalletConnectionStatusStore.setValue("disconnected");
        }
    };
    const disconnectWallet = (wallet) => {
        onWalletDisconnect(wallet);
        wallet.disconnect();
    };
    // handle the connection logic, but don't set the wallet as active
    const handleConnection = async (wallet, options) => {
        const account = wallet.getAccount();
        if (!account) {
            throw new Error("Can not set a wallet without an account as active");
        }
        const personalWallet = wallet;
        let activeWallet = personalWallet;
        const isInAppSmartAccount = hasSmartAccount(wallet);
        if (options?.accountAbstraction && !isInAppSmartAccount) {
            activeWallet = smartWallet(options.accountAbstraction);
            await activeWallet.connect({
                personalAccount: wallet.getAccount(),
                client: options.client,
            });
        }
        // add personal wallet to connected wallets list
        addConnectedWallet(personalWallet);
        if (personalWallet.id !== "smart") {
            await storage.setItem(LAST_ACTIVE_EOA_ID, personalWallet.id);
        }
        return activeWallet;
    };
    const connect = async (wallet, options) => {
        // connectedWallet can be either wallet or smartWallet based on
        const connectedWallet = await handleConnection(wallet, options);
        options?.onConnect?.(connectedWallet);
        handleSetActiveWallet(connectedWallet);
        wallet.subscribe("accountChanged", async () => {
            const newConnectedWallet = await handleConnection(wallet, options);
            options?.onConnect?.(newConnectedWallet);
            handleSetActiveWallet(newConnectedWallet);
        });
        return connectedWallet;
    };
    const handleSetActiveWallet = (activeWallet) => {
        const account = activeWallet.getAccount();
        if (!account) {
            throw new Error("Can not set a wallet without an account as active");
        }
        // also add it to connected wallets if it's not already there
        addConnectedWallet(activeWallet);
        // update active states
        activeWalletStore.setValue(activeWallet);
        activeAccountStore.setValue(account);
        activeWalletChainStore.setValue(activeWallet.getChain());
        activeWalletConnectionStatusStore.setValue("connected");
        // setup listeners
        const onAccountsChanged = (newAccount) => {
            activeAccountStore.setValue(newAccount);
        };
        const unsubAccounts = activeWallet.subscribe("accountChanged", onAccountsChanged);
        const unsubChainChanged = activeWallet.subscribe("chainChanged", (chain) => activeWalletChainStore.setValue(chain));
        const unsubDisconnect = activeWallet.subscribe("disconnect", () => {
            handleDisconnect();
        });
        const handleDisconnect = () => {
            onWalletDisconnect(activeWallet);
            unsubAccounts();
            unsubChainChanged();
            unsubDisconnect();
        };
    };
    const setActiveWallet = async (activeWallet) => {
        handleSetActiveWallet(activeWallet);
        // do not set smart wallet as last active EOA
        if (activeWallet.id !== "smart") {
            await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);
        }
    };
    // side effects
    effect(() => {
        const _chain = activeWalletChainStore.getValue();
        if (_chain) {
            storage.setItem(LAST_ACTIVE_CHAIN, JSON.stringify(_chain));
        }
        else {
            storage.removeItem(LAST_ACTIVE_CHAIN);
        }
    }, [activeWalletChainStore], false);
    // save last connected wallet ids to storage
    effect(() => {
        const accounts = connectedWallets.getValue();
        const ids = accounts.map((acc) => acc?.id).filter((c) => !!c);
        storage.setItem(CONNECTED_WALLET_IDS, JSON.stringify(ids));
    }, [connectedWallets], false);
    const switchActiveWalletChain = async (chain) => {
        const wallet = activeWalletStore.getValue();
        if (!wallet) {
            throw new Error("no wallet found");
        }
        if (!wallet.switchChain) {
            throw new Error("wallet does not support switching chains");
        }
        if (wallet.id === "smart") {
            // also switch personal wallet
            const personalWalletId = await getStoredActiveWalletId(storage);
            if (personalWalletId) {
                const personalWallet = connectedWallets
                    .getValue()
                    .find((w) => w.id === personalWalletId);
                if (personalWallet) {
                    await personalWallet.switchChain(chain);
                }
            }
            await wallet.switchChain(chain);
            // reset the active wallet as switch chain recreates a new smart account
            handleSetActiveWallet(wallet);
        }
        else {
            await wallet.switchChain(chain);
        }
        // for wallets that dont implement events, just set it manually
        activeWalletChainStore.setValue(wallet.getChain());
    };
    function defineChains(chains) {
        const currentMapVal = definedChainsStore.getValue();
        // if all chains to be defined are already defined, no need to update the definedChains map
        const allChainsSame = chains.every((c) => {
            const definedChain = currentMapVal.get(c.id);
            // basically a deep equal check
            return JSON.stringify(definedChain) === JSON.stringify(c);
        });
        if (allChainsSame) {
            return;
        }
        const newMapVal = new Map(currentMapVal);
        for (const c of chains) {
            newMapVal.set(c.id, c);
        }
        definedChainsStore.setValue(newMapVal);
    }
    return {
        activeWalletStore,
        activeAccountStore,
        connectedWallets,
        addConnectedWallet,
        disconnectWallet,
        setActiveWallet,
        connect,
        handleConnection,
        activeWalletChainStore,
        switchActiveWalletChain,
        activeWalletConnectionStatusStore,
        isAutoConnecting,
        removeConnectedWallet,
        defineChains,
    };
}
/**
 *
 * @internal
 */
export async function getStoredConnectedWalletIds(storage) {
    try {
        const value = await storage.getItem(CONNECTED_WALLET_IDS);
        if (value) {
            return JSON.parse(value);
        }
        return [];
    }
    catch {
        return [];
    }
}
/**
 * @internal
 */
export async function getStoredActiveWalletId(storage) {
    try {
        const value = await storage.getItem(LAST_ACTIVE_EOA_ID);
        if (value) {
            return value;
        }
        return null;
    }
    catch {
        return null;
    }
}
/**
 * @internal
 */
export async function getLastConnectedChain(storage) {
    try {
        const value = await storage.getItem(LAST_ACTIVE_CHAIN);
        if (value) {
            return JSON.parse(value);
        }
        return null;
    }
    catch {
        return null;
    }
}
//# sourceMappingURL=index.js.map