"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasskeyNativeClient = void 0;
exports.hasStoredPasskey = hasStoredPasskey;
const react_native_passkey_1 = require("react-native-passkey");
const viem_1 = require("viem");
const to_bytes_js_1 = require("../../../../utils/encoding/to-bytes.js");
const keccak256_js_1 = require("../../../../utils/hashing/keccak256.js");
const nativeStorage_js_1 = require("../../../../utils/storage/nativeStorage.js");
const uint8_array_js_1 = require("../../../../utils/uint8-array.js");
const client_scoped_storage_js_1 = require("../../core/authentication/client-scoped-storage.js");
class PasskeyNativeClient {
    isAvailable() {
        return react_native_passkey_1.Passkey.isSupported();
    }
    async register(args) {
        const { name, challenge, rp } = args;
        const result = await react_native_passkey_1.Passkey.create({
            challenge,
            user: {
                displayName: name,
                name: name,
                id: (0, keccak256_js_1.keccak256)((0, to_bytes_js_1.toBytes)(name)),
            },
            authenticatorSelection: {
                authenticatorAttachment: "platform",
                residentKey: "required",
                userVerification: "required",
                requireResidentKey: true,
            },
            rp,
            pubKeyCredParams: [
                {
                    alg: -7,
                    type: "public-key",
                },
            ],
        });
        const parsedResult = typeof result === "string" ? JSON.parse(result) : result;
        const { publicKey, authData } = await extractPublicKeyAndAuthData(parsedResult.response);
        const clientDataB64 = (0, uint8_array_js_1.base64UrlToBase64)(parsedResult.response.clientDataJSON);
        const clientDataParsed = JSON.parse((0, uint8_array_js_1.base64ToString)(clientDataB64));
        return {
            authenticatorData: authData,
            credentialId: parsedResult.id,
            clientData: clientDataB64,
            credential: {
                publicKey,
                algorithm: "ES256",
            },
            origin: clientDataParsed.origin,
        };
    }
    async authenticate(args) {
        const { credentialId, challenge, rp } = args;
        const result = await react_native_passkey_1.Passkey.get({
            challenge,
            rpId: rp.id,
            allowCredentials: credentialId
                ? [
                    {
                        id: credentialId,
                        type: "public-key",
                        // biome-ignore lint/suspicious/noExplicitAny: enum not exported
                        transports: ["hybrid"],
                    },
                ]
                : [],
        });
        const parsedResult = typeof result === "string" ? JSON.parse(result) : result;
        const clientDataB64 = (0, uint8_array_js_1.base64UrlToBase64)(parsedResult.response.clientDataJSON);
        const clientDataParsed = JSON.parse((0, uint8_array_js_1.base64ToString)(clientDataB64));
        return {
            authenticatorData: parsedResult.response.authenticatorData,
            credentialId: parsedResult.id,
            clientData: clientDataB64,
            signature: parsedResult.response.signature,
            origin: clientDataParsed.origin,
        };
    }
}
exports.PasskeyNativeClient = PasskeyNativeClient;
/**
 * Returns whether this device has a stored passkey ready to be used for sign-in
 * @param client - the thirdweb client
 * @returns whether the device has a stored passkey
 * @walletUtils
 */
async function hasStoredPasskey(client, ecosystemId) {
    const storage = new client_scoped_storage_js_1.ClientScopedStorage({
        storage: nativeStorage_js_1.nativeLocalStorage,
        clientId: client.clientId,
        ecosystemId: ecosystemId,
    });
    const credId = await storage.getPasskeyCredentialId();
    return !!credId;
}
async function extractPublicKeyAndAuthData(response) {
    const { decode } = await Promise.resolve().then(() => require("../../../../utils/bytecode/cbor-decode.js"));
    const { attestationObject } = response;
    const attestationBase64 = (0, uint8_array_js_1.base64UrlToBase64)(attestationObject);
    // Decode the attestationObject from base64url
    const attestationBytes = (0, uint8_array_js_1.base64ToUint8Array)(attestationBase64);
    const decodedAttestationObject = decode(attestationBytes);
    // Extract the authenticator data (authData) from the attestation object
    const authData = Uint8Array.from(decodedAttestationObject.authData);
    const decoded = decodeAuthData(authData);
    if (!decoded.publicKey) {
        throw new Error("No public key found");
    }
    const coseKey = decode(decoded.publicKey);
    // convert to PEM format
    const x = Uint8Array.from(coseKey[-2]); // x coordinate
    const y = Uint8Array.from(coseKey[-3]); // y coordinate
    // Concatenate x and y coordinates with the uncompressed point indicator (0x04)
    const pubKey = (0, viem_1.concat)([
        Uint8Array.from([
            // ASN.1 DER encoding, aka X.690 ... https://en.wikipedia.org/wiki/X.690
            0x30, // DER Sequence
            0x59, // Length (2+19 + 2+66) = 89
            0x30, // DER Sequence
            0x13, // Length (2+7 + 2+8) = 19
            0x06, // DER OBJECT IDENTIFIER
            0x07, // Length
            0x2a,
            0x86,
            0x48,
            0xce,
            0x3d,
            0x02,
            0x01, // OID 1.2.840.10045.2.1 ecPublicKey
            0x06, // DER OBJECT IDENTIFIER
            0x08, // Length
            0x2a,
            0x86,
            0x48,
            0xce,
            0x3d,
            0x03,
            0x01,
            0x07, // OID 1.2.840.10045.3.1.7 prime256v1
            0x03, // DER BIT STRING
            0x42, // Length (32 + 32 + 1(null) + 1) = 66
            0x00,
            0x04, // ECC uncompressed... beginning of X9.62 Key
        ]), // Uncompressed point indicator
        x,
        y,
    ]);
    return {
        publicKey: (0, uint8_array_js_1.uint8ArrayToBase64)(pubKey),
        authData: (0, uint8_array_js_1.uint8ArrayToBase64)(authData),
    };
}
function decodeAuthData(authData) {
    let offset = 0;
    // Step 1: Read the RP ID hash (32 bytes)
    const rpIdHash = authData.slice(offset, offset + 32);
    offset += 32;
    // Step 2: Read the flags (1 byte)
    const flags = authData[offset];
    offset += 1;
    if (!flags) {
        throw new Error("No flags found");
    }
    // Step 3: Read the sign count (4 bytes)
    const signCount = authData.slice(offset, offset + 4);
    offset += 4;
    // Step 4: Check if attested credential data is present
    const attestedCredentialDataPresent = (flags & 0x40) !== 0;
    let aaguid;
    let credentialIdLength;
    let credentialId;
    let publicKey;
    if (attestedCredentialDataPresent) {
        // Step 5: Read AAGUID (16 bytes)
        aaguid = authData.slice(offset, offset + 16);
        offset += 16;
        const start = authData[offset];
        const end = authData[offset + 1];
        if (start === undefined || end === undefined) {
            throw new Error("No credential ID found");
        }
        // Step 6: Read Credential ID Length (2 bytes)
        credentialIdLength = (start << 8) + end;
        offset += 2;
        // Step 7: Read Credential ID (variable length)
        credentialId = authData.slice(offset, offset + credentialIdLength);
        offset += credentialIdLength;
        // Step 8: Read Public Key (variable length, COSE-encoded)
        publicKey = authData.slice(offset); // The rest is the public key
        offset += publicKey.length;
    }
    return {
        rpIdHash,
        flags,
        signCount,
        aaguid,
        credentialIdLength,
        credentialId,
        publicKey,
    };
}
//# sourceMappingURL=passkeys.js.map