import { NATIVE_TOKEN_ADDRESS, isNativeTokenAddress, } from "../../../constants/addresses.js";
import { dateToSeconds, tenYearsFromNow } from "../../../utils/date.js";
import { isHex, stringToHex } from "../../../utils/encoding/hex.js";
import { randomBytesHex } from "../../../utils/random.js";
import { name } from "../../common/read/name.js";
import { mintWithSignature as generatedMintWithSignature, } from "../__generated__/ISignatureMintERC20/write/mintWithSignature.js";
/**
 * Mints a new ERC20 token with the given minter signature
 * @param options - The transaction options.
 * @extension ERC20
 * @example
 * ```ts
 * import { mintWithSignature, generateMintSignature } from "thirdweb/extensions/erc20";
 * import { sendTransaction } from "thirdweb";
 *
 * const { payload, signature } = await generateMintSignature(...)
 *
 * const transaction = mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 *
 * await sendTransaction({ transaction, account });
 * ```
 * @extension ERC20
 * @returns A promise that resolves to the transaction result.
 */
export function mintWithSignature(options) {
    const value = isNativeTokenAddress(options.payload.currency)
        ? options.payload.price
        : 0n;
    const erc20Value = !isNativeTokenAddress(options.payload.currency) &&
        options.payload.price > 0n
        ? {
            amountWei: options.payload.price,
            tokenAddress: options.payload.currency,
        }
        : undefined;
    return generatedMintWithSignature({
        ...options,
        overrides: {
            value,
            erc20Value,
        },
    });
}
/**
 * Generates the payload and signature for minting an ERC20 token.
 * @param options - The options for the minting process.
 * @example
 * ```ts
 * import { mintWithSignature, generateMintSignature } from "thirdweb/extensions/erc20";
 *
 * const { payload, signature } = await generateMintSignature({
 *   account,
 *   contract,
 *   mintRequest: {
 *     to: "0x...",
 *     quantity: "10",
 *   },
 * });
 *
 * const transaction = mintWithSignature({
 *   contract,
 *   payload,
 *   signature,
 * });
 * await sendTransaction({ transaction, account });
 * ```
 * @extension ERC20
 * @returns A promise that resolves to the payload and signature.
 */
export async function generateMintSignature(options) {
    const { mintRequest, account, contract } = options;
    const currency = mintRequest.currency || NATIVE_TOKEN_ADDRESS;
    const [price, quantity, uid, tokenName] = await Promise.all([
        // price per token in wei
        (async () => {
            // if priceInWei is provided, use it
            if ("priceInWei" in mintRequest && mintRequest.priceInWei) {
                return mintRequest.priceInWei;
            }
            // if price is provided, convert it to wei
            if ("price" in mintRequest && mintRequest.price) {
                const { convertErc20Amount } = await import("../../../utils/extensions/convert-erc20-amount.js");
                return await convertErc20Amount({
                    amount: mintRequest.price,
                    client: contract.client,
                    chain: contract.chain,
                    erc20Address: currency,
                });
            }
            // if neither price nor priceInWei is provided, default to 0
            return 0n;
        })(),
        // quantity in wei
        (async () => {
            // if the quantity is already passed in wei, use it
            if ("quantityWei" in mintRequest) {
                return mintRequest.quantityWei;
            }
            // otherwise convert the quantity to wei using the contract's OWN decimals
            const { convertErc20Amount } = await import("../../../utils/extensions/convert-erc20-amount.js");
            return await convertErc20Amount({
                amount: mintRequest.quantity,
                client: contract.client,
                chain: contract.chain,
                erc20Address: contract.address,
            });
        })(),
        (() => {
            if (mintRequest.uid) {
                return isHex(mintRequest.uid)
                    ? mintRequest.uid
                    : stringToHex(mintRequest.uid, { size: 32 });
            }
            return randomBytesHex();
        })(),
        // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.
        // it uses the token name in the domain separator
        name({
            contract,
        }),
    ]);
    const startTime = mintRequest.validityStartTimestamp || new Date(0);
    const endTime = mintRequest.validityEndTimestamp || tenYearsFromNow();
    const payload = {
        price,
        quantity,
        uid,
        currency,
        to: mintRequest.to,
        primarySaleRecipient: mintRequest.primarySaleRecipient || account.address,
        validityStartTimestamp: dateToSeconds(startTime),
        validityEndTimestamp: dateToSeconds(endTime),
    };
    const signature = await account.signTypedData({
        domain: {
            name: tokenName,
            version: "1",
            chainId: contract.chain.id,
            verifyingContract: contract.address,
        },
        types: { MintRequest: MintRequest20 },
        primaryType: "MintRequest",
        message: payload,
    });
    return { payload, signature };
}
const MintRequest20 = [
    { name: "to", type: "address" },
    { name: "primarySaleRecipient", type: "address" },
    { name: "quantity", type: "uint256" },
    { name: "price", type: "uint256" },
    { name: "currency", type: "address" },
    { name: "validityStartTimestamp", type: "uint128" },
    { name: "validityEndTimestamp", type: "uint128" },
    { name: "uid", type: "bytes32" },
];
//# sourceMappingURL=sigMint.js.map