"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeMintParams = void 0;
exports.mint = mint;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../constants/addresses.js");
const download_js_1 = require("../../../storage/download.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const encodeBytesBeforeMintERC20_js_1 = require("../__generated__/ClaimableERC20/encode/encodeBytesBeforeMintERC20.js");
const mint_js_1 = require("../__generated__/ERC20Core/write/mint.js");
/**
 * Mints tokens to a specified address via a ClaimableERC20 module.
 * @param options The options for minting tokens.
 * @returns A transaction to mint tokens.
 * @example
 * ```typescript
 * import { ClaimableERC20 } from "thirdweb/modules";
 *
 * const transaction = ClaimableERC20.mint({
 *   contract,
 *   to: "0x...", // Address to mint tokens to
 *   quantity: "0.1", // Amount of tokens to mint (in decimals)
 * });
 *
 * // Send the transaction
 * await sendTransaction({ transaction, account });
 * ```
 * @modules ClaimableERC20
 */
function mint(options) {
    return (0, mint_js_1.mint)({
        contract: options.contract,
        asyncParams: async () => {
            let amount = 0n;
            const [{ convertErc20Amount }, { getClaimCondition }, { decimals }] = await Promise.all([
                Promise.resolve().then(() => require("../../../utils/extensions/convert-erc20-amount.js")),
                Promise.resolve().then(() => require("../__generated__/ClaimableERC20/read/getClaimCondition.js")),
                Promise.resolve().then(() => require("../../erc20/read/decimals.js")),
            ]);
            amount = await convertErc20Amount({
                amount: options.quantity.toString(),
                client: options.contract.client,
                chain: options.contract.chain,
                erc20Address: options.contract.address,
            });
            const [cc, tokenDecimals] = await Promise.all([
                getClaimCondition({ contract: options.contract }),
                decimals({ contract: options.contract }),
            ]);
            const totalPrice = (cc.pricePerUnit * amount) / BigInt(10 ** tokenDecimals);
            const value = (0, addresses_js_1.isNativeTokenAddress)(cc.currency) ? totalPrice : 0n;
            const erc20Value = !(0, addresses_js_1.isNativeTokenAddress)(cc.currency) && cc.pricePerUnit > 0n
                ? {
                    amountWei: totalPrice,
                    tokenAddress: cc.currency,
                }
                : undefined;
            let recipientAllowlistProof = [];
            if (cc.allowlistMerkleRoot &&
                cc.allowlistMerkleRoot !== (0, hex_js_1.padHex)("0x", { size: 32 })) {
                const { fetchProofsForClaimer } = await Promise.resolve().then(() => require("../../../utils/extensions/drops/fetch-proofs-for-claimers.js"));
                const metadataUri = cc.auxData;
                if (metadataUri) {
                    // download merkle tree from metadata
                    const metadata = await (0, download_js_1.download)({
                        client: options.contract.client,
                        uri: metadataUri,
                    });
                    const metadataJson = await metadata.json();
                    const merkleTreeUri = metadataJson.merkleTreeUri;
                    // fetch proofs
                    if (merkleTreeUri) {
                        const allowlistProof = await fetchProofsForClaimer({
                            contract: options.contract,
                            claimer: options.to,
                            merkleTreeUri,
                            tokenDecimals,
                            async hashEntry(options) {
                                return (0, viem_1.keccak256)((0, viem_1.encodePacked)(["address"], [(0, viem_1.getAddress)(options.entry.address)]));
                            },
                        });
                        recipientAllowlistProof = allowlistProof?.proof || [];
                    }
                }
            }
            return {
                to: (0, viem_1.getAddress)(options.to),
                amount,
                data: (0, encodeBytesBeforeMintERC20_js_1.encodeBytesBeforeMintERC20Params)({
                    params: {
                        currency: cc.currency,
                        pricePerUnit: cc.pricePerUnit,
                        recipientAllowlistProof,
                    },
                }),
                overrides: {
                    value,
                    erc20Value,
                },
            };
        },
    });
}
exports.encodeMintParams = encodeBytesBeforeMintERC20_js_1.encodeBytesBeforeMintERC20Params;
//# sourceMappingURL=mint.js.map