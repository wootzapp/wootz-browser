"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimButton = ClaimButton;
exports.getERC721ClaimTo = getERC721ClaimTo;
exports.getERC1155ClaimTo = getERC1155ClaimTo;
exports.getERC20ClaimTo = getERC20ClaimTo;
const jsx_runtime_1 = require("react/jsx-runtime");
const contract_js_1 = require("../../../../../../contract/contract.js");
const getContractMetadata_js_1 = require("../../../../../../extensions/common/read/getContractMetadata.js");
const getNFT_js_1 = require("../../../../../../extensions/erc1155/read/getNFT.js");
const useReadContract_js_1 = require("../../../../../core/hooks/contract/useReadContract.js");
const useSendAndConfirmTransaction_js_1 = require("../../../../../core/hooks/transaction/useSendAndConfirmTransaction.js");
const useActiveAccount_js_1 = require("../../../../../core/hooks/wallets/useActiveAccount.js");
const index_js_1 = require("../../../TransactionButton/index.js");
/**
 * This button is used to claim tokens (NFT or ERC20) from a given thirdweb Drop contract.
 *
 * there are 3 type of Drop contract: NFT Drop (DropERC721), Edition Drop (DropERC1155) and Token Drop (DropERC20)
 *
 * Learn more: https://thirdweb.com/explore/drops
 *
 *
 * Note: This button only works with thirdweb Drop contracts.
 * For custom contract, please use [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)
 * @param props
 * @returns A wrapper for TransactionButton
 *
 * @component
 * @example
 *
 * Example for claiming NFT from an NFT Drop contract
 * ```tsx
 * import { ClaimButton } from "thirdweb/react";
 * import { ethereum } from "thirdweb/chains";
 *
 * <ClaimButton
 *   contractAddress="0x..." // contract address of the NFT Drop
 *   chain={ethereum}
 *   client={client}
 *   claimParams={{
 *     type: "ERC721",
 *     quantity: 1n, // claim 1 token
 *   }}
 * >
 *   Claim now
 * </ClaimButton>
 * ```
 *
 * For Edition Drop (ERC1155)
 * ```tsx
 * <ClaimButton
 *   contractAddress="0x..." // contract address of the Edition Drop
 *   chain={ethereum}
 *   client={client}
 *   claimParams={{
 *     type: "ERC1155",
 *     quantity: 1n,
 *     tokenId: 0n,
 *   }}
 * >
 *   Claim now
 * </ClaimButton>
 * ```
 *
 * For Token Drop (ERC20)
 * ```tsx
 * <ClaimButton
 *   contractAddress="0x..." // contract address of the Token Drop
 *   chain={ethereum}
 *   client={client}
 *   claimParams={{
 *     type: "ERC20",
 *     quantity: "100", // claim 100 ERC20 tokens
 *     // instead of `quantity`, you can also use `quantityInWei` (bigint)
 *   }}
 * >
 *   Claim now
 * </ClaimButton>
 * ```
 *
 * Attach custom Pay metadata
 * ```tsx
 * <ClaimButton
 *   payModal={{
 *     metadata: {
 *       name: "Van Gogh Starry Night",
 *       image: "https://unsplash.com/starry-night.png"
 *     }
 *   }}
 * >...</ClaimButton>
 *
 * ```
 *
 * Since this button uses the `TransactionButton`, it can take in any props that can be passed
 * to the [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)
 *
 *
 * For error handling & callbacks on transaction-sent and transaction-confirmed,
 * please refer to the TransactionButton docs.
 */
function ClaimButton(props) {
    const { children, contractAddress, client, chain, claimParams, payModal } = props;
    const defaultPayModalMetadata = payModal ? payModal.metadata : undefined;
    const contract = (0, contract_js_1.getContract)({
        address: contractAddress,
        client,
        chain,
    });
    const { data: payMetadata } = (0, useReadContract_js_1.useReadContract)(getPayMetadata, {
        contract,
        tokenId: claimParams.type === "ERC1155" ? claimParams.tokenId : undefined,
        queryOptions: {
            enabled: !defaultPayModalMetadata,
        },
    });
    const account = (0, useActiveAccount_js_1.useActiveAccount)();
    const { mutateAsync } = (0, useSendAndConfirmTransaction_js_1.useSendAndConfirmTransaction)();
    return ((0, jsx_runtime_1.jsx)(index_js_1.TransactionButton, { payModal: {
            metadata: defaultPayModalMetadata || payMetadata,
            ...payModal,
        }, transaction: async () => {
            if (!account) {
                throw new Error("No account detected");
            }
            const [claimTx, { getApprovalForTransaction }] = await Promise.all([
                getClaimTransaction({
                    contract,
                    account,
                    claimParams,
                }),
                Promise.resolve().then(() => require("../../../../../../extensions/erc20/write/getApprovalForTransaction.js")),
            ]);
            const approveTx = await getApprovalForTransaction({
                transaction: claimTx,
                account,
            });
            if (approveTx) {
                await mutateAsync(approveTx);
            }
            return claimTx;
        }, ...props, children: children }));
}
/**
 * We can only get the image and name for Edition Drop
 * For NFT Drop and Token Drop we fall back to the name & image of the contract
 * @internal
 */
async function getPayMetadata(options) {
    const { contract, tokenId } = options;
    const [contractMetadata, nft] = await Promise.all([
        (0, getContractMetadata_js_1.getContractMetadata)(options),
        tokenId ? (0, getNFT_js_1.getNFT)({ contract, tokenId }) : undefined,
    ]);
    if (tokenId) {
        return {
            image: nft?.metadata?.image,
            name: nft?.metadata?.name,
        };
    }
    return {
        image: contractMetadata?.image,
        name: contractMetadata?.name,
    };
}
/**
 * @internal Export for test
 */
async function getClaimTransaction({ contract, account, claimParams, }) {
    switch (claimParams.type) {
        case "ERC721":
            return await getERC721ClaimTo({ contract, account, claimParams });
        case "ERC1155":
            return await getERC1155ClaimTo({ contract, account, claimParams });
        case "ERC20": {
            return await getERC20ClaimTo({ contract, account, claimParams });
        }
        default:
            throw new Error("Invalid contract type. Must be either NFT Drop (ERC721), Edition Drop (ERC1155) or Token Drop (ERC20)");
    }
}
/**
 * @internal
 */
async function getERC721ClaimTo({ contract, account, claimParams, }) {
    const { claimTo } = await Promise.resolve().then(() => require("../../../../../../extensions/erc721/drops/write/claimTo.js"));
    return claimTo({
        contract,
        to: claimParams.to || account?.address || "",
        quantity: claimParams.quantity,
        from: claimParams.from,
    });
}
/**
 * @internal
 */
async function getERC1155ClaimTo({ contract, account, claimParams, }) {
    const { claimTo } = await Promise.resolve().then(() => require("../../../../../../extensions/erc1155/drops/write/claimTo.js"));
    return claimTo({
        contract,
        to: claimParams.to || account?.address || "",
        quantity: claimParams.quantity,
        tokenId: claimParams.tokenId,
        from: claimParams.from,
    });
}
/**
 * @internal
 */
async function getERC20ClaimTo({ contract, account, claimParams, }) {
    // Ideally we should check if the contract is ERC20 using `isERC20`
    // however TokenDrop doesn't have `supportsInterface` so it doesn't work
    const { claimTo } = await Promise.resolve().then(() => require("../../../../../../extensions/erc20/drops/write/claimTo.js"));
    if ("quantity" in claimParams) {
        return claimTo({
            contract,
            to: claimParams.to || account?.address || "",
            quantity: claimParams.quantity,
            from: claimParams.from,
        });
    }
    if ("quantityInWei" in claimParams) {
        return claimTo({
            contract,
            to: claimParams.to || account?.address || "",
            quantityInWei: claimParams.quantityInWei,
            from: claimParams.from,
        });
    }
    throw new Error("Missing quantity or quantityInWei");
}
//# sourceMappingURL=index.js.map