"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyHash = verifyHash;
const utils_1 = require("@noble/curves/abstract/utils");
const viem_1 = require("viem");
const contract_js_1 = require("../contract/contract.js");
const isValidSignature_js_1 = require("../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js");
const eth_call_js_1 = require("../rpc/actions/eth_call.js");
const rpc_js_1 = require("../rpc/rpc.js");
const from_bytes_js_1 = require("../utils/encoding/from-bytes.js");
const hex_js_1 = require("../utils/encoding/hex.js");
const to_bytes_js_1 = require("../utils/encoding/to-bytes.js");
const is_erc6492_signature_js_1 = require("./is-erc6492-signature.js");
const serialize_erc6492_signature_js_1 = require("./serialize-erc6492-signature.js");
/**
 * @description Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.
 * This function should rarely be used directly, instead use @see {import("./verify-signature.js")} and @see {import("./verify-typed-data.js")}}
 *
 * @param {Hex} options.hash The hash that was signed
 * @param {string | Uint8Array | Signature} options.signature The signature that was signed
 * @param {string} options.address The address that signed the hash
 * @param {ThirdwebClient} options.client The Thirdweb client
 * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.
 * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory
 * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory
 *
 * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.
 *
 * @example
 * ```ts
 * import { verifyHash } from "thirdweb/utils";
 * const isValid = await verifyHash({
 *   hash: "0x1234",
 *   signature: "0x1234",
 *   address: "0x1234",
 *   client,
 *   chain,
 * });
 * ```
 *
 * @auth
 */
async function verifyHash({ hash, signature, address, client, chain, accountFactory, }) {
    const signatureHex = (() => {
        if ((0, hex_js_1.isHex)(signature))
            return signature;
        if (typeof signature === "object" && "r" in signature && "s" in signature)
            return (0, viem_1.serializeSignature)(signature);
        if (signature instanceof Uint8Array)
            return (0, from_bytes_js_1.fromBytes)(signature, "hex");
        // We should never hit this but TS doesn't know that
        throw new Error(`Invalid signature type for signature ${signature}: ${typeof signature}`);
    })();
    const wrappedSignature = await (async () => {
        // If no factory is provided, we have to assume its already deployed or is an EOA
        // TODO: Figure out how to automatically tell if our default factory was used
        if (!accountFactory)
            return signatureHex;
        // If this sigature was already wrapped for ERC-6492, carry on
        if ((0, is_erc6492_signature_js_1.isErc6492Signature)(signatureHex))
            return signatureHex;
        // Otherwise, serialize the signature for ERC-6492 validation
        return (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
            address: accountFactory.address,
            data: accountFactory.verificationCalldata,
            signature: signatureHex,
        });
    })();
    const verificationData = (0, viem_1.encodeDeployData)({
        abi: viem_1.universalSignatureValidatorAbi,
        args: [address, hash, wrappedSignature],
        bytecode: viem_1.universalSignatureValidatorByteCode,
    });
    const rpcRequest = (0, rpc_js_1.getRpcClient)({
        chain,
        client,
    });
    try {
        const result = await (0, eth_call_js_1.eth_call)(rpcRequest, {
            data: verificationData,
        });
        const hexResult = (0, hex_js_1.isHex)(result) ? (0, to_bytes_js_1.toBytes)(result) : result;
        return (0, utils_1.equalBytes)(hexResult, (0, to_bytes_js_1.toBytes)("0x1"));
    }
    catch {
        // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation
        const validEip1271 = await verifyEip1271Signature({
            hash,
            signature: signatureHex,
            contract: (0, contract_js_1.getContract)({
                chain,
                address,
                client,
            }),
        }).catch(() => false);
        if (validEip1271) {
            return true;
        }
        // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error
        // Verification failed somehow
        return false;
    }
}
const EIP_1271_MAGIC_VALUE = "0x1626ba7e";
async function verifyEip1271Signature({ hash, signature, contract, }) {
    const result = await (0, isValidSignature_js_1.isValidSignature)({
        hash,
        signature,
        contract,
    });
    return result === EIP_1271_MAGIC_VALUE;
}
//# sourceMappingURL=verify-hash.js.map