"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchProofsERC721 = fetchProofsERC721;
const getContractMetadata_js_1 = require("../../../extensions/common/read/getContractMetadata.js");
const MerkleTree_js_1 = require("../../../merkletree/MerkleTree.js");
const download_js_1 = require("../../../storage/download.js");
const hash_entry_erc721_js_1 = require("./hash-entry-erc721.js");
/**
 * Retrieves the claim merkle proof for the provided address.
 * @param {Object} options
 * @param {@link ThirdwebContract} contract - The ERC721 airdrop contract
 * @param {string} recipient - The address of the drop recipient
 * @param {string} merkleRoot - The merkle root, found on the active claim condition
 *
 * @returns {Promise<ClaimProofERC721 | null>} A promise that resolves to the proof or null if the recipient is not in the allowlist
 *
 * @example
 * ```ts
 * import { fetchProofsERC721 } from "thirdweb/extensions/airdrop";
 * import { getContract, defineChain } from "thirdweb";
 *
 * const NFT = getContracct({
 *  client,
 *  chain: defineChain(1),
 *  address: "0x..."
 * });
 *
 * const merkleRoot = await tokenMerkleRoot({
 *  contract: NFT,
 *  tokenAddress: NFT.address
 * });
 *
 * const proof = await fetchProofsERC721({
 *  contract: NFT,
 *  recipient: "0x...",
 *  merkleRoot
 * });
 * ```
 *
 * @extension AIRDROP
 */
async function fetchProofsERC721(options) {
    const { contract, merkleRoot, recipient } = options;
    // 1. fetch merkle data from contract URI
    const metadata = await (0, getContractMetadata_js_1.getContractMetadata)({
        contract,
    });
    const merkleData = metadata.merkle || {};
    const snapshotUri = merkleData[merkleRoot];
    if (!snapshotUri) {
        return null;
    }
    // 2. download snapshot data
    const response = await (0, download_js_1.download)({
        client: contract.client,
        uri: snapshotUri,
    });
    const merkleInfo = await response.json();
    // 3. download shard data based off the user address
    const shardId = recipient.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();
    const uri = merkleInfo.baseUri.endsWith("/")
        ? merkleInfo.baseUri
        : `${merkleInfo.baseUri}/`;
    let shardData;
    try {
        const constructedShardUri = `${uri}${shardId}.json`;
        const shard = await (0, download_js_1.download)({
            client: contract.client,
            uri: constructedShardUri,
        });
        shardData = await shard.json();
    }
    catch {
        // if the file can't be fetched it means claimer not in merkle tree
        return null;
    }
    // 4. hash all the entries in that shard and construct the sub merkle tree
    const hashedEntries = await Promise.all(shardData.entries.map(async (entry) => {
        return (0, hash_entry_erc721_js_1.hashEntryERC721)({
            entry,
        });
    }));
    const tree = new MerkleTree_js_1.MerkleTree(hashedEntries);
    // 5. get the proof for the claimer + the sub merkle tree root
    const entry = shardData.entries.find((i) => i.recipient.toLowerCase() === recipient.toLowerCase());
    if (!entry) {
        return null;
    }
    const proof = tree
        .getHexProof(await (0, hash_entry_erc721_js_1.hashEntryERC721)({
        entry,
    }))
        .concat(shardData.proofs);
    return {
        proof,
        recipient: recipient,
        tokenId: BigInt(entry.tokenId),
    };
}
//# sourceMappingURL=fetch-proofs-erc721.js.map