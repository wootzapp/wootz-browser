"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerPasskey = registerPasskey;
exports.loginWithPasskey = loginWithPasskey;
const domains_js_1 = require("../../../../utils/domains.js");
const fetch_js_1 = require("../../../../utils/fetch.js");
const client_scoped_storage_js_1 = require("./client-scoped-storage.js");
function getVerificationPath() {
    return `${(0, domains_js_1.getThirdwebBaseUrl)("inAppWallet")}/api/2024-05-05/login/passkey/callback`;
}
function getChallengePath(type, username) {
    return `${(0, domains_js_1.getThirdwebBaseUrl)("inAppWallet")}/api/2024-05-05/login/passkey?type=${type}${username ? `&username=${username}` : ""}`;
}
async function registerPasskey(options) {
    if (!options.passkeyClient.isAvailable()) {
        throw new Error("Passkeys are not available on this device");
    }
    const storage = new client_scoped_storage_js_1.ClientScopedStorage({
        storage: options.storage,
        clientId: options.client.clientId,
        ecosystemId: options.ecosystem?.id,
    });
    const fetchWithId = (0, fetch_js_1.getClientFetch)(options.client, options.ecosystem);
    const generatedName = options.username ?? generateUsername(options.ecosystem);
    // 1. request challenge from  server
    const res = await fetchWithId(getChallengePath("sign-up", generatedName));
    const challengeData = await res.json();
    if (!challengeData.challenge) {
        throw new Error("No challenge received");
    }
    const challenge = challengeData.challenge;
    // 2. initiate registration
    const registration = await options.passkeyClient.register({
        name: generatedName,
        challenge,
        rp: options.rp,
    });
    const customHeaders = {};
    if (options.ecosystem?.partnerId) {
        customHeaders["x-ecosystem-partner-id"] = options.ecosystem.partnerId;
    }
    if (options.ecosystem?.id) {
        customHeaders["x-ecosystem-id"] = options.ecosystem.id;
    }
    // 3. send the registration object to the server
    const verifRes = await fetchWithId(getVerificationPath(), {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            ...customHeaders,
        },
        body: JSON.stringify({
            type: "sign-up",
            authenticatorData: registration.authenticatorData,
            credentialId: registration.credentialId,
            serverVerificationId: challengeData.serverVerificationId,
            clientData: registration.clientData,
            username: generatedName,
            credential: {
                publicKey: registration.credential.publicKey,
                algorithm: registration.credential.algorithm,
            },
            origin: registration.origin,
            rpId: options.rp.id,
        }),
    });
    const verifData = await verifRes.json();
    if (!verifData || !verifData.storedToken) {
        throw new Error(`Error verifying passkey: ${verifData.message ?? "unknown error"}`);
    }
    // 4. store the credentialId in local storage
    await storage.savePasskeyCredentialId(registration.credentialId);
    // 5. returns back the IAW authentication token
    return verifData;
}
async function loginWithPasskey(options) {
    if (!options.passkeyClient.isAvailable()) {
        throw new Error("Passkeys are not available on this device");
    }
    const storage = new client_scoped_storage_js_1.ClientScopedStorage({
        storage: options.storage,
        clientId: options.client.clientId,
        ecosystemId: options.ecosystem?.id,
    });
    const fetchWithId = (0, fetch_js_1.getClientFetch)(options.client, options.ecosystem);
    // 1. request challenge from  server/iframe
    const res = await fetchWithId(getChallengePath("sign-in"));
    const challengeData = await res.json();
    if (!challengeData.challenge) {
        throw new Error("No challenge received");
    }
    const challenge = challengeData.challenge;
    // 1.2. find the user's credentialId in local storage
    const credentialId = (await storage.getPasskeyCredentialId()) ?? undefined;
    // 2. initiate login
    const authentication = await options.passkeyClient.authenticate({
        credentialId,
        challenge,
        rp: options.rp,
    });
    const customHeaders = {};
    if (options.ecosystem?.partnerId) {
        customHeaders["x-ecosystem-partner-id"] = options.ecosystem.partnerId;
    }
    if (options.ecosystem?.id) {
        customHeaders["x-ecosystem-id"] = options.ecosystem.id;
    }
    const verifRes = await fetchWithId(getVerificationPath(), {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            ...customHeaders,
        },
        body: JSON.stringify({
            type: "sign-in",
            authenticatorData: authentication.authenticatorData,
            credentialId: authentication.credentialId,
            serverVerificationId: challengeData.serverVerificationId,
            clientData: authentication.clientData,
            signature: authentication.signature,
            origin: authentication.origin,
            rpId: options.rp.id,
        }),
    });
    const verifData = await verifRes.json();
    if (!verifData || !verifData.storedToken) {
        throw new Error(`Error verifying passkey: ${verifData.message ?? "unknown error"}`);
    }
    // 5. store the credentialId in local storage
    await storage.savePasskeyCredentialId(authentication.credentialId);
    // 6. return the auth'd user type
    return verifData;
}
function generateUsername(ecosystem) {
    return `${ecosystem?.id ?? "wallet"}-${new Date().toISOString()}`;
}
//# sourceMappingURL=passkeys.js.map