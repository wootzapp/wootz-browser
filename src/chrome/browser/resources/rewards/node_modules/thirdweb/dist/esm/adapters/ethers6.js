import * as universalethers from "ethers";
import { getRpcUrlForChain } from "../chains/utils.js";
import { getContract } from "../contract/contract.js";
import { toSerializableTransaction } from "../transaction/actions/to-serializable-transaction.js";
import { toHex } from "../utils/encoding/hex.js";
import { resolvePromisedValue } from "../utils/promise/resolve-promised-value.js";
import { normalizeChainId } from "../wallets/utils/normalizeChainId.js";
/**
 * Checks if the given ethers object is of type ethers5.
 * @param ethers - The ethers object to check.
 * @returns True if the ethers object is of type ethers5, false otherwise.
 * @internal
 */
function isEthers5(ethers_) {
    return "providers" in ethers_;
}
/**
 * Asserts that the provided ethers object is of type ethers5.
 * If the object is not of type ethers5, an error is thrown.
 * @param ethers - The ethers object to be asserted.
 * @throws Error - If the ethers object is not of type ethers5.
 * @internal
 */
function assertEthers6(ethers_) {
    if (isEthers5(ethers_)) {
        throw new Error("You seem to be using ethers@5, please use the `ethers5Adapter()");
    }
}
/**
 * The ethers6 adapter provides a way to convert between Thirdweb contracts, accounts, and providers.
 * @example
 *
 * ### Converting a Thirdweb account to an ethers.js signer
 * ```ts
 * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
 * const signer = await ethers6Adapter.signer.toEthers({ client, chain, account });
 * ```
 *
 * ### Converting an ethers.js signer into a Thirdweb account
 * ```ts
 * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
 * const account = await ethers6Adapter.signer.fromEthers({ signer });
 * ```
 *
 * ### Converting a Thirdweb contract to an ethers.js Contract
 * ```ts
 * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
 * const ethersContract = await ethers6Adapter.contract.toEthers({ thirdwebContract });
 * ```
 *
 * ### Converting a Thirdweb client and chain ID into an ethers.js provider
 * ```ts
 * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
 * const provider = ethers6Adapter.provider.toEthers({ client, chain });
 * ```
 */
export const ethers6Adapter = /* @__PURE__ */ (() => {
    const ethers = universalethers;
    return {
        /**
         * Converts a Thirdweb client and chain ID into an ethers.js provider.
         * @param options - The options for converting the Thirdweb client and chain ID into an ethers.js provider.
         * @param options.client - The Thirdweb client.
         * @param options.chain - The chain.
         * @returns The ethers.js provider.
         * @example
         * ```ts
         * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
         * const provider = ethers6Adapter.provider.toEthers({ client, chain });
         * ```
         */
        provider: {
            /**
             * Converts a Thirdweb client and chain ID into an ethers.js provider.
             * @param options - The options for converting the Thirdweb client and chain ID into an ethers.js provider.
             * @param options.client - The Thirdweb client.
             * @param options.chain - The chain.
             * @returns The ethers.js provider.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const provider = ethers6Adapter.provider.toEthers({ client, chain });
             * ```
             */
            toEthers: (options) => {
                assertEthers6(ethers);
                return toEthersProvider(ethers, options.client, options.chain);
            },
        },
        /**
         * Converts a ThirdwebContract to an ethers.js Contract or the other way around.
         * @example
         *
         * ### toEthers
         * ```ts
         * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
         * const ethersContract = await ethers6Adapter.contract.toEthers({ thirdwebContract, account });
         * ```
         *
         * ### fromEthers
         * ```ts
         * import { ethers6Adapter } from "thirdweb/adapters";
         * const contract = ethers6Adapter.contract.fromEthers({ client, chain, ethersContract });
         * ```
         */
        contract: {
            /**
             * Converts a ThirdwebContract to an ethers.js Contract.
             * @param options - The options for converting a ThirdwebContract to an ethers.js Contract.
             * @param options.thirdwebContract - The ThirdwebContract to convert.
             * @param options.account - The account to use for signing the transaction.
             * @returns The ethers.js Contract.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const ethersContract = await ethers6Adapter.contract.toEthers({ thirdwebContract });
             * ```
             */
            toEthers: (options) => {
                assertEthers6(ethers);
                return toEthersContract(ethers, options.thirdwebContract, options.account);
            },
            /**
             * Creates a ThirdwebContract from an ethers.js Contract.
             * @param options - The options for creating a ThirdwebContract from an ethers.js Contract.
             * @param options.ethersContract - The ethers.js Contract to convert.
             * @param options.chain - The chain.
             * @returns The ThirdwebContract.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const contract = ethers6Adapter.contract.fromEthers({ ethersContract, chain });
             * ```
             */
            fromEthers: (options) => {
                assertEthers6(ethers);
                return fromEthersContract(options);
            },
        },
        /**
         * Converts an ethers6 Signer into an Wallet object or the other way around.
         * @example
         *
         * ### fromEthersSigner
         * ```ts
         * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
         * const signer = ethers6Adapter.signer.fromEthersSigner({ signer });
         * ```
         *
         * ### toEthersSigner
         * ```ts
         * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
         * const signer = await ethers6Adapter.signer.toEthers({ client, chain, account });
         * ```
         */
        signer: {
            /**
             * Converts an ethers6 Signer into an thirdweb account.
             * @param options - The options for converting the ethers6 Signer into a thirdweb account.
             * @param options.signer - The ethers6 Signer object.
             * @returns - A Promise that resolves to a thirdweb account.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const account = await ethers6Adapter.signer.fromEthers({ signer });
             * ```
             */
            fromEthers: (options) => {
                assertEthers6(ethers);
                return fromEthersSigner(options.signer);
            },
            /**
             * Converts a Thirdweb wallet to an ethers.js signer.
             * @param options - The options for converting the Thirdweb wallet to an ethers.js signer.
             * @param options.client - The thirdweb client.
             * @param options.account - The account.
             * @param options.chain - The chain.
             * @returns A promise that resolves to an ethers.js signer.
             * @example
             * ```ts
             * import { ethers6Adapter } from "thirdweb/adapters/ethers6";
             * const signer = await ethers6Adapter.signer.toEthers({ client, chain, account });
             * ```
             */
            toEthers: (options) => {
                assertEthers6(ethers);
                return toEthersSigner(ethers, options.client, options.account, options.chain);
            },
        },
    };
})();
/**
 * Converts a Thirdweb client and chain ID into an ethers.js provider.
 * @param ethers - The ethers.js library instance.
 * @param client - The Thirdweb client.
 * @param chain - The chain.
 * @returns The ethers.js provider.
 * @internal
 */
export function toEthersProvider(ethers, client, chain) {
    const url = getRpcUrlForChain({ client, chain });
    const fetchRequest = new ethers.FetchRequest(url);
    if (client.secretKey) {
        fetchRequest.setHeader("x-secret-key", client.secretKey);
        fetchRequest.setHeader("Content-Type", "application/json");
    }
    return new ethers.JsonRpcProvider(fetchRequest, chain.id, {
        staticNetwork: true,
    });
}
/**
 * Converts a ThirdwebContract to an ethers.js Contract.
 * @param ethers - The ethers.js instance.
 * @param twContract - The ThirdwebContract to convert.
 * @returns A Promise that resolves to an ethers.js Contract.
 * @internal
 */
export async function toEthersContract(ethers, twContract, account) {
    if (twContract.abi) {
        return new ethers.Contract(twContract.address, JSON.stringify(twContract.abi), account
            ? toEthersSigner(ethers, twContract.client, account, twContract.chain)
            : toEthersProvider(ethers, twContract.client, twContract.chain));
    }
    const { resolveContractAbi } = await import("../contract/actions/resolve-abi.js");
    const abi = await resolveContractAbi(twContract);
    return new ethers.Contract(twContract.address, JSON.stringify(abi), account
        ? toEthersSigner(ethers, twContract.client, account, twContract.chain)
        : toEthersProvider(ethers, twContract.client, twContract.chain));
}
/**
 * Creates a ThirdwebContract instance from an ethers.js contract.
 * @param options - The options for creating the ThirdwebContract instance.
 * @returns A promise that resolves to a ThirdwebContract instance.
 * @internal
 */
export async function fromEthersContract({ client, ethersContract, chain, }) {
    return getContract({
        client,
        address: await ethersContract.getAddress(),
        abi: JSON.parse(ethersContract.interface.formatJson()),
        chain,
    });
}
/**
 * Converts an ethers5 Signer into an Account object.
 * @param signer - The ethers5 Signer object.
 * @returns - A Promise that resolves to an Account object.
 * @internal
 */
export async function fromEthersSigner(signer) {
    const address = await signer.getAddress();
    const account = {
        address,
        signMessage: async ({ message }) => {
            return signer.signMessage(typeof message === "string" ? message : message.raw);
        },
        signTransaction: async (tx) => {
            return signer.signTransaction(alignTxToEthers(tx));
        },
        sendTransaction: async (tx) => {
            const transactionHash = (await signer.sendTransaction(alignTxToEthers(tx))).hash;
            return {
                transactionHash,
            };
        },
        signTypedData: async (data) => {
            return (await signer.signTypedData(data.domain, data.types, 
            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
            data.message));
        },
    };
    return account;
}
/**
 * Converts a Thirdweb account to an ethers.js signer.
 * @param ethers - The ethers.js library.
 * @param client - The Thirdweb client.
 * @param chain - The blockchain chain.
 * @param account - The Thirdweb account.
 * @returns An ethers.js signer.
 * @internal
 */
export function toEthersSigner(ethers, client, account, chain) {
    class ThirdwebAdapterSigner extends ethers.AbstractSigner {
        constructor(provider, address) {
            super(provider);
            Object.defineProperty(this, "address", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "provider", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.address = address;
            this.provider = provider;
        }
        async getAddress() {
            // needs to be a promise because ethers6 returns a promise
            return this.address;
        }
        connect() {
            return this;
        }
        async sendTransaction(tx) {
            if (!account) {
                throw new Error("Account not found");
            }
            const ethersTx = await alignTxFromEthers({
                chain,
                client,
                tx,
            });
            const serializableTx = await toSerializableTransaction({
                transaction: ethersTx,
                from: account.address,
            });
            const result = await account.sendTransaction(serializableTx);
            const txResponseParams = {
                ...serializableTx,
                blockHash: null,
                from: this.address,
                hash: result.transactionHash,
                blockNumber: null,
                index: 0,
                gasLimit: serializableTx.gas,
                // @ts-expect-error - we don't have this reliably so we'll just not include it
                signature: null,
            };
            return new ethers.TransactionResponse(txResponseParams, this.provider);
        }
        async signTransaction(tx) {
            if (!account) {
                throw new Error("Account not found");
            }
            if (!account.signTransaction) {
                throw new Error("Account does not support signing transactions");
            }
            const ethersTx = await alignTxFromEthers({
                chain,
                client,
                tx,
            });
            const serializableTx = await toSerializableTransaction({
                transaction: ethersTx,
                from: account.address,
            });
            return account.signTransaction(serializableTx);
        }
        signMessage(message) {
            if (!account) {
                throw new Error("Account not found");
            }
            return account.signMessage({
                message: typeof message === "string" ? message : { raw: message },
            });
        }
        signTypedData(domain, types, 
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
        value) {
            if (!account) {
                throw new Error("Account not found");
            }
            const typedDataEncoder = new ethers.TypedDataEncoder(types);
            const typedData = {
                primaryType: typedDataEncoder.primaryType,
                domain: {
                    chainId: domain.chainId
                        ? bigNumberIshToNumber(domain.chainId)
                        : undefined,
                    name: domain.name ?? undefined,
                    salt: domain.salt ? toHex(domain.salt) : undefined,
                    verifyingContract: domain.verifyingContract ?? undefined,
                    version: domain.version ?? undefined,
                },
                types,
                message: value,
            };
            return account.signTypedData(typedData);
        }
    }
    return new ThirdwebAdapterSigner(toEthersProvider(ethers, client, chain), account.address);
}
/**
 * Aligns a transaction object to fit the format expected by ethers6 library.
 * @param tx - The transaction object to align.
 * @returns The aligned transaction object.
 * @internal
 */
function alignTxToEthers(tx) {
    const { type: viemType, ...rest } = tx;
    // massage "type" to fit ethers
    let type;
    switch (viemType) {
        case "legacy": {
            type = 0;
            break;
        }
        case "eip2930": {
            type = 1;
            break;
        }
        case "eip1559": {
            type = 2;
            break;
        }
        default: {
            type = null;
            break;
        }
    }
    return {
        ...rest,
        type,
    };
}
async function alignTxFromEthers(options) {
    const { client, chain, tx } = options;
    const { type: ethersType, accessList, chainId: ethersChainId, to: ethersTo, data, nonce, value, gasPrice, gasLimit, maxFeePerGas, maxPriorityFeePerGas, } = tx;
    let chainId;
    if (ethersChainId) {
        chainId = normalizeChainId(ethersChainId);
    }
    const to = await resolveEthers6Address(ethersTo);
    // massage "type" to fit ethers
    switch (ethersType) {
        case 1: {
            if (!chainId) {
                throw new Error("ChainId is required for EIP-2930 transactions");
            }
            return {
                client,
                chain,
                accessList: accessList,
                to: (to ?? undefined),
                data: (data ?? undefined),
                gasPrice: gasPrice ? bigNumberIshToBigint(gasPrice) : undefined,
                gas: gasLimit ? bigNumberIshToBigint(gasLimit) : undefined,
                nonce: nonce ?? undefined,
                value: value ? bigNumberIshToBigint(value) : undefined,
            };
        }
        case 2: {
            if (!chainId) {
                throw new Error("ChainId is required for EIP-1559 transactions");
            }
            return {
                client,
                chain,
                accessList: accessList,
                to: (to ?? undefined),
                data: (data ?? undefined),
                gas: gasLimit ? bigNumberIshToBigint(gasLimit) : undefined,
                nonce: nonce ?? undefined,
                value: value ? bigNumberIshToBigint(value) : undefined,
                maxFeePerGas: maxFeePerGas
                    ? bigNumberIshToBigint(maxFeePerGas)
                    : undefined,
                maxPriorityFeePerGas: maxPriorityFeePerGas
                    ? bigNumberIshToBigint(maxPriorityFeePerGas)
                    : undefined,
            };
        }
        default: {
            // fall back to legacy
            return {
                client,
                chain,
                to: (to ?? undefined),
                data: (data ?? undefined),
                nonce: nonce ?? undefined,
                value: value ? bigNumberIshToBigint(value) : undefined,
                gasPrice: gasPrice ? bigNumberIshToBigint(gasPrice) : undefined,
                gas: gasLimit ? bigNumberIshToBigint(gasLimit) : undefined,
            };
        }
    }
}
async function resolveEthers6Address(address) {
    if (!address) {
        return address;
    }
    let resolvedAddress = address;
    if (resolvedAddress) {
        resolvedAddress = await resolvePromisedValue(resolvedAddress);
    }
    if (typeof resolvedAddress === "string") {
        return resolvedAddress;
    }
    return resolvedAddress?.getAddress();
}
function bigNumberIshToBigint(value) {
    if (typeof value === "bigint") {
        return value;
    }
    return BigInt(value);
}
function bigNumberIshToNumber(value) {
    return Number(bigNumberIshToBigint(value));
}
//# sourceMappingURL=ethers6.js.map