"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuyDirectListingButton = BuyDirectListingButton;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const contract_js_1 = require("../../../../../../contract/contract.js");
const getListing_js_1 = require("../../../../../../extensions/marketplace/direct-listings/read/getListing.js");
const useReadContract_js_1 = require("../../../../../core/hooks/contract/useReadContract.js");
const useSendAndConfirmTransaction_js_1 = require("../../../../../core/hooks/transaction/useSendAndConfirmTransaction.js");
const useActiveAccount_js_1 = require("../../../../../core/hooks/wallets/useActiveAccount.js");
const index_js_1 = require("../../../TransactionButton/index.js");
/**
 * This button is used with thirdweb Marketplace v3 contract, for buying NFT(s) from a listing.
 *
 * Under the hood, it prepares a transaction using the [`buyFromListing` extension](https://portal.thirdweb.com/references/typescript/v5/marketplace/buyFromListing)
 * and then pass it to a <TransactionButton />
 *
 * Since it uses the TransactionButton, it can take in any props that can be passed
 * to the [`TransactionButton`](https://portal.thirdweb.com/references/typescript/v5/TransactionButton)
 *
 *
 * @param props
 * @returns <TransactionButton />
 *
 * @example
 * ```tsx
 * import { BuyDirectListingButton } from "thirdweb/react";
 *
 * <BuyDirectListingButton
 *   contractAddress="0x..." // contract address of the marketplace v3
 *   chain={...} // the chain which the marketplace contract is deployed on
 *   client={...} // thirdweb client
 *   listingId={100n} // the listingId or the item you want to buy
 *   quantity={1n} // optional - see the docs to learn more
 * >
 *   Buy NFT
 * </BuyDirectListingButton>
 * ```
 *
 * For error handling & callbacks on transaction-sent and transaction-confirmed,
 * please refer to the TransactionButton docs.
 * @component
 */
function BuyDirectListingButton(props) {
    const { contractAddress, listingId, children, chain, client, quantity, payModal, } = props;
    const defaultPayModalMetadata = payModal ? payModal.metadata : undefined;
    const account = (0, useActiveAccount_js_1.useActiveAccount)();
    const contract = (0, contract_js_1.getContract)({
        address: contractAddress,
        client,
        chain,
    });
    const { data: payMetadata } = (0, useReadContract_js_1.useReadContract)(getPayMetadata, {
        contract,
        listingId,
        queryOptions: {
            enabled: !defaultPayModalMetadata,
        },
    });
    const { mutateAsync } = (0, useSendAndConfirmTransaction_js_1.useSendAndConfirmTransaction)();
    const prepareBuyTransaction = (0, react_1.useCallback)(async () => {
        if (!account) {
            throw new Error("No account detected");
        }
        const [listing, { getApprovalForTransaction }, { buyFromListing }] = await Promise.all([
            (0, getListing_js_1.getListing)({
                contract,
                listingId,
            }),
            Promise.resolve().then(() => require("../../../../../../extensions/erc20/write/getApprovalForTransaction.js")),
            Promise.resolve().then(() => require("../../../../../../extensions/marketplace/direct-listings/write/buyFromListing.js")),
        ]);
        if (!listing) {
            throw new Error(`Could not retrieve listing with ID: ${listingId}`);
        }
        let _quantity = 1n;
        // For ERC721 the quantity should always be 1n. We throw an error if user passes a different props
        if (listing.asset.type === "ERC721") {
            if (typeof quantity === "bigint" && (quantity !== 1n || quantity < 0n)) {
                throw new Error("Invalid quantity. This is an ERC721 listing & quantity is always `1n`");
            }
        }
        else if (listing.asset.type === "ERC1155") {
            if (typeof quantity === "bigint") {
                if (quantity > listing.quantity) {
                    throw new Error(`quantity exceeds available amount. Available: ${listing.quantity.toString()}`);
                }
                if (quantity < 0n) {
                    throw new Error("Invalid quantity. Should be at least 1n");
                }
                _quantity = quantity;
            }
            _quantity = listing.quantity;
        }
        const buyTx = buyFromListing({
            contract,
            listingId,
            quantity: _quantity,
            recipient: account?.address || "",
        });
        const approveTx = await getApprovalForTransaction({
            transaction: buyTx,
            account,
        });
        if (approveTx) {
            await mutateAsync(approveTx);
        }
        return buyTx;
    }, [account, contract, quantity, listingId, mutateAsync]);
    return ((0, jsx_runtime_1.jsx)(index_js_1.TransactionButton, { payModal: {
            metadata: defaultPayModalMetadata || payMetadata,
            ...payModal,
        }, transaction: () => prepareBuyTransaction(), ...props, children: children }));
}
/**
 * @internal
 */
async function getPayMetadata(options) {
    const listing = await (0, getListing_js_1.getListing)(options);
    if (!listing) {
        return { name: undefined, image: undefined };
    }
    return {
        name: listing.asset?.metadata?.name,
        image: listing.asset?.metadata?.image,
    };
}
//# sourceMappingURL=index.js.map