"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkModulesCompatibility = checkModulesCompatibility;
const eth_call_js_1 = require("../../../rpc/actions/eth_call.js");
const rpc_js_1 = require("../../../rpc/rpc.js");
const arrays_js_1 = require("../../../utils/arrays.js");
const prefix_js_1 = require("../../../utils/bytecode/prefix.js");
const supportsInterface_js_1 = require("../../erc165/__generated__/IERC165/read/supportsInterface.js");
const getSupportedCallbackFunctions_js_1 = require("../__generated__/IModularCore/read/getSupportedCallbackFunctions.js");
const getModuleConfig_js_1 = require("../__generated__/IModule/read/getModuleConfig.js");
async function checkModulesCompatibility(options) {
    const addr = "0x0000000000000000000000000000000000000124"; // arbitrary address
    let _coreBytecode = (0, prefix_js_1.ensureBytecodePrefix)(options.coreBytecode);
    if (!_coreBytecode.startsWith("0x6080604052")) {
        const index = _coreBytecode.indexOf("6080604052");
        _coreBytecode = `0x${_coreBytecode.substring(index)}`;
    }
    else if (_coreBytecode.lastIndexOf("6080604052") > 0) {
        const index = _coreBytecode.lastIndexOf("6080604052");
        _coreBytecode = `0x${_coreBytecode.substring(index)}`;
    }
    const rpcClient = (0, rpc_js_1.getRpcClient)({
        client: options.client,
        chain: options.chain,
    });
    // get the core's supported callback functions
    const coreCallResult = await (0, eth_call_js_1.eth_call)(rpcClient, {
        data: getSupportedCallbackFunctions_js_1.FN_SELECTOR,
        to: addr,
        stateOverrides: {
            [addr]: {
                code: _coreBytecode,
            },
        },
    });
    const decodedCallResult = (0, getSupportedCallbackFunctions_js_1.decodeGetSupportedCallbackFunctionsResult)(coreCallResult);
    const coreCallbackSelectors = decodedCallResult.flat().map((c) => c.selector);
    // get the module config for each module
    const modules = await Promise.all(options.moduleBytecodes.map(async (b) => {
        // TODO: Upload deployed bytecode on publish metadata
        let moduleBytecode = (0, prefix_js_1.ensureBytecodePrefix)(b);
        if (!moduleBytecode.startsWith("0x6080604052")) {
            const index = moduleBytecode.indexOf("6080604052");
            moduleBytecode = `0x${moduleBytecode.substring(index)}`;
        }
        else if (moduleBytecode.lastIndexOf("6080604052") > 0) {
            const index = moduleBytecode.lastIndexOf("6080604052");
            moduleBytecode = `0x${moduleBytecode.substring(index)}`;
        }
        const callResult = await (0, eth_call_js_1.eth_call)(rpcClient, {
            data: getModuleConfig_js_1.FN_SELECTOR,
            to: addr,
            stateOverrides: {
                [addr]: {
                    code: moduleBytecode,
                },
            },
        });
        return (0, getModuleConfig_js_1.decodeGetModuleConfigResult)(callResult);
    }));
    // check if callback selectors are supported
    for (const module of modules) {
        for (const callback of module.callbackFunctions) {
            if (!coreCallbackSelectors.includes(callback.selector)) {
                return false;
            }
        }
    }
    // check if the core contract supports required interfaces by modules above
    const requiredInterfaces = modules.flatMap((m) => m.requiredInterfaces);
    if (requiredInterfaces.length > 0) {
        const supportsInterfaceResult = await Promise.all(requiredInterfaces.map(async (r) => {
            const callResult = await (0, eth_call_js_1.eth_call)(rpcClient, {
                data: (0, supportsInterface_js_1.encodeSupportsInterface)({
                    interfaceId: r,
                }),
                to: addr,
                stateOverrides: {
                    [addr]: {
                        code: _coreBytecode,
                    },
                },
            });
            return (0, supportsInterface_js_1.decodeSupportsInterfaceResult)(callResult);
        }));
        if (supportsInterfaceResult.flat().some((element) => element === false)) {
            return false;
        }
    }
    return !(0, arrays_js_1.hasDuplicates)([
        ...modules.flatMap((m) => m.callbackFunctions.map((c) => c.selector)),
        ...modules.flatMap((m) => m.fallbackFunctions.map((f) => f.selector)),
    ], (a, b) => a === b);
}
//# sourceMappingURL=checkModulesCompatibility.js.map