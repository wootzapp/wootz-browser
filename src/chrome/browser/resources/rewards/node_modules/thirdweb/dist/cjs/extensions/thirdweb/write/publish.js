"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishContract = publishContract;
exports.getContractPublisher = getContractPublisher;
const utils_1 = require("viem/utils");
const polygon_js_1 = require("../../../chains/chain-definitions/polygon.js");
const addresses_js_1 = require("../../../constants/addresses.js");
const contract_js_1 = require("../../../contract/contract.js");
const publisher_js_1 = require("../../../contract/deployment/publisher.js");
const download_js_1 = require("../../../storage/download.js");
const upload_js_1 = require("../../../storage/upload.js");
const prefix_js_1 = require("../../../utils/bytecode/prefix.js");
const semver_js_1 = require("../../../utils/semver.js");
const getInstalledModules_js_1 = require("../../modules/__generated__/IModularCore/read/getInstalledModules.js");
const publishContract_js_1 = require("../__generated__/IContractPublisher/write/publishContract.js");
/**
 * Publish a contract to the contract publisher.
 *
 * @param options - The options for publishing the contract.
 * @returns The transaction to publish the contract.
 * @example
 * ```ts
 * const tx = publishContract({
 *   contract,
 *   account,
 *   metadata,
 * });
 * ```
 * @extension thirdweb
 */
function publishContract(options) {
    return (0, publishContract_js_1.publishContract)({
        contract: options.contract,
        async asyncParams() {
            const currentVersion = options.previousMetadata?.version;
            // check if the version is greater than the current version
            if (currentVersion &&
                !(0, semver_js_1.isIncrementalVersion)(currentVersion, options.metadata.version)) {
                throw Error(`Version ${options.metadata.version} is not greater than ${currentVersion}`);
            }
            // hash the bytecode
            const bytecode = await (0, download_js_1.download)({
                client: options.contract.client,
                uri: options.metadata.bytecodeUri,
            }).then((r) => r.text());
            const bytecodeHash = (0, utils_1.keccak256)((0, utils_1.encodePacked)(["bytes"], [(0, prefix_js_1.ensureBytecodePrefix)(bytecode)]));
            const abi = options.metadata.abi;
            const routerType = getRouterType(abi);
            // not spreading here, we don't want to re-upload the fetched data like bytecode
            const newMetadata = {
                bytecodeUri: options.metadata.bytecodeUri,
                metadataUri: options.metadata.metadataUri,
                name: options.metadata.name,
                version: options.metadata.version,
                audit: options.metadata.audit,
                changelog: options.metadata.changelog,
                compositeAbi: options.metadata.compositeAbi,
                constructorParams: options.metadata.constructorParams,
                defaultExtensions: options.metadata.defaultExtensions,
                defaultModules: options.metadata.defaultModules,
                deployType: options.metadata.deployType,
                description: options.metadata.description,
                displayName: options.metadata.displayName,
                factoryDeploymentData: options.metadata.factoryDeploymentData,
                isDeployableViaFactory: options.metadata.isDeployableViaFactory,
                isDeployableViaProxy: options.metadata.isDeployableViaProxy,
                logo: options.metadata.logo,
                networksForDeployment: options.metadata.networksForDeployment,
                readme: options.metadata.readme,
                tags: options.metadata.tags,
                compilers: options.metadata.compilers,
                publisher: options.account.address,
                routerType,
            };
            // upload the new metadata
            const newMetadataUri = await (0, upload_js_1.upload)({
                client: options.contract.client,
                files: [newMetadata],
            });
            return {
                publisher: options.account.address,
                contractId: options.metadata.name,
                publishMetadataUri: newMetadataUri,
                compilerMetadataUri: options.metadata.metadataUri,
                bytecodeHash,
                implementation: addresses_js_1.ZERO_ADDRESS,
            };
        },
    });
}
function getContractPublisher(client) {
    return (0, contract_js_1.getContract)({
        client,
        chain: polygon_js_1.polygon,
        address: publisher_js_1.CONTRACT_PUBLISHER_ADDRESS,
    });
}
function getRouterType(abi) {
    const fnSelectors = abi
        .filter((f) => f.type === "function")
        .map((f) => (0, utils_1.toFunctionSelector)(f));
    const isModule = (0, getInstalledModules_js_1.isGetInstalledModulesSupported)(fnSelectors);
    // TODO add dynamic detection
    return isModule ? "modular" : "none";
}
//# sourceMappingURL=publish.js.map