"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAutoConnectCore = useAutoConnectCore;
const react_query_1 = require("@tanstack/react-query");
const create_wallet_js_1 = require("../../../../wallets/create-wallet.js");
const get_url_token_js_1 = require("../../../../wallets/in-app/web/lib/get-url-token.js");
const index_js_1 = require("../../../../wallets/manager/index.js");
const connection_manager_js_1 = require("../../providers/connection-manager.js");
const storage_js_1 = require("../../utils/storage.js");
const timeoutPromise_js_1 = require("../../utils/timeoutPromise.js");
const useConnect_js_1 = require("./useConnect.js");
const useSetActiveWalletConnectionStatus_js_1 = require("./useSetActiveWalletConnectionStatus.js");
function useAutoConnectCore(storage, props, getInstalledWallets) {
    const manager = (0, connection_manager_js_1.useConnectionManagerCtx)("useAutoConnect");
    const setConnectionStatus = (0, useSetActiveWalletConnectionStatus_js_1.useSetActiveWalletConnectionStatus)();
    const { connect } = (0, useConnect_js_1.useConnect)({
        client: props.client,
        accountAbstraction: props.accountAbstraction,
    });
    const { isAutoConnecting } = manager;
    const { wallets, onConnect } = props;
    const timeout = props.timeout ?? 15000;
    // get the supported wallets from thirdweb provider
    // check the storage for last connected wallets and connect them all
    // check the storage for last active wallet and set it as active
    const autoConnect = async () => {
        let autoConnected = false;
        isAutoConnecting.setValue(true);
        let [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([
            (0, index_js_1.getStoredConnectedWalletIds)(storage),
            (0, index_js_1.getStoredActiveWalletId)(storage),
        ]);
        const { authResult, walletId, authProvider } = (0, get_url_token_js_1.getUrlToken)();
        if (authResult && walletId) {
            lastActiveWalletId = walletId;
            lastConnectedWalletIds = lastConnectedWalletIds?.includes(walletId)
                ? lastConnectedWalletIds
                : [walletId, ...(lastConnectedWalletIds || [])];
        }
        if (authProvider) {
            await (0, storage_js_1.setLastAuthProvider)(authProvider, storage);
        }
        // if no wallets were last connected or we didn't receive an auth token
        if (!lastConnectedWalletIds) {
            return autoConnected;
        }
        const lastConnectedChain = await (0, index_js_1.getLastConnectedChain)(storage);
        async function handleWalletConnection(wallet) {
            return wallet.autoConnect({
                client: props.client,
                chain: lastConnectedChain ?? undefined,
                authResult,
            });
        }
        const availableWallets = [...wallets, ...(getInstalledWallets?.() ?? [])];
        const activeWallet = lastActiveWalletId &&
            (availableWallets.find((w) => w.id === lastActiveWalletId) ||
                (0, create_wallet_js_1.createWallet)(lastActiveWalletId));
        if (activeWallet) {
            try {
                setConnectionStatus("connecting"); // only set connecting status if we are connecting the last active EOA
                await (0, timeoutPromise_js_1.timeoutPromise)(handleWalletConnection(activeWallet), {
                    ms: timeout,
                    message: `AutoConnect timeout: ${timeout}ms limit exceeded.`,
                });
                // connected wallet could be activeWallet or smart wallet
                const connectedWallet = await connect(activeWallet);
                if (connectedWallet) {
                    if (onConnect) {
                        try {
                            onConnect(connectedWallet);
                            autoConnected = true;
                        }
                        catch {
                            // ignore
                        }
                    }
                }
                else {
                    setConnectionStatus("disconnected");
                }
            }
            catch (e) {
                if (e instanceof Error) {
                    console.warn("Error auto connecting wallet:", e.message);
                }
                setConnectionStatus("disconnected");
            }
        }
        else {
            setConnectionStatus("disconnected");
        }
        // then connect wallets that were last connected but were not set as active
        const otherWallets = wallets.filter((w) => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id));
        for (const wallet of otherWallets) {
            try {
                await handleWalletConnection(wallet);
                manager.addConnectedWallet(wallet);
            }
            catch {
                // no-op
            }
        }
        isAutoConnecting.setValue(false);
        return autoConnected; // useQuery needs a return value
    };
    // trigger the auto connect on first mount only
    const query = (0, react_query_1.useQuery)({
        queryKey: ["autoConnect", props.client.clientId],
        queryFn: autoConnect,
        refetchOnMount: false,
        refetchOnWindowFocus: false,
    });
    return query;
}
//# sourceMappingURL=useAutoConnect.js.map