"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isWalletConnect = isWalletConnect;
exports.connectWC = connectWC;
exports.autoConnectWC = autoConnectWC;
const viem_1 = require("viem");
const utils_js_1 = require("../../chains/utils.js");
const address_js_1 = require("../../utils/address.js");
const hex_js_1 = require("../../utils/encoding/hex.js");
const parseTypedData_js_1 = require("../../utils/signatures/helpers/parseTypedData.js");
const walletStorage_js_1 = require("../../utils/storage/walletStorage.js");
const url_js_1 = require("../../utils/url.js");
const getWalletInfo_js_1 = require("../__generated__/getWalletInfo.js");
const chains_js_1 = require("../utils/chains.js");
const defaultDappMetadata_js_1 = require("../utils/defaultDappMetadata.js");
const normalizeChainId_js_1 = require("../utils/normalizeChainId.js");
const constants_js_1 = require("./constants.js");
const ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
const defaultShowQrModal = true;
const storageKeys = {
    requestedChains: "tw.wc.requestedChains",
    lastUsedChainId: "tw.wc.lastUsedChainId",
};
/**
 * Checks if the provided wallet is a Wallet Connect wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is a Wallet Connect wallet, false otherwise.
 */
function isWalletConnect(wallet) {
    return wallet.id === "walletConnect";
}
/**
 * @internal
 */
async function connectWC(options, emitter, walletId, storage, sessionHandler) {
    const provider = await initProvider(options, walletId, sessionHandler);
    const wcOptions = options.walletConnect;
    let { onDisplayUri } = wcOptions || {};
    // use default sessionHandler unless onDisplayUri is explicitly provided
    if (!onDisplayUri && sessionHandler && walletId !== "walletConnect") {
        const walletInfo = await (0, getWalletInfo_js_1.getWalletInfo)(walletId);
        const deeplinkHandler = (uri) => {
            const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;
            if (!appUrl) {
                throw new Error("No app url found for wallet connect to redirect to.");
            }
            const fullUrl = (0, url_js_1.formatWalletConnectUrl)(appUrl, uri).redirect;
            sessionHandler(fullUrl);
        };
        onDisplayUri = deeplinkHandler;
    }
    if (onDisplayUri) {
        provider.events.addListener("display_uri", onDisplayUri);
    }
    let optionalChains = wcOptions?.optionalChains;
    let chainToRequest = options.chain;
    // ignore the given options chains - and set the safe supported chains
    if (walletId === "global.safe") {
        optionalChains = chainsToRequestForSafe.map(utils_js_1.getCachedChain);
        if (chainToRequest && !optionalChains.includes(chainToRequest)) {
            chainToRequest = undefined;
        }
    }
    const { rpcMap, chainsToRequest } = getChainsToRequest({
        client: options.client,
        chain: chainToRequest,
        optionalChains: optionalChains,
    });
    if (provider.session) {
        await provider.connect({
            ...(wcOptions?.pairingTopic
                ? { pairingTopic: wcOptions?.pairingTopic }
                : {}),
            optionalChains: chainsToRequest,
            chains: chainToRequest
                ? [chainToRequest.id]
                : chainsToRequest.length > 0
                    ? [chainsToRequest[0]]
                    : [1],
            rpcMap: rpcMap,
        });
    }
    setRequestedChainsIds(chainsToRequest, storage);
    // If session exists and chains are authorized, enable provider for required chain
    const addresses = await provider.enable();
    const address = addresses[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const providerChainId = (0, normalizeChainId_js_1.normalizeChainId)(provider.chainId);
    const chain = options.chain && options.chain.id === providerChainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(providerChainId);
    if (options) {
        const savedParams = {
            optionalChains: options.walletConnect?.optionalChains,
            chain: options.chain,
            pairingTopic: options.walletConnect?.pairingTopic,
        };
        if (storage) {
            (0, walletStorage_js_1.saveConnectParamsToStorage)(storage, walletId, savedParams);
        }
    }
    if (wcOptions?.onDisplayUri) {
        provider.events.removeListener("display_uri", wcOptions.onDisplayUri);
    }
    return onConnect(address, chain, provider, emitter, storage);
}
/**
 * Auto connect to already connected wallet connect session.
 * @internal
 */
async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {
    const savedConnectParams = storage
        ? await (0, walletStorage_js_1.getSavedConnectParamsFromStorage)(storage, walletId)
        : null;
    const provider = await initProvider(savedConnectParams
        ? {
            chain: savedConnectParams.chain,
            client: options.client,
            walletConnect: {
                pairingTopic: savedConnectParams.pairingTopic,
                optionalChains: savedConnectParams.optionalChains,
            },
        }
        : {
            client: options.client,
            walletConnect: {},
        }, walletId, sessionHandler, true);
    const address = provider.accounts[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const providerChainId = (0, normalizeChainId_js_1.normalizeChainId)(provider.chainId);
    const chain = options.chain && options.chain.id === providerChainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(providerChainId);
    return onConnect(address, chain, provider, emitter, storage);
}
// Connection utils -----------------------------------------------------------------------------------------------
async function initProvider(options, walletId, sessionRequestHandler, isAutoConnect = false) {
    const walletInfo = await (0, getWalletInfo_js_1.getWalletInfo)(walletId);
    const wcOptions = options.walletConnect;
    const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await Promise.resolve().then(() => require("@walletconnect/ethereum-provider"));
    let optionalChains = wcOptions?.optionalChains;
    let chainToRequest = options.chain;
    // ignore the given options chains - and set the safe supported chains
    if (walletId === "global.safe") {
        optionalChains = chainsToRequestForSafe.map(utils_js_1.getCachedChain);
        if (chainToRequest && !optionalChains.includes(chainToRequest)) {
            chainToRequest = undefined;
        }
    }
    const { rpcMap, chainsToRequest } = getChainsToRequest({
        client: options.client,
        chain: chainToRequest,
        optionalChains: optionalChains,
    });
    const provider = await EthereumProvider.init({
        showQrModal: wcOptions?.showQrModal === undefined
            ? sessionRequestHandler
                ? false
                : defaultShowQrModal
            : wcOptions.showQrModal,
        projectId: wcOptions?.projectId || constants_js_1.DEFAULT_PROJECT_ID,
        optionalMethods: OPTIONAL_METHODS,
        optionalEvents: OPTIONAL_EVENTS,
        optionalChains: chainsToRequest,
        chains: chainToRequest
            ? [chainToRequest.id]
            : chainsToRequest.length > 0
                ? [chainsToRequest[0]]
                : [1],
        metadata: {
            name: wcOptions?.appMetadata?.name || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().name,
            description: wcOptions?.appMetadata?.description ||
                (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().description,
            url: wcOptions?.appMetadata?.url || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().url,
            icons: [
                wcOptions?.appMetadata?.logoUrl || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().logoUrl,
            ],
        },
        rpcMap: rpcMap,
        qrModalOptions: wcOptions?.qrModalOptions,
        disableProviderPing: true,
    });
    provider.events.setMaxListeners(Number.POSITIVE_INFINITY);
    // disconnect the provider if chains are stale when (if not auto connecting)
    if (!isAutoConnect) {
        // const isStale = await isChainsStale(provider, chainsToRequest);
        if (provider.session) {
            await provider.disconnect();
        }
    }
    if (walletId !== "walletConnect") {
        function handleSessionRequest() {
            const walletLinkToOpen = provider.session?.peer?.metadata?.redirect?.native ||
                walletInfo.mobile.native ||
                walletInfo.mobile.universal;
            if (sessionRequestHandler && walletLinkToOpen) {
                sessionRequestHandler(walletLinkToOpen);
            }
        }
        provider.signer.client.on("session_request_sent", handleSessionRequest);
        provider.events.addListener("disconnect", () => {
            provider.signer.client.off("session_request_sent", handleSessionRequest);
        });
    }
    return provider;
}
function createAccount(provider, _address) {
    const address = (0, address_js_1.getAddress)(_address);
    const account = {
        address: address,
        async sendTransaction(tx) {
            const transactionHash = (await provider.request({
                method: "eth_sendTransaction",
                params: [
                    {
                        gas: tx.gas ? (0, hex_js_1.numberToHex)(tx.gas) : undefined,
                        value: tx.value ? (0, hex_js_1.numberToHex)(tx.value) : undefined,
                        from: this.address,
                        to: tx.to,
                        data: tx.data,
                    },
                ],
            }));
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            const messageToSign = (() => {
                if (typeof message === "string") {
                    return (0, hex_js_1.stringToHex)(message);
                }
                if (message.raw instanceof Uint8Array) {
                    return (0, hex_js_1.uint8ArrayToHex)(message.raw);
                }
                return message.raw;
            })();
            return provider.request({
                method: "personal_sign",
                params: [messageToSign, this.address],
            });
        },
        async signTypedData(_data) {
            const data = (0, parseTypedData_js_1.parseTypedData)(_data);
            const { domain, message, primaryType } = data;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...data.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const typedData = (0, viem_1.serializeTypedData)({
                domain: domain ?? {},
                message,
                primaryType,
                types,
            });
            return await provider.request({
                method: "eth_signTypedData_v4",
                params: [this.address, typedData],
            });
        },
    };
    return account;
}
function onConnect(address, chain, provider, emitter, storage) {
    const account = createAccount(provider, address);
    async function disconnect() {
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
        await provider.disconnect();
    }
    function onDisconnect() {
        setRequestedChainsIds([], storage);
        storage?.removeItem(storageKeys.lastUsedChainId);
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts[0]) {
            const newAccount = createAccount(provider, (0, address_js_1.getAddress)(accounts[0]));
            emitter.emit("accountChanged", newAccount);
            emitter.emit("accountsChanged", accounts);
        }
        else {
            onDisconnect();
        }
    }
    function onChainChanged(newChainId) {
        const newChain = (0, utils_js_1.getCachedChain)((0, normalizeChainId_js_1.normalizeChainId)(newChainId));
        emitter.emit("chainChanged", newChain);
        storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));
    }
    provider.on("accountsChanged", onAccountsChanged);
    provider.on("chainChanged", onChainChanged);
    provider.on("disconnect", onDisconnect);
    provider.on("session_delete", onDisconnect);
    return [
        account,
        chain,
        disconnect,
        (newChain) => switchChainWC(provider, newChain, storage),
    ];
}
// Storage utils  -----------------------------------------------------------------------------------------------
function getNamespaceMethods(provider) {
    return provider.session?.namespaces[constants_js_1.NAMESPACE]?.methods || [];
}
function getNamespaceChainsIds(provider) {
    const chainIds = provider.session?.namespaces[constants_js_1.NAMESPACE]?.chains?.map((chain) => Number.parseInt(chain.split(":")[1] || ""));
    return chainIds ?? [];
}
async function switchChainWC(provider, chain, storage) {
    const chainId = chain.id;
    try {
        const namespaceChains = getNamespaceChainsIds(provider);
        const namespaceMethods = getNamespaceMethods(provider);
        const isChainApproved = namespaceChains.includes(chainId);
        if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
            const apiChain = await (0, utils_js_1.getChainMetadata)(chain);
            const blockExplorerUrls = [
                ...new Set([
                    ...(chain.blockExplorers?.map((x) => x.url) || []),
                    ...(apiChain.explorers?.map((x) => x.url) || []),
                ]),
            ];
            await provider.request({
                method: ADD_ETH_CHAIN_METHOD,
                params: [
                    {
                        chainId: (0, hex_js_1.numberToHex)(apiChain.chainId),
                        chainName: apiChain.name,
                        nativeCurrency: apiChain.nativeCurrency,
                        rpcUrls: (0, chains_js_1.getValidPublicRPCUrl)(apiChain), // no clientId on purpose
                        blockExplorerUrls: blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined,
                    },
                ],
            });
            const requestedChains = await getRequestedChainsIds(storage);
            requestedChains.push(chainId);
            setRequestedChainsIds(requestedChains, storage);
        }
        await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: (0, hex_js_1.numberToHex)(chainId) }],
        });
    }
    catch (error) {
        const message = typeof error === "string" ? error : error?.message;
        if (/user rejected request/i.test(message)) {
            throw new viem_1.UserRejectedRequestError(error);
        }
        throw new viem_1.SwitchChainError(error);
    }
}
/**
 * Set the requested chains to the storage.
 * @internal
 */
function setRequestedChainsIds(chains, storage) {
    storage?.setItem(storageKeys.requestedChains, JSON.stringify(chains));
}
/**
 * Get the last requested chains from the storage.
 * @internal
 */
async function getRequestedChainsIds(storage) {
    const data = await storage.getItem(storageKeys.requestedChains);
    return data ? JSON.parse(data) : [];
}
function getChainsToRequest(options) {
    const rpcMap = {};
    if (options.chain) {
        rpcMap[options.chain.id] = (0, utils_js_1.getRpcUrlForChain)({
            chain: options.chain,
            client: options.client,
        });
    }
    // limit optional chains to 10
    const optionalChains = (options?.optionalChains || []).slice(0, 10);
    for (const chain of optionalChains) {
        rpcMap[chain.id] = (0, utils_js_1.getRpcUrlForChain)({
            chain: chain,
            client: options.client,
        });
    }
    const optionalChainIds = optionalChains.map((c) => c.id) || [];
    const chainsToRequest = options.chain
        ? [options.chain.id, ...optionalChainIds]
        : optionalChainIds.length > 0
            ? optionalChainIds
            : [1];
    if (!options.chain && optionalChains.length === 0) {
        rpcMap[1] = (0, utils_js_1.getCachedChain)(1).rpc;
    }
    return {
        rpcMap,
        chainsToRequest,
    };
}
const chainsToRequestForSafe = [
    1, // Ethereum Mainnet
    11155111, // Sepolia Testnet
    42161, // Arbitrum One Mainnet
    43114, // Avalanche Mainnet
    8453, // Base Mainnet
    1313161554, // Aurora Mainnet
    84532, // Base Sepolia Testnet
    56, // Binance Smart Chain Mainnet
    42220, // Celo Mainnet
    100, // Gnosis Mainnet
    10, // Optimism Mainnet
    137, // Polygon Mainnet
    1101, // Polygon zkEVM Mainnet
    324, // zkSync Era mainnet
    534352, // Scroll mainnet
];
//# sourceMappingURL=controller.js.map