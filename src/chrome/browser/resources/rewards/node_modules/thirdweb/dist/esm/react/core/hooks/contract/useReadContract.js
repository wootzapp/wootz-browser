import { queryOptions as defineQuery, useQuery, } from "@tanstack/react-query";
import { readContract, } from "../../../../transaction/read-contract.js";
import { getFunctionId } from "../../../../utils/function-id.js";
import { stringify } from "../../../../utils/json.js";
export function useReadContract(extensionOrOptions, options) {
    // extension case
    if (typeof extensionOrOptions === "function") {
        if (!options) {
            throw new Error(`Missing second argument for "useReadContract(<extension>, <options>)" hook.`);
        }
        const { queryOptions, contract, ...params } = options;
        const query = defineQuery({
            queryKey: [
                "readContract",
                contract.chain.id,
                contract.address,
                getFunctionId(extensionOrOptions),
                stringify(params),
            ],
            // @ts-expect-error - TODO: clean up the type issues here
            queryFn: () => extensionOrOptions({ ...params, contract }),
            ...queryOptions,
        });
        // TODO - FIX LATER
        // biome-ignore lint/correctness/useHookAtTopLevel: <explanation>
        return useQuery(query);
    }
    // raw tx case
    if ("method" in extensionOrOptions) {
        const { queryOptions, ...tx } = extensionOrOptions;
        const query = defineQuery({
            queryKey: [
                "readContract",
                tx.contract.chain.id,
                tx.contract.address,
                tx.method,
                stringify(tx.params),
            ],
            queryFn: () => readContract(extensionOrOptions),
            ...queryOptions,
        });
        // TODO - FIX LATER
        // biome-ignore lint/correctness/useHookAtTopLevel: <explanation>
        return useQuery(query);
    }
    throw new Error(`Invalid "useReadContract" options. Expected either a read extension or a transaction object.`);
}
//# sourceMappingURL=useReadContract.js.map