"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNFTAsset = getNFTAsset;
exports.computeStatus = computeStatus;
exports.getAllInBatches = getAllInBatches;
const isERC721_js_1 = require("../erc721/read/isERC721.js");
const isERC1155_js_1 = require("../erc1155/read/isERC1155.js");
/**
 * Retrieves the NFT asset based on the provided options.
 * @param options The transaction options.
 * @returns A promise that resolves to the NFT asset.
 * @extension MARKETPLACE
 * @example
 * ```ts
 * import { getNFTAsset } from "thirdweb/extensions/marketplace";
 *
 * const nft = await getNFTAsset({ contract, tokenId: 1n });
 * ```
 */
async function getNFTAsset(options) {
    const [erc721, erc1155] = await Promise.all([
        (0, isERC721_js_1.isERC721)(options),
        (0, isERC1155_js_1.isERC1155)(options),
    ]);
    switch (true) {
        case erc721: {
            const { getNFT } = await Promise.resolve().then(() => require("../erc721/read/getNFT.js"));
            return getNFT(options);
        }
        case erc1155: {
            const { getNFT } = await Promise.resolve().then(() => require("../erc1155/read/getNFT.js"));
            return getNFT(options);
        }
        default: {
            throw new Error("Contract is neither ERC721 nor ERC1155.");
        }
    }
}
function computeStatus(options) {
    switch (options.listingStatus) {
        case 1: {
            if (options.startTimestamp > options.blockTimeStamp) {
                return "CREATED";
            }
            if (options.endTimestamp < options.blockTimeStamp) {
                return "EXPIRED";
            }
            return "ACTIVE";
        }
        case 2: {
            return "COMPLETED";
        }
        case 3: {
            return "CANCELLED";
        }
        default: {
            throw new Error(`Invalid listing status: "${options.listingStatus}"`);
        }
    }
}
/**
 * @internal
 */
async function getAllInBatches(fn, options) {
    let start = options.start;
    const batches = [];
    while (options.end - start > options.maxSize) {
        batches.push(fn(start, options.end + options.maxSize - 1n));
        start += options.maxSize;
    }
    batches.push(fn(start, options.end - 1n));
    return await Promise.all(batches);
}
//# sourceMappingURL=utils.js.map