"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useBuyTransactionsToShow = useBuyTransactionsToShow;
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const getStatus_js_1 = require("../../../../../../../pay/buyWithCrypto/getStatus.js");
const getStatus_js_2 = require("../../../../../../../pay/buyWithFiat/getStatus.js");
const useBuyHistory_js_1 = require("../../../../../../core/hooks/pay/useBuyHistory.js");
const useActiveAccount_js_1 = require("../../../../../../core/hooks/wallets/useActiveAccount.js");
const pendingSwapTx_js_1 = require("../swap/pendingSwapTx.js");
function useBuyTransactionsToShow(client) {
    const account = (0, useActiveAccount_js_1.useActiveAccount)();
    const [pageIndex, setPageIndex] = (0, react_1.useState)(0);
    const txStatusList = [];
    const PAGE_SIZE = 10;
    const buyHistory = (0, useBuyHistory_js_1.useBuyHistory)({
        walletAddress: account?.address || "",
        start: pageIndex * PAGE_SIZE,
        count: PAGE_SIZE,
        client,
    }, {
        refetchInterval: 10 * 1000, // 10 seconds
    });
    const pendingTxStoreValue = (0, react_1.useSyncExternalStore)(pendingSwapTx_js_1.pendingTransactions.subscribe, pendingSwapTx_js_1.pendingTransactions.getValue);
    const pendingStatusQueries = (0, react_query_1.useQueries)({
        queries: pendingTxStoreValue.map((tx) => {
            return {
                queryKey: ["pending-tx-status", tx],
                queryFn: async () => {
                    if (tx.type === "swap") {
                        const swapStatus = await (0, getStatus_js_1.getBuyWithCryptoStatus)({
                            client: client,
                            transactionHash: tx.txHash,
                        });
                        if (swapStatus.status === "NOT_FOUND" ||
                            swapStatus.status === "NONE") {
                            return null;
                        }
                        return {
                            type: "swap",
                            status: swapStatus,
                        };
                    }
                    const fiatStatus = await (0, getStatus_js_2.getBuyWithFiatStatus)({
                        client: client,
                        intentId: tx.intentId,
                    });
                    if (fiatStatus.status === "NOT_FOUND" ||
                        fiatStatus.status === "NONE") {
                        return null;
                    }
                    return {
                        type: "fiat",
                        status: fiatStatus,
                    };
                },
                refetchInterval: 10 * 1000, // 10 seconds
            };
        }),
    });
    if (pendingStatusQueries.length > 0 && pageIndex === 0) {
        for (const query of pendingStatusQueries) {
            if (query.data) {
                const txStatusInfo = query.data;
                // if already present in endpoint - don't add it
                if (buyHistory.data) {
                    if (txStatusInfo.type === "swap") {
                        const isPresent = buyHistory.data.page.find((tx) => {
                            if ("buyWithCryptoStatus" in tx &&
                                tx.buyWithCryptoStatus.status !== "NOT_FOUND") {
                                return (tx.buyWithCryptoStatus.source?.transactionHash ===
                                    txStatusInfo.status.source?.transactionHash);
                            }
                            return false;
                        });
                        if (!isPresent) {
                            txStatusList.push(txStatusInfo);
                        }
                    }
                    if (txStatusInfo.type === "fiat") {
                        const isPresent = buyHistory.data.page.find((tx) => {
                            if ("buyWithFiatStatus" in tx &&
                                tx.buyWithFiatStatus.status !== "NOT_FOUND") {
                                return (tx.buyWithFiatStatus.intentId === txStatusInfo.status.intentId);
                            }
                            return false;
                        });
                        if (!isPresent) {
                            txStatusList.push(txStatusInfo);
                        }
                    }
                }
                else {
                    // if no buy history available for this walllet - add without duplicate check
                    txStatusList.push(txStatusInfo);
                }
            }
        }
    }
    if (buyHistory.data) {
        for (const tx of buyHistory.data.page) {
            if ("buyWithCryptoStatus" in tx) {
                if (tx.buyWithCryptoStatus.status !== "NOT_FOUND" &&
                    tx.buyWithCryptoStatus.status !== "NONE") {
                    txStatusList.push({
                        type: "swap",
                        status: tx.buyWithCryptoStatus,
                    });
                }
            }
            else {
                if (tx.buyWithFiatStatus.status !== "NOT_FOUND" &&
                    tx.buyWithFiatStatus.status !== "NONE") {
                    txStatusList.push({
                        type: "fiat",
                        status: tx.buyWithFiatStatus,
                    });
                }
            }
        }
    }
    const hidePagination = !buyHistory.data ||
        (buyHistory.data && !buyHistory.data.hasNextPage && pageIndex === 0);
    return {
        pageIndex,
        setPageIndex,
        txInfosToShow: txStatusList,
        hidePagination,
        isLoading: buyHistory.isLoading,
        pagination: buyHistory.data
            ? {
                hasNextPage: buyHistory.data.hasNextPage,
            }
            : undefined,
    };
}
//# sourceMappingURL=useBuyTransactionsToShow.js.map