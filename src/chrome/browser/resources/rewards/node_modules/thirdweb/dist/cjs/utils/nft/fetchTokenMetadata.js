"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTokenMetadata = fetchTokenMetadata;
const base64_js_1 = require("../base64/base64.js");
const hex_js_1 = require("../encoding/hex.js");
/**
 * Fetches the metadata for a token.
 *
 * @param options - The options for fetching the token metadata.
 * @returns The token metadata.
 * @internal
 */
async function fetchTokenMetadata(options) {
    const { client, tokenId, tokenUri } = options;
    // handle case where the URI is a base64 encoded JSON (onchain nft)
    if ((0, base64_js_1.isBase64JSON)(tokenUri)) {
        try {
            return JSON.parse((0, base64_js_1.parseBase64String)(tokenUri));
        }
        catch (e) {
            console.error("Failed to fetch base64 encoded NFT", { tokenId, tokenUri }, e);
            throw e;
        }
    }
    // in all other cases we will need the `download` function from storage
    const { download } = await Promise.resolve().then(() => require("../../storage/download.js"));
    // handle non-dynamic uris (most common case -> skip the other checks)
    try {
        if (!tokenUri.includes("{id}")) {
            return await (await download({ client, uri: tokenUri })).json();
        }
    }
    catch (e) {
        console.error("Failed to fetch non-dynamic NFT", { tokenId, tokenUri }, e);
        throw e;
    }
    // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)
    try {
        try {
            // try first dynamic id format
            return await (await download({
                client,
                uri: tokenUri.replace("{id}", (0, hex_js_1.numberToHex)(tokenId, { size: 32 }).slice(2)),
            })).json();
        }
        catch {
            // otherwise attempt the second format
            return await (await download({
                client,
                uri: tokenUri.replace("{id}", tokenId.toString()),
            })).json();
        }
    }
    catch (e) {
        console.error("Failed to fetch dynamic NFT", { tokenId, tokenUri }, e);
        throw e;
    }
}
//# sourceMappingURL=fetchTokenMetadata.js.map