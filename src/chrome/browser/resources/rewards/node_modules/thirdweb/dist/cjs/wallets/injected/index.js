"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInjectedWallet = isInjectedWallet;
exports.getInjectedProvider = getInjectedProvider;
exports.connectInjectedWallet = connectInjectedWallet;
exports.autoConnectInjectedWallet = autoConnectInjectedWallet;
const viem_1 = require("viem");
const utils_js_1 = require("../../chains/utils.js");
const address_js_1 = require("../../utils/address.js");
const hex_js_1 = require("../../utils/encoding/hex.js");
const chains_js_1 = require("../utils/chains.js");
const normalizeChainId_js_1 = require("../utils/normalizeChainId.js");
const mipdStore_js_1 = require("./mipdStore.js");
const parseTypedData_js_1 = require("../../utils/signatures/helpers/parseTypedData.js");
/**
 * Checks if the provided wallet is an injected wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is an injected wallet, false otherwise.
 */
function isInjectedWallet(wallet) {
    return !!(0, mipdStore_js_1.injectedProvider)(wallet.id);
}
// TODO: save the provider in data
function getInjectedProvider(walletId) {
    const provider = (0, mipdStore_js_1.injectedProvider)(walletId);
    if (!provider) {
        throw new Error(`No injected provider found for wallet: "${walletId}"`);
    }
    return provider;
}
/**
 * @internal
 */
async function connectInjectedWallet(id, options, emitter) {
    const provider = getInjectedProvider(id);
    const addresses = await provider.request({
        method: "eth_requestAccounts",
    });
    const addr = addresses[0];
    if (!addr) {
        throw new Error("no accounts available");
    }
    // use the first account
    const address = (0, address_js_1.getAddress)(addr);
    // get the chainId the provider is on
    const chainId = await provider
        .request({ method: "eth_chainId" })
        .then(normalizeChainId_js_1.normalizeChainId);
    let connectedChain = options.chain && options.chain.id === chainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(chainId);
    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain
    if (options.chain && options.chain.id !== chainId) {
        await switchChain(provider, options.chain);
        connectedChain = options.chain;
    }
    return onConnect(provider, address, connectedChain, emitter);
}
/**
 * @internal
 */
async function autoConnectInjectedWallet(id, emitter, chain) {
    const provider = getInjectedProvider(id);
    // connected accounts
    const addresses = await provider.request({
        method: "eth_accounts",
    });
    const addr = addresses[0];
    if (!addr) {
        throw new Error("no accounts available");
    }
    // use the first account
    const address = (0, address_js_1.getAddress)(addr);
    // get the chainId the provider is on
    const chainId = await provider
        .request({ method: "eth_chainId" })
        .then(normalizeChainId_js_1.normalizeChainId);
    const connectedChain = chain && chain.id === chainId ? chain : (0, utils_js_1.getCachedChain)(chainId);
    return onConnect(provider, address, connectedChain, emitter);
}
function createAccount(provider, _address) {
    const account = {
        address: (0, address_js_1.getAddress)(_address),
        async sendTransaction(tx) {
            const transactionHash = (await provider.request({
                method: "eth_sendTransaction",
                params: [
                    {
                        accessList: tx.accessList,
                        value: tx.value ? (0, hex_js_1.numberToHex)(tx.value) : undefined,
                        gas: tx.gas ? (0, hex_js_1.numberToHex)(tx.gas) : undefined,
                        from: this.address,
                        to: tx.to,
                        data: tx.data,
                    },
                ],
            }));
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            if (!account.address) {
                throw new Error("Provider not setup");
            }
            const messageToSign = (() => {
                if (typeof message === "string") {
                    return (0, hex_js_1.stringToHex)(message);
                }
                if (message.raw instanceof Uint8Array) {
                    return (0, hex_js_1.uint8ArrayToHex)(message.raw);
                }
                return message.raw;
            })();
            return await provider.request({
                method: "personal_sign",
                params: [messageToSign, account.address],
            });
        },
        async signTypedData(typedData) {
            if (!provider || !account.address) {
                throw new Error("Provider not setup");
            }
            const parsedTypedData = (0, parseTypedData_js_1.parseTypedData)(typedData);
            const { domain, message, primaryType } = parsedTypedData;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...parsedTypedData.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const stringifiedData = (0, viem_1.serializeTypedData)({
                domain: domain ?? {},
                message,
                primaryType,
                types,
            });
            return await provider.request({
                method: "eth_signTypedData_v4",
                params: [account.address, stringifiedData],
            });
        },
        async watchAsset(asset) {
            const result = await provider.request({
                method: "wallet_watchAsset",
                params: asset,
            }, { retryCount: 0 });
            return result;
        },
    };
    return account;
}
/**
 * Call this method when the wallet provider is connected or auto connected
 * @internal
 */
async function onConnect(provider, address, chain, emitter) {
    const account = createAccount(provider, address);
    async function disconnect() {
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
    }
    async function onDisconnect() {
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts[0]) {
            const newAccount = createAccount(provider, (0, address_js_1.getAddress)(accounts[0]));
            emitter.emit("accountChanged", newAccount);
            emitter.emit("accountsChanged", accounts);
        }
        else {
            onDisconnect();
        }
    }
    function onChainChanged(newChainId) {
        const newChain = (0, utils_js_1.getCachedChain)((0, normalizeChainId_js_1.normalizeChainId)(newChainId));
        emitter.emit("chainChanged", newChain);
    }
    if (provider.on) {
        provider.on("accountsChanged", onAccountsChanged);
        provider.on("chainChanged", onChainChanged);
        provider.on("disconnect", onDisconnect);
    }
    return [
        account,
        chain,
        onDisconnect,
        (newChain) => switchChain(provider, newChain),
    ];
}
/**
 * @internal
 */
async function switchChain(provider, chain) {
    const hexChainId = (0, hex_js_1.numberToHex)(chain.id);
    try {
        await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: hexChainId }],
        });
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
    }
    catch (e) {
        // if chain does not exist, add the chain
        if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {
            const apiChain = await (0, utils_js_1.getChainMetadata)(chain);
            await provider.request({
                method: "wallet_addEthereumChain",
                params: [
                    {
                        chainId: hexChainId,
                        chainName: apiChain.name,
                        nativeCurrency: apiChain.nativeCurrency,
                        rpcUrls: (0, chains_js_1.getValidPublicRPCUrl)(apiChain), // no client id on purpose here
                        blockExplorerUrls: apiChain.explorers?.map((x) => x.url),
                    },
                ],
            });
        }
        else {
            throw e;
        }
    }
}
//# sourceMappingURL=index.js.map