{"version":3,"file":"GLTFInstance.js","sourceRoot":"","sources":["../../src/three-components/GLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Group, Mesh, Object3D, Texture} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils.js';\n\nimport {Constructor} from '../utilities.js';\n\n\n\nexport const $prepared = Symbol('prepared');\n\nexport interface PreparedGLTF extends GLTF {\n  [$prepared]?: boolean;\n}\n\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nexport class GLTFInstance implements GLTF {\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source: GLTF): PreparedGLTF {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n\n    if ((source as PreparedGLTF)[$prepared]) {\n      return source;\n    }\n\n    const prepared = this[$prepare](source) as Partial<PreparedGLTF>;\n\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n\n    return prepared as PreparedGLTF;\n  }\n\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  protected static[$prepare](source: GLTF): GLTF {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {scene} = source;\n    const scenes = [scene];\n\n    return {...source, scene, scenes};\n  }\n\n  protected[$preparedGLTF]: PreparedGLTF;\n\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n\n  constructor(preparedGLTF: PreparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone<T extends GLTFInstance>(): T {\n    const GLTFInstanceConstructor = this.constructor as Constructor<T>;\n    const clonedGLTF = this[$clone]();\n\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose(): void {\n    this.scenes.forEach((scene: Group) => {\n      scene.traverse((object: Object3D) => {\n        if (!(object as Mesh).isMesh) {\n          return;\n        }\n        const mesh = object as Mesh;\n        const materials =\n            Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          // Explicitly dispose any textures assigned to this material\n          for (const propertyName in material) {\n            const texture = (material as any)[propertyName];\n            if (texture instanceof Texture) {\n              const image = texture.source.data;\n              if (image.close != null) {\n                image.close();\n              }\n              texture.dispose();\n            }\n          }\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  protected[$clone](): PreparedGLTF {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = SkeletonUtils.clone(this.scene) as Group;\n    cloneVariantMaterials(scene, this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? {...source.userData} : {};\n    return {...source, scene, scenes, userData};\n  }\n}\n\n// Variant materials and original material instances are stored under\n// object.userData.variantMaterials/originalMaterial.\n// Three.js Object3D.clone() doesn't clone Three.js objects under\n// .userData so this function is a workaround.\nconst cloneVariantMaterials = (dst: Object3D, src: Object3D) => {\n  traversePair(dst, src, (dst, src) => {\n    if (src.userData.variantMaterials !== undefined) {\n      dst.userData.variantMaterials = new Map(src.userData.variantMaterials);\n    }\n    if (src.userData.variantData !== undefined) {\n      dst.userData.variantData = src.userData.variantData;\n    }\n    if (src.userData.originalMaterial !== undefined) {\n      dst.userData.originalMaterial = src.userData.originalMaterial;\n    }\n  });\n};\n\nconst traversePair =\n    (obj1: Object3D,\n     obj2: Object3D,\n     callback: (obj1: Object3D, obj2: Object3D) => void) => {\n      callback(obj1, obj2);\n      // Assume obj1 and obj2 have the same tree structure\n      for (let i = 0; i < obj1.children.length; i++) {\n        traversePair(obj1.children[i], obj2.children[i], callback);\n      }\n    };\n\nexport type GLTFInstanceConstructor =\n    Constructor<GLTFInstance, {prepare: typeof GLTFInstance['prepare']}>;\n"]}