{"version":3,"file":"TextureUtils.js","sourceRoot":"","sources":["../../src/three-components/TextureUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, BoxGeometry, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EventDispatcher, HalfFloatType, LinearEncoding, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, sRGBEncoding, Texture, TextureLoader, Vector3, WebGLCubeRenderTarget, WebGLRenderer} from 'three';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';\n\nimport {deserializeUrl, timePasses} from '../utilities.js';\n\nimport EnvironmentScene from './EnvironmentScene.js';\nimport EnvironmentSceneAlt from './EnvironmentSceneAlt.js';\n\nexport interface EnvironmentMapAndSkybox {\n  environmentMap: Texture;\n  skybox: Texture|null;\n}\n\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nhdrLoader.setDataType(HalfFloatType);\n\nexport default class TextureUtils extends EventDispatcher {\n  private generatedEnvironmentMap: Promise<CubeTexture>|null = null;\n  private generatedEnvironmentMapAlt: Promise<CubeTexture>|null = null;\n\n  private skyboxCache = new Map<string, Promise<Texture>>();\n\n  private blurMaterial: ShaderMaterial|null = null;\n  private blurScene: Scene|null = null;\n\n  constructor(private threeRenderer: WebGLRenderer) {\n    super();\n  }\n\n  async load(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<Texture> {\n    try {\n      const isHDR: boolean = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture: Texture = await new Promise<Texture>(\n          (resolve, reject) => loader.load(\n              url, resolve, (event: {loaded: number, total: number}) => {\n                progressCallback(event.loaded / event.total * 0.9);\n              }, reject));\n\n      progressCallback(1.0);\n\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n\n      if (!isHDR) {\n        texture.encoding = sRGBEncoding;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl: string|null = null, environmentMapUrl: string|null = null,\n      progressCallback: (progress: number) => void = () => {}):\n      Promise<EnvironmentMapAndSkybox> {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n\n    let skyboxLoads: Promise<Texture|null> = Promise.resolve(null);\n    let environmentMapLoads: Promise<Texture>;\n\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    }\n\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads =\n          this.loadEquirectFromUrl(environmentMapUrl, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads =\n          this.loadEquirectFromUrl(skyboxUrl, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ?\n          this.loadGeneratedEnvironmentMapAlt() :\n          this.loadGeneratedEnvironmentMap();\n    }\n\n    const [environmentMap, skybox] =\n        await Promise.all([environmentMapLoads, skyboxLoads]);\n\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n\n    return {environmentMap, skybox};\n  }\n\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  private async loadEquirectFromUrl(\n      url: string,\n      progressCallback: (progress: number) => void): Promise<Texture> {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.load(url, progressCallback);\n\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n\n    return this.skyboxCache.get(url)!;\n  }\n\n  private async GenerateEnvironmentMap(scene: Scene, name: string) {\n    await timePasses();\n\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      encoding: LinearEncoding,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n\n    cubeCamera.update(renderer, scene);\n\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n\n    return generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  private async loadGeneratedEnvironmentMap(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap =\n          this.GenerateEnvironmentMap(new EnvironmentScene(), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  private async loadGeneratedEnvironmentMapAlt(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt =\n          this.GenerateEnvironmentMap(new EnvironmentSceneAlt(), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n\n  private blurCubemap(cubeTarget: WebGLCubeRenderTarget, sigma: number) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial!);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n\n  private halfblur(\n      targetIn: WebGLCubeRenderTarget, targetOut: WebGLCubeRenderTarget,\n      sigmaRadians: number, direction: 'latitudinal'|'longitudinal') {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ?\n        Math.PI / (2 * pixels) :\n        2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ?\n        1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) :\n        MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${\n          sigmaRadians}, is too large and will clip, as it requested ${\n          samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    const blurUniforms = this.blurMaterial!.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene!);\n  }\n\n  private getBlurShader(maxSamples: number) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n\n      name: 'SphericalGaussianBlur',\n\n      defines: {'n': maxSamples},\n\n      uniforms: {\n        'envMap': {value: null},\n        'samples': {value: 1},\n        'weights': {value: weights},\n        'latitudinal': {value: false},\n        'dTheta': {value: 0},\n        'poleAxis': {value: poleAxis}\n      },\n\n      vertexShader: /* glsl */ `\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n\n      fragmentShader: /* glsl */ `\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n\n    });\n\n    return shaderMaterial;\n  }\n\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}\n"]}