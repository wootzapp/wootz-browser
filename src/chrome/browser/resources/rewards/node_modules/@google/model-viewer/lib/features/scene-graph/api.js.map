{"version":3,"file":"api.js","sourceRoot":"","sources":["../../../src/features/scene-graph/api.ts"],"names":[],"mappings":"","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {AlphaMode, MagFilter, MinFilter, WrapMode} from '../../three-components/gltf-instance/gltf-2.0.js';\n\n\n\n/**\n * All constructs in a 3DOM scene graph have a corresponding string name.\n * This is similar in spirit to the concept of a \"tag name\" in HTML, and exists\n * in support of looking up 3DOM elements by type.\n */\nexport declare interface ThreeDOMElementMap {\n  'model': Model;\n  'material': Material;\n  'pbr-metallic-roughness': PBRMetallicRoughness;\n  'sampler': Sampler;\n  'image': Image;\n  'texture': Texture;\n  'texture-info': TextureInfo;\n}\n\n/**\n * A Model is the root element of a 3DOM scene graph. It gives scripts access\n * to the sub-elements found without the graph.\n */\nexport declare interface Model {\n  /**\n   * An ordered set of unique Materials found in this model. The Materials\n   * correspond to the listing of materials in the glTF, with the possible\n   * addition of a default material at the end.\n   */\n  readonly materials: Readonly<Material[]>;\n\n  /**\n   * Gets a material(s) by name.\n   * @param name the name of the material to return.\n   * @returns the first material to whose name matches `name`\n   */\n  getMaterialByName(name: string): Material|null;\n\n  /**\n   * Creates a new material variant from an existing material.\n   * @param originalMaterialIndex index of the material to clone the variant\n   *     from.\n   * @param materialName the name of the new material\n   * @param variantName the name of the variant\n   * @param activateVariant activates this material variant, i.e. the variant\n   *     material is rendered, not the existing material.\n   * @returns returns a clone of the original material, returns `null` if the\n   *     material instance for this variant already exists.\n   */\n  createMaterialInstanceForVariant(\n      originalMaterialIndex: number, newMaterialName: string,\n      variantName: string, activateVariant: boolean): Material|null;\n\n  /**\n   * Adds a variant name to the model.\n   * @param variantName\n   */\n  createVariant(variantName: string): void;\n\n  /**\n   * Adds an existing material to a variant name.\n   * @param materialIndex\n   * @param targetVariantName\n   */\n  setMaterialToVariant(materialIndex: number, targetVariantName: string): void;\n\n  /**\n   * Removes the variant name from the model.\n   * @param variantName the variant to remove.\n   */\n  deleteVariant(variantName: string): void;\n}\n\n/**\n * A Material gives the script access to modify a single, unique material found\n * in a model's scene graph.\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-material\n */\nexport declare interface Material {\n  /**\n   * The name of the material, if any.\n   */\n  name: string;\n\n  readonly normalTexture: TextureInfo|null;\n  readonly occlusionTexture: TextureInfo|null;\n  readonly emissiveTexture: TextureInfo|null;\n\n  readonly emissiveFactor: Readonly<RGB>;\n  setEmissiveFactor(rgb: RGB|string): void;\n  setAlphaCutoff(cutoff: number): void;\n  getAlphaCutoff(): number;\n  setDoubleSided(doubleSided: boolean): void;\n  getDoubleSided(): boolean;\n  setAlphaMode(alphaMode: AlphaMode): void;\n  getAlphaMode(): AlphaMode;\n\n  /**\n   * The PBRMetallicRoughness configuration of the material.\n   */\n  readonly pbrMetallicRoughness: PBRMetallicRoughness;\n\n  /**\n   * Asynchronously loads the underlying material resource if it's currently\n   * unloaded, otherwise the method is a noop.\n   */\n  ensureLoaded(): void;\n\n  /**\n   * Returns true if the material participates in the variant.\n   * @param name the variant name.\n   */\n  hasVariant(name: string): boolean;\n\n  /**\n   * Returns true if the material is loaded.\n   */\n  readonly isLoaded: boolean;\n\n  /**\n   * Returns true if the material is participating in scene renders.\n   */\n  readonly isActive: boolean;\n\n  /**\n   * Returns the glTF index of this material.\n   */\n  readonly index: number;\n}\n\n/**\n * The PBRMetallicRoughness encodes the PBR properties of a material\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-pbrmetallicroughness\n */\nexport declare interface PBRMetallicRoughness {\n  /**\n   * The base color factor of the material, represented as RGBA values\n   */\n  readonly baseColorFactor: Readonly<RGBA>;\n\n  /**\n   * Metalness factor of the material, represented as number between 0 and 1\n   */\n  readonly metallicFactor: number;\n\n  /**\n   * Roughness factor of the material, represented as number between 0 and 1\n   */\n  readonly roughnessFactor: number;\n\n  /**\n   * A texture reference, associating an image with color information and\n   * a sampler for describing base color factor for a UV coordinate space.\n   */\n  readonly baseColorTexture: TextureInfo|null;\n\n  /**\n   * A texture reference, associating an image with color information and\n   * a sampler for describing metalness (B channel) and roughness (G channel)\n   * for a UV coordinate space.\n   */\n  readonly metallicRoughnessTexture: TextureInfo|null;\n\n  /**\n   * Changes the base color factor of the material to the given value.\n   */\n  setBaseColorFactor(rgba: RGBA|string): void;\n\n  /**\n   * Changes the metalness factor of the material to the given value.\n   */\n  setMetallicFactor(value: number): void;\n\n  /**\n   * Changes the roughness factor of the material to the given value.\n   */\n  setRoughnessFactor(value: number): void;\n}\n\n/**\n * A TextureInfo is a pointer to a specific Texture in use on a Material\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-textureinfo\n */\nexport declare interface TextureInfo {\n  /**\n   * The Texture being referenced by this TextureInfo\n   */\n  readonly texture: Texture|null;\n\n  /**\n   * Sets the texture, or removes it if argument is null. Note you cannot build\n   * your own Texture object, but must either use one from another TextureInfo,\n   * or create one with the createTexture method.\n   */\n  setTexture(texture: Texture|null): void;\n}\n\n/**\n * A Texture pairs an Image and a Sampler for use in a Material\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-texture\n */\nexport declare interface Texture {\n  /**\n   * The name of the texture, if any.\n   */\n  readonly name: string;\n\n  /**\n   * The Sampler for this Texture\n   */\n  readonly sampler: Sampler;\n\n  /**\n   * The source Image for this Texture\n   */\n  readonly source: Image;\n}\n\n/**\n * A Sampler describes how to filter and wrap textures\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler\n */\nexport declare interface Sampler {\n  /**\n   * The name of the sampler, if any.\n   */\n  readonly name: string;\n\n  /**\n   * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#samplerminfilter\n   */\n  readonly minFilter: MinFilter;\n\n  /**\n   * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#samplermagfilter\n   */\n  readonly magFilter: MagFilter;\n\n  /**\n   * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#samplerwraps\n   */\n  readonly wrapS: WrapMode;\n\n  /**\n   * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#samplerwrapt\n   */\n  readonly wrapT: WrapMode;\n\n  /**\n   * Configure the minFilter value of the Sampler.\n   */\n  setMinFilter(filter: MinFilter): void;\n\n  /**\n   * Configure the magFilter value of the Sampler.\n   */\n  setMagFilter(filter: MagFilter): void;\n\n  /**\n   * Configure the S (U) wrap mode of the Sampler.\n   */\n  setWrapS(mode: WrapMode): void;\n\n  /**\n   * Configure the T (V) wrap mode of the Sampler.\n   */\n  setWrapT(mode: WrapMode): void;\n}\n\n\n/**\n * An Image represents an embedded or external image used to provide texture\n * color data.\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-image\n */\nexport declare interface Image {\n  /**\n   * The name of the image, if any.\n   */\n  readonly name: string;\n\n  /**\n   * The type is 'external' if the image has a configured URI. Otherwise, it is\n   * considered to be 'embedded'. Note: this distinction is only implied by the\n   * glTF spec, and is made explicit here for convenience.\n   */\n  readonly type: 'embedded'|'external';\n\n  /**\n   * The URI of the image, if it is external.\n   */\n  readonly uri?: string;\n\n  /**\n   * The bufferView of the image, if it is embedded.\n   */\n  readonly bufferView?: number\n\n  /**\n   * A method to create an object URL of this image at the desired\n   * resolution. Especially useful for KTX2 textures which are GPU compressed,\n   * and so are unreadable on the CPU without a method like this.\n   */\n  createThumbnail(width: number, height: number): Promise<string>;\n}\n\n/**\n * An RGBA-encoded color, with channels represented as floating point values\n * from [0,1].\n */\nexport declare type RGBA = [number, number, number, number];\nexport declare type RGB = [number, number, number];\n"]}