{"version":3,"file":"evaluators.js","sourceRoot":"","sources":["../../src/styles/evaluators.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {normalizeUnit} from './conversions';\nimport {ExpressionNode, ExpressionTerm, FunctionNode, IdentNode, NumberNode, numberNode, OperatorNode, Percentage, Unit, ZERO} from './parsers';\n\nexport type Evaluatable<T> = Evaluator<T>|T;\n\n/**\n * A NumberNodeSequence is a vector of NumberNodes with a specified\n * sequence of units.\n */\nexport type NumberNodeSequence<T extends Array<Unit>, U = never> = {\n  [I in keyof T]:\n      NumberNode&{\n        unit: T[I]|U;\n      };\n};\n\nexport type Sparse<T> = {\n  [I in keyof T]: null|T[I];\n};\n\n/**\n * Intrinsics describe the metadata required to do four things for any given\n * type of number-based CSS expression:\n *\n *  1. Establish the expected units of a final, evaluated result\n *  2. Provide a foundational value that percentages should scale against\n *  3. Describe the analog number values that correspond to various keywords\n *  4. Have an available concrete value to fallback to when needed\n *\n * Intrinsics must always specify a basis and the substitute values for the\n * keyword 'auto'.\n *\n * Intrinsics may optionally specify the substitute values for any additional\n * number of keywords.\n */\nexport interface Intrinsics<T extends Array<Unit> = []> {\n  basis: NumberNodeSequence<T>;\n  keywords: {\n    auto: Sparse<NumberNodeSequence<T, Percentage>>;\n    [index: string]: Sparse<NumberNodeSequence<T, Percentage>>;\n  };\n}\n\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nexport abstract class Evaluator<T> {\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(\n      node: ExpressionTerm|Evaluator<NumberNode>,\n      basis: NumberNode = ZERO): Evaluatable<NumberNode> {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node as NumberNode<'%'>, basis);\n      }\n      return node;\n    }\n\n    switch ((node as FunctionNode).name.value) {\n      case 'calc':\n        return new CalcEvaluator(node as FunctionNode, basis);\n      case 'env':\n        return new EnvEvaluator(node as FunctionNode);\n    }\n\n    return ZERO;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate<T extends NumberNode|IdentNode>(evaluatable: Evaluatable<T>):\n      T {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n\n    return evaluatable;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant<T>(evaluatable: Evaluatable<T>): boolean {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics<T extends Array<Unit>>(\n      evaluated: Array<any>, intrinsics: Intrinsics<T>): NumberNodeSequence<T> {\n    const {basis, keywords} = intrinsics;\n    const {auto} = keywords;\n\n    return basis.map<NumberNode>((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode =\n          evaluated[index] ? evaluated[index] : autoSubstituteNode;\n\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(\n            evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      }\n\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    }) as NumberNodeSequence<T>;\n  }\n\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant(): boolean {\n    return false;\n  }\n\n  protected[$lastValue]: T|null = null;\n\n  /**\n   * This method must be implemented by subclasses. Its implementation should be\n   * the actual steps to evaluate the AST, and should return the evaluated\n   * result.\n   */\n  protected abstract[$evaluate](): T;\n\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate(): T {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue]!;\n  }\n}\n\n\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n\n\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nexport class PercentageEvaluator extends Evaluator<NumberNode> {\n  protected[$percentage]: NumberNode<'%'>;\n  protected[$basis]: NumberNode;\n\n  constructor(percentage: NumberNode<'%'>, basis: NumberNode) {\n    super();\n\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n\n  get isConstant() {\n    return true;\n  }\n\n  [$evaluate]() {\n    return numberNode(\n        this[$percentage].number / 100 * this[$basis].number,\n        this[$basis].unit);\n  }\n}\n\n\nconst $identNode = Symbol('identNode');\n\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nexport class EnvEvaluator extends Evaluator<NumberNode> {\n  protected[$identNode]: IdentNode|null = null;\n\n  constructor(envFunction: FunctionNode) {\n    super();\n\n    const identNode =\n        envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n\n  get isConstant(): boolean {\n    return false;\n  };\n\n  [$evaluate](): NumberNode {\n    if (this[$identNode] != null) {\n      switch (this[$identNode]!.value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(\n              document.body.scrollHeight,\n              document.body.offsetHeight,\n              document.documentElement.clientHeight,\n              document.documentElement.scrollHeight,\n              document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition /\n                  (verticalScrollMax - window.innerHeight) ||\n              0;\n\n          return {type: 'number', number: scrollY, unit: null};\n      }\n    }\n\n    return ZERO;\n  }\n}\n\n\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evaluator');\n\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class CalcEvaluator extends Evaluator<NumberNode> {\n  protected[$evaluator]: Evaluator<NumberNode>|null = null;\n\n  constructor(calcFunction: FunctionNode, basis: NumberNode = ZERO) {\n    super();\n\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n\n    const terms: Array<ExpressionTerm> =\n        calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms: Array<ExpressionTerm|Evaluator<NumberNode>> = [];\n\n    while (terms.length) {\n      const term: ExpressionTerm = terms.shift()!;\n\n      if (secondOrderTerms.length > 0) {\n        const previousTerm =\n            secondOrderTerms[secondOrderTerms.length - 1] as ExpressionTerm;\n        if (previousTerm.type === 'operator' &&\n            IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop() as OperatorNode;\n          const leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return;\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(\n              operator,\n              Evaluator.evaluatableFor(leftValue, basis),\n              Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(\n          term.type === 'operator' ? term :\n                                     Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if ((operator as ExpressionTerm).type !== 'operator') {\n        return;\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(\n          operator as OperatorNode,\n          Evaluator.evaluatableFor(left, basis),\n          Evaluator.evaluatableFor(right, basis)));\n    }\n\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0] as Evaluator<NumberNode>;\n    }\n  }\n\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]!);\n  }\n\n  [$evaluate]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]!) :\n                                      ZERO;\n  }\n}\n\n\n\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class OperatorEvaluator extends Evaluator<NumberNode> {\n  protected[$operator]: OperatorNode;\n  protected[$left]: Evaluatable<NumberNode>;\n  protected[$right]: Evaluatable<NumberNode>;\n\n  constructor(\n      operator: OperatorNode, left: Evaluatable<NumberNode>,\n      right: Evaluatable<NumberNode>) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) &&\n        Evaluator.isConstant(this[$right]);\n  }\n\n  [$evaluate](): NumberNode {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {number: leftValue, unit: leftUnit} = leftNode;\n    const {number: rightValue, unit: rightUnit} = rightNode;\n\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n\n    return {type: 'number', number: value, unit};\n  }\n}\n\n\nexport type EvaluatedStyle<T extends Intrinsics<Array<Unit>>> = {\n  [I in keyof T['basis']]: number;\n}&Array<never>;\n\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nexport class StyleEvaluator<T extends Intrinsics<Array<any>>> extends\n    Evaluator<EvaluatedStyle<T>> {\n  protected[$intrinsics]: T;\n  protected[$evaluatables]: Array<Evaluatable<NumberNode|IdentNode>>;\n\n  constructor(expressions: Array<ExpressionNode>, intrinsics: T) {\n    super();\n\n    this[$intrinsics] = intrinsics;\n\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n\n    this[$evaluatables] =\n        intrinsics.basis.map<Evaluatable<NumberNode|IdentNode>>(\n            (basisNode, index) => {\n              const term = terms[index];\n              if (term == null) {\n                return {type: 'ident', value: 'auto'};\n              }\n\n              if (term.type === 'ident') {\n                return term;\n              }\n\n              return Evaluator.evaluatableFor(term, basisNode);\n            });\n  }\n\n  get isConstant(): boolean {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map<NumberNode|IdentNode>(\n        evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics])\n               .map<number>(numberNode => numberNode.number) as\n        EvaluatedStyle<T>;\n  }\n}\n\n// SphericalIntrinsics are Intrinsics that expect two angle terms\n// and one length term\nexport type SphericalIntrinsics = Intrinsics<['rad', 'rad', 'm']>;\n// Vector3Intrinsics expect three length terms\nexport type Vector3Intrinsics = Intrinsics<['m', 'm', 'm']>;\n"]}