{"version":3,"file":"scene-graph.js","sourceRoot":"","sources":["../../src/features/scene-graph.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {RepeatWrapping, sRGBEncoding, Texture, TextureLoader} from 'three';\nimport {GLTFExporter, GLTFExporterOptions} from 'three/examples/jsm/exporters/GLTFExporter.js';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $progressTracker, $renderer, $scene} from '../model-viewer-base.js';\nimport {GLTF} from '../three-components/gltf-instance/gltf-defaulted.js';\nimport {ModelViewerGLTFInstance} from '../three-components/gltf-instance/ModelViewerGLTFInstance.js';\nimport GLTFExporterMaterialsVariantsExtension from '../three-components/gltf-instance/VariantMaterialExporterPlugin';\nimport {Constructor} from '../utilities.js';\n\nimport {Image, PBRMetallicRoughness, Sampler, TextureInfo} from './scene-graph/api.js';\nimport {Material} from './scene-graph/material.js';\nimport {$availableVariants, $materialFromPoint, $prepareVariantsForExport, $switchVariant, Model} from './scene-graph/model.js';\nimport {Texture as ModelViewerTexture} from './scene-graph/texture';\n\n\n\nexport const $currentGLTF = Symbol('currentGLTF');\nexport const $originalGltfJson = Symbol('originalGltfJson');\nexport const $model = Symbol('model');\nconst $getOnUpdateMethod = Symbol('getOnUpdateMethod');\nconst $textureLoader = Symbol('textureLoader');\n\ninterface SceneExportOptions {\n  binary?: boolean, trs?: boolean, onlyVisible?: boolean,\n      maxTextureSize?: number, includeCustomExtensions?: boolean,\n      forceIndices?: boolean\n}\n\nexport interface SceneGraphInterface {\n  readonly model?: Model;\n  variantName: string|null;\n  readonly availableVariants: string[];\n  orientation: string;\n  scale: string;\n  readonly originalGltfJson: GLTF|null;\n  exportScene(options?: SceneExportOptions): Promise<Blob>;\n  createTexture(uri: string, type?: string): Promise<ModelViewerTexture|null>;\n  /**\n   * Intersects a ray with the scene and returns a list of materials who's\n   * objects were intersected.\n   * @param pixelX X coordinate of the mouse.\n   * @param pixelY Y coordinate of the mouse.\n   * @returns a material, if no intersection is made then null is returned.\n   */\n  materialFromPoint(pixelX: number, pixelY: number): Material|null;\n}\n\n/**\n * SceneGraphMixin manages exposes a model API in order to support operations on\n * the <model-viewer> scene graph.\n */\nexport const SceneGraphMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<SceneGraphInterface>&T => {\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    protected[$model]: Model|undefined = undefined;\n    protected[$currentGLTF]: ModelViewerGLTFInstance|null = null;\n    private[$textureLoader] = new TextureLoader();\n    private[$originalGltfJson]: GLTF|null = null;\n\n    @property({type: String, attribute: 'variant-name'})\n    variantName: string|null = null;\n\n    @property({type: String, attribute: 'orientation'})\n    orientation: string = '0 0 0';\n\n    @property({type: String, attribute: 'scale'}) scale: string = '1 1 1';\n\n    // Scene-graph API:\n    /** @export */\n    get model() {\n      return this[$model];\n    }\n\n    get availableVariants() {\n      return this.model ? this.model[$availableVariants]() : [] as string[];\n    }\n\n    /**\n     * Returns a deep copy of the gltf JSON as loaded. It will not reflect\n     * changes to the scene-graph, nor will editing it have any effect.\n     */\n    get originalGltfJson() {\n      return this[$originalGltfJson];\n    }\n\n    /**\n     * References to each element constructor. Supports instanceof checks; these\n     * classes are not directly constructable.\n     */\n    static Model: Constructor<Model>;\n    static Material: Constructor<Material>;\n    static PBRMetallicRoughness: Constructor<PBRMetallicRoughness>;\n    static Sampler: Constructor<Sampler>;\n    static TextureInfo: Constructor<TextureInfo>;\n    static Texture: Constructor<Texture>;\n    static Image: Constructor<Image>;\n\n    private[$getOnUpdateMethod]() {\n      return () => {\n        this[$needsRender]();\n      };\n    }\n\n    async createTexture(uri: string, type: string = 'image/png'):\n        Promise<ModelViewerTexture|null> {\n      const currentGLTF = this[$currentGLTF];\n      const texture: Texture = await new Promise<Texture>(\n          (resolve) => this[$textureLoader].load(uri, resolve));\n      if (!currentGLTF || !texture) {\n        return null;\n      }\n      // Applies default settings.\n      texture.encoding = sRGBEncoding;\n      texture.wrapS = RepeatWrapping;\n      texture.wrapT = RepeatWrapping;\n      texture.flipY = false;\n      texture.userData.mimeType = type;\n\n      return new ModelViewerTexture(this[$getOnUpdateMethod](), texture);\n    }\n\n    async updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('variantName')) {\n        const updateVariantProgress = this[$progressTracker].beginActivity();\n        updateVariantProgress(0.1);\n        const model = this[$model];\n        const {variantName} = this;\n\n        if (model != null) {\n          await model[$switchVariant](variantName!);\n          this[$needsRender]();\n          this.dispatchEvent(new CustomEvent('variant-applied'));\n        }\n        updateVariantProgress(1.0);\n      }\n\n      if (changedProperties.has('orientation') ||\n          changedProperties.has('scale')) {\n        if (!this.loaded) {\n          return;\n        }\n        const scene = this[$scene];\n        scene.applyTransform();\n        scene.updateBoundingBox();\n        scene.updateShadow();\n        this[$renderer].arRenderer.onUpdateScene();\n        this[$needsRender]();\n      }\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      const {currentGLTF} = this[$scene];\n\n      if (currentGLTF != null) {\n        const {correlatedSceneGraph} = currentGLTF;\n\n        if (correlatedSceneGraph != null &&\n            currentGLTF !== this[$currentGLTF]) {\n          this[$model] =\n              new Model(correlatedSceneGraph, this[$getOnUpdateMethod]());\n          this[$originalGltfJson] =\n              JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));\n        }\n\n        // KHR_materials_variants extension spec:\n        // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants\n\n        if ('variants' in currentGLTF.userData) {\n          this.requestUpdate('variantName');\n        }\n      }\n\n      this[$currentGLTF] = currentGLTF;\n    }\n\n    /** @export */\n    async exportScene(options?: SceneExportOptions): Promise<Blob> {\n      const scene = this[$scene];\n      return new Promise<Blob>(async (resolve, reject) => {\n        // Defaults\n        const opts = {\n          binary: true,\n          onlyVisible: true,\n          maxTextureSize: Infinity,\n          includeCustomExtensions: false,\n          forceIndices: false\n        } as GLTFExporterOptions;\n\n        Object.assign(opts, options);\n        // Not configurable\n        opts.animations = scene.animations;\n        opts.truncateDrawRange = true;\n\n        const shadow = scene.shadow;\n        let visible = false;\n        // Remove shadow from export\n        if (shadow != null) {\n          visible = shadow.visible;\n          shadow.visible = false;\n        }\n\n        await this[$model]![$prepareVariantsForExport]();\n\n        const exporter =\n            (new GLTFExporter() as any)\n                .register(\n                    (writer: any) =>\n                        new GLTFExporterMaterialsVariantsExtension(writer));\n        exporter.parse(\n            scene.model,\n            (gltf: object) => {\n              return resolve(new Blob(\n                  [opts.binary ? gltf as Blob : JSON.stringify(gltf)], {\n                    type: opts.binary ? 'application/octet-stream' :\n                                        'application/json'\n                  }));\n            },\n            () => {\n              return reject('glTF export failed');\n            },\n            opts);\n\n        if (shadow != null) {\n          shadow.visible = visible;\n        }\n      });\n    }\n\n    materialFromPoint(pixelX: number, pixelY: number): Material|null {\n      const scene = this[$scene];\n      const ndcCoords = scene.getNDC(pixelX, pixelY);\n      scene.raycaster.setFromCamera(ndcCoords, scene.getCamera());\n\n      return this[$model]![$materialFromPoint](scene.raycaster);\n    }\n  }\n\n  return SceneGraphModelViewerElement;\n};\n"]}