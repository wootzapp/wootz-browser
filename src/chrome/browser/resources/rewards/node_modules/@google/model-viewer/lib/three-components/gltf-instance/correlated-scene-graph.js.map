{"version":3,"file":"correlated-scene-graph.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/correlated-scene-graph.ts"],"names":[],"mappings":"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","sourcesContent":["import {Group, Material, Mesh, Object3D, Texture} from 'three';\nimport {GLTF as ThreeGLTF, GLTFReference, GLTFReferenceType} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {GLTF, GLTFElement} from '../../three-components/gltf-instance/gltf-2.0.js';\n\n\n\nexport type ThreeSceneObject = Object3D|Material|Texture;\ntype ThreeSceneObjectCallback = (a: ThreeSceneObject, b: ThreeSceneObject) =>\n    void;\n\nexport type ThreeObjectSet = Set<ThreeSceneObject>;\n\nexport type GLTFElementToThreeObjectMap = Map<GLTFElement, ThreeObjectSet>;\nexport type ThreeObjectToGLTFElementHandleMap =\n    Map<ThreeSceneObject, GLTFReference>;\n\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\n\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(\n      threeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph?: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](\n          threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n\n  private static[$correlateOriginalThreeGLTF](threeGLTF: ThreeGLTF):\n      CorrelatedSceneGraph {\n    const gltf = threeGLTF.parser.json as GLTF;\n\n    const associations =\n        threeGLTF.parser.associations as Map<ThreeSceneObject, GLTFReference>;\n    const gltfElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    const defaultMaterial = {name: 'Default'} as Material;\n    const defaultReference = {type: 'materials', index: -1};\n\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (threeMaterial instanceof Material &&\n          associations.get(threeMaterial) == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, {materials: defaultReference.index});\n      }\n    }\n\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        const objWithUserData = threeObject as {userData: {associations: {}}};\n        objWithUserData.userData = objWithUserData.userData || {};\n        objWithUserData.userData.associations = gltfMappings;\n      }\n\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping as GLTFReferenceType;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]!];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n\n          let threeObjects = gltfElementMap.get(gltfElement);\n\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n\n    return new CorrelatedSceneGraph(\n        threeGLTF, gltf, associations, gltfElementMap);\n  }\n\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  private static[$correlateCloneThreeGLTF](\n      cloneThreeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF: GLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap: ThreeObjectToGLTFElementHandleMap = new Map();\n    const cloneGLTFElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](\n          originalThreeGLTF.scenes[i],\n          cloneThreeGLTF.scenes[i],\n          (object: ThreeSceneObject, cloneObject: ThreeSceneObject) => {\n            const elementReference =\n                upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n\n            if (elementReference == null) {\n              return;\n            }\n\n            for (const mapping in elementReference) {\n              if (mapping != null && mapping !== 'primitives') {\n                const type = mapping as GLTFReferenceType;\n                const index = elementReference[type]!;\n                const cloneElement = cloneGLTF[type]![index];\n\n                const mappings =\n                    cloneThreeObjectMap.get(cloneObject) || {} as GLTFReference;\n                mappings[type] = index;\n                cloneThreeObjectMap.set(cloneObject, mappings);\n\n                const cloneObjects: Set<typeof cloneObject> =\n                    cloneGLTFElementMap.get(cloneElement) || new Set();\n                cloneObjects.add(cloneObject);\n\n                cloneGLTFElementMap.set(cloneElement, cloneObjects);\n              }\n            }\n          });\n    }\n\n    return new CorrelatedSceneGraph(\n        cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);\n  }\n\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  private static[$parallelTraverseThreeScene](\n      sceneOne: Group, sceneTwo: Group, callback: ThreeSceneObjectCallback) {\n    const isMesh = (object: unknown): object is Mesh => {\n      return (object as Mesh).isMesh;\n    };\n    const traverse = (a: ThreeSceneObject, b: ThreeSceneObject) => {\n      callback(a, b);\n\n      if ((a as Object3D).isObject3D) {\n        if (isMesh(a)) {\n          if (Array.isArray(a.material)) {\n            for (let i = 0; i < a.material.length; ++i) {\n              traverse(\n                  a.material[i], ((b as typeof a).material as Material[])[i]);\n            }\n          } else {\n            traverse(a.material, (b as typeof a).material as Material);\n          }\n        }\n\n        for (let i = 0; i < (a as Object3D).children.length; ++i) {\n          traverse((a as Object3D).children[i], (b as Object3D).children[i]);\n        }\n      }\n    };\n\n    traverse(sceneOne, sceneTwo);\n  }\n\n  private[$threeGLTF]: ThreeGLTF;\n  private[$gltf]: GLTF;\n  private[$gltfElementMap]: GLTFElementToThreeObjectMap;\n  private[$threeObjectMap]: ThreeObjectToGLTFElementHandleMap;\n\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF(): ThreeGLTF {\n    return this[$threeGLTF];\n  }\n\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf(): GLTF {\n    return this[$gltf];\n  }\n\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap(): GLTFElementToThreeObjectMap {\n    return this[$gltfElementMap];\n  }\n\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap(): ThreeObjectToGLTFElementHandleMap {\n    return this[$threeObjectMap];\n  }\n\n  constructor(\n      threeGLTF: ThreeGLTF, gltf: GLTF,\n      threeObjectMap: ThreeObjectToGLTFElementHandleMap,\n      gltfElementMap: GLTFElementToThreeObjectMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n}\n"]}