{"version":3,"file":"parsers.js","sourceRoot":"","sources":["../../src/styles/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// The operators that are available in CSS calc() functions\n// include symbols for addition, subtraction, multiplication and division\n// @see https://www.w3.org/TR/css-values-3/#calc-syntax\nexport type Operator = '+'|'-'|'*'|'/';\n\n// We only support units for length in meters, radians and degrees for angles\n// and percentage values\nexport type Unit = 'm'|'cm'|'mm'|'rad'|'deg';\nexport type Percentage = '%';\n\n// Any node that might appear in a parsed expression is referred to as an\n// ExpressionTerm\nexport type ExpressionTerm =\n    IdentNode|HexNode|NumberNode|OperatorNode|FunctionNode;\n\nexport interface IdentNode {\n  type: 'ident';\n  value: string;\n}\n\nexport interface HexNode {\n  type: 'hex';\n  value: string;\n}\n\nexport interface NumberNode<U = Unit | Percentage | null> {\n  type: 'number';\n  number: number;\n  unit: U;\n}\n\nexport const numberNode =\n    <T extends Unit|Percentage|null>(value: number, unit: T): NumberNode<T> =>\n        ({type: 'number', number: value, unit});\n\nexport interface OperatorNode {\n  type: 'operator';\n  value: Operator;\n}\n\nexport interface FunctionNode {\n  type: 'function';\n  name: IdentNode;\n  arguments: Array<ExpressionNode>;\n}\n\nexport interface ExpressionNode {\n  type: 'expression';\n  terms: Array<ExpressionTerm>;\n}\n\nexport type ASTNode =\n    IdentNode|HexNode|NumberNode|OperatorNode|FunctionNode|ExpressionNode;\n\n// As an internal detail of this module, non-exported parsers return both a\n// set of nodes and the remaining string input to be parsed. This saves us a bit\n// of book keeping work and allows our internal parser implementations to remain\n// essentially stateless.\ninterface ParseResult<T extends ASTNode> {\n  nodes: Array<T>;\n  remainingInput: string;\n}\n\n/**\n * Given a string representing a comma-separated set of CSS-like expressions,\n * parses and returns an array of ASTs that correspond to those expressions.\n *\n * Currently supported syntax includes:\n *\n *  - functions (top-level and nested)\n *  - calc() arithmetic operators\n *  - numbers with units\n *  - hexadecimal-encoded colors in 3, 6 or 8 digit form\n *  - idents\n *\n * All syntax is intended to match the parsing rules and semantics of the actual\n * CSS spec as closely as possible.\n *\n * @see https://www.w3.org/TR/CSS2/\n * @see https://www.w3.org/TR/css-values-3/\n */\nexport const parseExpressions = (() => {\n  const cache: {[index: string]: Array<ExpressionNode>} = {};\n  const MAX_PARSE_ITERATIONS = 1000;  // Arbitrarily large\n\n  return (inputString: string): Array<ExpressionNode> => {\n    const cacheKey = inputString;\n\n    if (cacheKey in cache) {\n      return cache[cacheKey];\n    }\n\n    const expressions: Array<ExpressionNode> = [];\n    let parseIterations = 0;\n\n    while (inputString) {\n      if (++parseIterations > MAX_PARSE_ITERATIONS) {\n        // Avoid a potentially infinite loop due to typos:\n        inputString = '';\n        break;\n      }\n\n      const expressionParseResult = parseExpression(inputString);\n      const expression = expressionParseResult.nodes[0];\n\n      if (expression == null || expression.terms.length === 0) {\n        break;\n      }\n\n      expressions.push(expression);\n      inputString = expressionParseResult.remainingInput;\n    }\n\n    return cache[cacheKey] = expressions;\n  };\n})();\n\n\n/**\n * Parse a single expression. For the purposes of our supported syntax, an\n * expression is the set of semantically meaningful terms that appear before the\n * next comma, or between the parens of a function invocation.\n */\nconst parseExpression = (() => {\n  const IS_IDENT_RE = /^(\\-\\-|[a-z\\u0240-\\uffff])/i;\n  const IS_OPERATOR_RE = /^([\\*\\+\\/]|[\\-]\\s)/i;\n  const IS_EXPRESSION_END_RE = /^[\\),]/;\n  const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';\n  const HEX_FIRST_TOKEN = '#';\n\n  return (inputString: string): ParseResult<ExpressionNode> => {\n    const terms: Array<ExpressionTerm> = [];\n\n    while (inputString.length) {\n      inputString = inputString.trim();\n\n      if (IS_EXPRESSION_END_RE.test(inputString)) {\n        break;\n      } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n        const {nodes, remainingInput} = parseFunctionArguments(inputString);\n\n        inputString = remainingInput;\n\n        terms.push({\n          type: 'function',\n          name: {type: 'ident', value: 'calc'},\n          arguments: nodes\n        });\n      } else if (IS_IDENT_RE.test(inputString)) {\n        const identParseResult = parseIdent(inputString);\n        const identNode = identParseResult.nodes[0];\n\n        inputString = identParseResult.remainingInput;\n\n        if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {\n          const {nodes, remainingInput} = parseFunctionArguments(inputString);\n          terms.push({type: 'function', name: identNode, arguments: nodes});\n          inputString = remainingInput;\n        } else {\n          terms.push(identNode);\n        }\n      } else if (IS_OPERATOR_RE.test(inputString)) {\n        // Operators are always a single character, so just pluck them out:\n        terms.push({type: 'operator', value: inputString[0] as Operator});\n        inputString = inputString.slice(1);\n      } else {\n        const {nodes, remainingInput} = inputString[0] === HEX_FIRST_TOKEN ?\n            parseHex(inputString) :\n            parseNumber(inputString);\n\n        // The remaining string may not have had any meaningful content. Exit\n        // early if this is the case:\n        if (nodes.length === 0) {\n          break;\n        }\n\n        terms.push(nodes[0]);\n        inputString = remainingInput;\n      }\n    }\n\n    return {nodes: [{type: 'expression', terms}], remainingInput: inputString};\n  };\n})();\n\n\n/**\n * An ident is something like a function name or the keyword \"auto\".\n */\nconst parseIdent = (() => {\n  const NOT_IDENT_RE = /[^a-z0-9_\\-\\u0240-\\uffff]/i;\n\n  return (inputString: string): ParseResult<IdentNode> => {\n    const match = inputString.match(NOT_IDENT_RE);\n    const ident =\n        match == null ? inputString : inputString.substr(0, match.index);\n    const remainingInput =\n        match == null ? '' : inputString.substr(match.index!);\n\n    return {nodes: [{type: 'ident', value: ident}], remainingInput};\n  };\n})();\n\n\n/**\n * Parses a number. A number value can be expressed with an integer or\n * non-integer syntax, and usually includes a unit (but does not strictly\n * require one for our purposes).\n */\nconst parseNumber = (() => {\n  // @see https://www.w3.org/TR/css-syntax/#number-token-diagram\n  const VALUE_RE = /[\\+\\-]?(\\d+[\\.]\\d+|\\d+|[\\.]\\d+)([eE][\\+\\-]?\\d+)?/;\n  const UNIT_RE = /^[a-z%]+/i;\n  const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;\n\n  return (inputString: string): ParseResult<NumberNode> => {\n    const valueMatch = inputString.match(VALUE_RE);\n    const value = valueMatch == null ? '0' : valueMatch[0];\n    inputString = value == null ? inputString : inputString.slice(value.length);\n\n    const unitMatch = inputString.match(UNIT_RE);\n    let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;\n    const remainingInput =\n        unitMatch == null ? inputString : inputString.slice(unit!.length);\n\n    if (unit != null && !ALLOWED_UNITS.test(unit)) {\n      unit = null;\n    }\n\n    return {\n      nodes: [{\n        type: 'number',\n        number: parseFloat(value) || 0,\n        unit: unit as Unit | Percentage | null\n      }],\n      remainingInput\n    };\n  };\n})();\n\n\n/**\n * Parses a hexadecimal-encoded color in 3, 6 or 8 digit form.\n */\nconst parseHex = (() => {\n  // TODO(cdata): right now we don't actually enforce the number of digits\n  const HEX_RE = /^[a-f0-9]*/i;\n\n  return (inputString: string): ParseResult<HexNode> => {\n    inputString = inputString.slice(1).trim();\n    const hexMatch = inputString.match(HEX_RE);\n    const nodes: Array<HexNode> =\n        hexMatch == null ? [] : [{type: 'hex', value: hexMatch[0]}];\n\n    return {\n      nodes,\n      remainingInput: hexMatch == null ? inputString :\n                                         inputString.slice(hexMatch[0].length)\n    };\n  };\n})();\n\n\n/**\n * Parses arguments passed to a function invocation (e.g., the expressions\n * within a matched set of parens).\n */\nconst parseFunctionArguments =\n    (inputString: string): ParseResult<ExpressionNode> => {\n      const expressionNodes: Array<ExpressionNode> = [];\n\n      // Consume the opening paren\n      inputString = inputString.slice(1).trim();\n\n      while (inputString.length) {\n        const expressionParseResult = parseExpression(inputString);\n        expressionNodes.push(expressionParseResult.nodes[0]);\n        inputString = expressionParseResult.remainingInput.trim();\n\n        if (inputString[0] === ',') {\n          inputString = inputString.slice(1).trim();\n        } else if (inputString[0] === ')') {\n          // Consume the closing paren and stop parsing\n          inputString = inputString.slice(1);\n          break;\n        }\n      }\n\n      return {nodes: expressionNodes, remainingInput: inputString};\n    };\n\n\nexport type ASTWalkerCallback<T> = (node: T) => void;\n\nconst $visitedTypes = Symbol('visitedTypes');\n\n/**\n * An ASTWalker walks an array of ASTs such as the type produced by\n * parseExpressions and invokes a callback for a configured set of nodes that\n * the user wishes to \"visit\" during the walk.\n */\nexport class ASTWalker<T extends ASTNode> {\n  protected[$visitedTypes]: Array<string>;\n  constructor(visitedTypes: Array<string>) {\n    this[$visitedTypes] = visitedTypes;\n  }\n\n  /**\n   * Walk the given set of ASTs, and invoke the provided callback for nodes that\n   * match the filtered set that the ASTWalker was constructed with.\n   */\n  walk(ast: Array<ExpressionNode>, callback: ASTWalkerCallback<T>) {\n    const remaining: Array<ASTNode> = ast.slice();\n\n    while (remaining.length) {\n      const next = remaining.shift()!;\n\n      if (this[$visitedTypes].indexOf(next.type) > -1) {\n        callback(next as T);\n      }\n\n      switch (next.type) {\n        case 'expression':\n          remaining.unshift(...next.terms);\n          break;\n        case 'function':\n          remaining.unshift(next.name, ...next.arguments);\n          break;\n      }\n    }\n  }\n}\n\nexport const ZERO: NumberNode =\n    Object.freeze({type: 'number', number: 0, unit: null});"]}