{"version":3,"file":"style-effector.js","sourceRoot":"","sources":["../../src/styles/style-effector.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ASTWalker, ExpressionNode, FunctionNode} from './parsers';\n\ninterface AnyObserver {\n  observe(): void;\n  disconnect(): void;\n}\n\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n\ntype ScrollObserverCallback = () => void;\n\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance analyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  private static[$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  private static[$instances]: Set<ScrollObserver> = new Set();\n  private static[$activateListener]() {\n    window.addEventListener('scroll', this[$notifyInstances], {passive: true});\n  }\n  private static[$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n\n  private[$scrollCallback]: ScrollObserverCallback;\n\n  constructor(callback: ScrollObserverCallback) {\n    this[$scrollCallback] = callback;\n  }\n\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n\n  private[$notify]() {\n    this[$scrollCallback]();\n  };\n}\n\n\nexport type EnvironmentState = 'window-scroll';\n\nexport type StyleEffectorCallback = (record: EnvironmentChangeRecord) => void;\nexport interface EnvironmentChangeRecord {\n  relatedState: EnvironmentState;\n}\n\ntype EnvironmentDependencies = {\n  [key in EnvironmentState]?: AnyObserver\n};\n\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\n\nconst $onScroll = Symbol('onScroll');\n\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n  protected[$dependencies]: EnvironmentDependencies = {};\n\n  protected[$computeStyleCallback]: StyleEffectorCallback;\n  protected[$astWalker] = new ASTWalker<FunctionNode>(['function']);\n\n  constructor(callback: StyleEffectorCallback) {\n    this[$computeStyleCallback] = callback;\n  }\n\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast: Array<ExpressionNode>) {\n    const newDependencies: EnvironmentDependencies = {};\n    const oldDependencies = this[$dependencies];\n\n    this[$astWalker].walk(ast, functionNode => {\n      const {name} = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n\n      if (name.value !== 'env' || firstTerm == null ||\n          firstTerm.type !== 'ident') {\n        return;\n      }\n\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ?\n                oldDependencies['window-scroll'] :\n                new ScrollObserver(this[$onScroll]);\n            observer!.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n\n    this[$dependencies] = newDependencies;\n  }\n\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer =\n          this[$dependencies][environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n  }\n\n  protected[$onScroll] = () => {\n    this[$computeStyleCallback]({relatedState: 'window-scroll'});\n  };\n}"]}