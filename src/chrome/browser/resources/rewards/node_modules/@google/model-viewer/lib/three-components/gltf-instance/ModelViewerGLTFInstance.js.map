{"version":3,"file":"ModelViewerGLTFInstance.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/ModelViewerGLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {FrontSide, Material, Mesh, MeshStandardMaterial, Object3D, Sphere} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {$clone, $prepare, $preparedGLTF, GLTFInstance, PreparedGLTF} from '../GLTFInstance.js';\n\nimport {CorrelatedSceneGraph} from './correlated-scene-graph.js';\n\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n\ninterface PreparedModelViewerGLTF extends PreparedGLTF {\n  [$correlatedSceneGraph]?: CorrelatedSceneGraph;\n}\n\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  protected static[$prepare](source: GLTF) {\n    const prepared = super[$prepare](source) as PreparedModelViewerGLTF;\n\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n\n    const {scene} = prepared;\n\n    const nullSphere = new Sphere(undefined, Infinity);\n\n    scene.traverse((node: Object3D) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the sky sphere\n      node.renderOrder = 1000;\n\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      const mesh = node as Mesh;\n      if (mesh.isMesh) {\n        const {geometry} = mesh;\n        mesh.castShadow = true;\n        if ((mesh as any).isSkinnedMesh) {\n          // Akin to disabling frustum culling above, we have to also manually\n          // disable the bounds to make raycasting correct for skinned meshes.\n          geometry.boundingSphere = nullSphere;\n          // The bounding box is set in GLTFLoader by the accessor bounds, which\n          // are not updated with animation.\n          geometry.boundingBox = null;\n        }\n\n        const material = mesh.material as MeshStandardMaterial;\n        if ((material as any).isMeshBasicMaterial === true) {\n          material.toneMapped = false;\n        }\n        // This makes shadows better for non-manifold meshes\n        material.shadowSide = FrontSide;\n\n        // Fixes an edge case with unused extra UV-coords being incorrectly\n        // referenced by three.js; remove when\n        // https://github.com/mrdoob/three.js/pull/23974 is merged.\n        if (material.aoMap) {\n          const {gltf, threeObjectMap} = prepared[$correlatedSceneGraph]!;\n          const gltfRef = threeObjectMap.get(material);\n          if (gltf.materials != null && gltfRef != null &&\n              gltfRef.materials != null) {\n            const gltfMaterial = gltf.materials[gltfRef.materials];\n            if (gltfMaterial.occlusionTexture &&\n                gltfMaterial.occlusionTexture.texCoord === 0 &&\n                geometry.attributes.uv != null) {\n              geometry.setAttribute('uv2', geometry.attributes.uv);\n            }\n          }\n        }\n      }\n    });\n\n    return prepared;\n  }\n\n  get correlatedSceneGraph() {\n    return (\n        this[$preparedGLTF] as PreparedModelViewerGLTF)[$correlatedSceneGraph]!;\n  }\n\n  /**\n   * @override\n   */\n  [$clone](): PreparedGLTF {\n    const clone: PreparedModelViewerGLTF = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map<string, Material>();\n\n    clone.scene.traverse((node: Object3D) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // scene-graph operations.\n      if ((node as Mesh).isMesh) {\n        const mesh = node as Mesh;\n        const material = mesh.material as MeshStandardMaterial;\n        if (material != null) {\n          if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n            mesh.material = sourceUUIDToClonedMaterial.get(material.uuid)!;\n            return;\n          }\n\n          mesh.material = material.clone() as MeshStandardMaterial;\n          sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);\n        }\n      }\n    });\n\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] =\n        CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n\n    return clone;\n  }\n}\n"]}