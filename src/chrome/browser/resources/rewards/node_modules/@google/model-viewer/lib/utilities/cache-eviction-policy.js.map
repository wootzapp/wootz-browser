{"version":3,"file":"cache-eviction-policy.js","sourceRoot":"","sources":["../../src/utilities/cache-eviction-policy.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A mutable cache is any object that has that allows cache\n * items to be deleted imperatively given their key\n */\nexport interface MutableCache<T> {\n  delete(key: T): void;\n}\n\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nexport class CacheEvictionPolicy<T = string> {\n  private[$retainerCount] = new Map<T, number>();\n  private[$recentlyUsed]: Array<T> = [];\n  private[$evictionThreshold]: number;\n  private[$cache]: MutableCache<T>;\n\n  constructor(cache: MutableCache<T>, evictionThreshold: number = 5) {\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value: number) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n\n  get evictionThreshold(): number {\n    return this[$evictionThreshold];\n  }\n\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache(): MutableCache<T> {\n    return this[$cache];\n  }\n\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key: T): number {\n    return this[$retainerCount].get(key) || 0;\n  }\n\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key: T) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key)! + 1);\n\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key: T) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(\n          key, Math.max(this[$retainerCount].get(key)! - 1, 0));\n    }\n\n    this[$evict]();\n  }\n\n  [$evict]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold];\n         --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}\n"]}