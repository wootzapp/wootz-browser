{"version":3,"file":"gltf-2.0.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/gltf-2.0.ts"],"names":[],"mappings":"AAkFA,MAAM,CAAN,IAAY,MAOX;AAPD,WAAY,MAAM;IAChB,4CAAc,CAAA;IACd,0CAAa,CAAA;IACb,sEAA2B,CAAA;IAC3B,oEAA0B,CAAA;IAC1B,oEAA0B,CAAA;IAC1B,kEAAyB,CAAA;AAC3B,CAAC,EAPW,MAAM,KAAN,MAAM,QAOjB;AAcD,MAAM,CAAN,IAAY,IAIX;AAJD,WAAY,IAAI;IACd,iDAAmB,CAAA;IACnB,uDAAsB,CAAA;IACtB,uCAAc,CAAA;AAChB,CAAC,EAJW,IAAI,KAAJ,IAAI,QAIf","sourcesContent":["import {TextureFilter, Wrapping} from 'three';\n\nexport type RGB = [number, number, number];\n\nexport type RGBA = [number, number, number, number];\n\nexport type Quaternion = [number, number, number, number];\n\nexport type Vector3 = [number, number, number];\n\nexport type Matrix4 = [\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n  number,\n];\n\nexport type Extras = any;\n\n// TODO: Document known extensions and update this type\nexport interface ExtensionDictionary {\n  [index: string]: any;\n}\n\nexport type VariantMapping = {\n  material: number; variants: Array<number>;\n}\n\nexport type VariantMappings = Array<VariantMapping>;\n\nexport type Variants = Array<{name: string}>;\n\nexport interface PerspectiveCameraIntrinsics {\n  aspectRatio?: number;\n  yfov: number;\n  zfar: number;\n  znear: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface OrthographicCameraIntrinsics {\n  xmag: number;\n  ymag: number;\n  zfar: number;\n  znear: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport type CameraType = 'perspective'|'orthographic';\n\nexport interface PerspectiveCamera {\n  name?: string;\n  type: 'perspective';\n  perspective?: PerspectiveCameraIntrinsics;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface OrthographicCamera {\n  name?: string;\n  type: 'orthographic';\n  orthographic?: OrthographicCamera;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport type Camera = PerspectiveCamera|OrthographicCamera;\n\nexport enum Filter {\n  Nearest = 9728,\n  Linear = 9729,\n  NearestMipmapNearest = 9984,\n  LinearMipmapNearest = 9985,\n  NearestMipmapLinear = 9986,\n  LinearMipmapLinear = 9987,\n}\n\nexport type NearestFilter = Filter.Nearest;\nexport type LinearFilter = Filter.Linear;\nexport type NearestMipmapNearestFilter = Filter.NearestMipmapNearest;\nexport type LinearMipmapNearestFilter = Filter.LinearMipmapNearest;\nexport type NearestMipmapLinearFilter = Filter.NearestMipmapLinear;\nexport type LinearMipmapLinearFilter = Filter.LinearMipmapLinear;\n\nexport type MagFilter = NearestFilter|LinearFilter|TextureFilter;\nexport type MinFilter = NearestFilter|LinearFilter|NearestMipmapNearestFilter|\n    LinearMipmapNearestFilter|NearestMipmapLinearFilter|\n    LinearMipmapLinearFilter|TextureFilter;\n\nexport enum Wrap {\n  ClampToEdge = 33071,\n  MirroredRepeat = 33648,\n  Repeat = 10497,\n}\n\nexport type ClampToEdgeWrap = Wrap.ClampToEdge;\nexport type MirroredRepeatWrap = Wrap.MirroredRepeat;\nexport type RepeatWrap = Wrap.Repeat;\n\nexport type WrapMode = RepeatWrap|ClampToEdgeWrap|MirroredRepeatWrap|Wrapping;\n\nexport interface Sampler {\n  name?: string;\n  magFilter?: MagFilter;\n  minFilter?: MinFilter;\n  wrapS?: WrapMode;\n  wrapT?: WrapMode;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Texture {\n  name?: string;\n  sampler?: number;\n  source?: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface TextureInfo {\n  index: number;\n  texCoord?: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface OcclusionTextureInfo extends TextureInfo {\n  strength?: number;\n}\n\nexport interface NormalTextureInfo extends TextureInfo {\n  scale?: number;\n}\n\nexport interface PBRMetallicRoughness {\n  baseColorFactor?: RGBA;\n  baseColorTexture?: TextureInfo;\n  metallicRoughnessTexture?: TextureInfo;\n  metallicFactor?: number;\n  roughnessFactor?: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport type AlphaMode = 'OPAQUE'|'MASK'|'BLEND';\n\nexport interface Material {\n  name?: string;\n  doubleSided?: boolean;\n  alphaMode?: AlphaMode;\n  alphaCutoff?: number;\n  emissiveFactor?: RGB;\n  pbrMetallicRoughness?: PBRMetallicRoughness;\n  normalTexture?: NormalTextureInfo;\n  occlusionTexture?: OcclusionTextureInfo;\n  emissiveTexture?: TextureInfo;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\nexport interface KHRMaterialsVariants {\n  mappings: VariantMapping[];\n}\n\nexport type AttributeDictionary = {\n  [index: string]: number;\n};\n\nexport interface Primitive {\n  attributes: AttributeDictionary;\n  indices?: number;\n  material?: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Mesh {\n  name?: string;\n  primitives: Primitive[];\n  weights: number[];\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Node {\n  name?: string;\n  mesh?: number;\n  matrix?: Matrix4;\n  rotation?: Quaternion;\n  scale?: Vector3;\n  translation?: Vector3;\n  weights?: number[];\n  children?: number[];\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Image {\n  name?: string;\n  uri?: string;\n  bufferView?: number;\n  mimeType?: string;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Scene {\n  name?: string;\n  nodes: number[];\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport type AccessorType = 'SCALAR'|'VEC2'|'VEC3'|'VEC4'|'MAT2'|'MAT3'|'MAT4';\n\nexport interface Accessor {\n  name?: string;\n  bufferView?: number;\n  byteOffset?: number;\n  componentType: number;\n  normalized?: boolean;\n  count: number;\n  type: AccessorType;\n  max?: number;\n  min?: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n\n  // TODO: What is this?\n  // @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessorsparse\n  sparse?: any;\n}\n\nexport type ChannelTargetPath = 'rotation'|'scale'|'translation'|'weights';\n\nexport interface ChannelTarget {\n  node: number;\n  path: ChannelTargetPath;\n}\n\nexport interface Channel {\n  sampler: number;\n  target: ChannelTarget;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport type AnimationInterpolation = 'LINEAR'|'STEP'|'CUBICSPLINE';\n\nexport interface AnimationSampler {\n  input: number;\n  interpolation: AnimationInterpolation;\n  output: number;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Animation {\n  name?: string;\n  channels: Channel[];\n  samplers: AnimationSampler[];\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface Skin {\n  inverseBindMatrices?: number;\n  skeleton?: number;\n  joints: number[];\n  name?: string;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport type GLTFElement =\n    Scene|Node|Mesh|Material|Image|Texture|TextureInfo|Sampler|\n    PBRMetallicRoughness|Accessor|Camera|Animation|AnimationSampler|Skin;\n\nexport interface GLTFElementMap {\n  'scene': Scene;\n  'node': Node;\n  'mesh': Mesh;\n  'material': Material;\n  'image': Image;\n  'texture': Texture;\n  'texture-info': TextureInfo;\n  'sampler': Sampler;\n  'accessor': Accessor;\n  'camera': Camera;\n  'animation': Animation;\n  'animation-sampler': AnimationSampler;\n  'skin': Skin;\n}\n\nexport interface Asset {\n  version: '2.0';\n  copyright?: string;\n  generator?: string;\n  minVersion?: string;\n  extensions?: ExtensionDictionary;\n  extras?: Extras;\n}\n\nexport interface GLTF {\n  asset: Asset;\n  scene?: number;\n  scenes?: Scene[];\n  nodes?: Node[];\n  materials?: Material[];\n  accessors?: Accessor[];\n  samplers?: Sampler[];\n  images?: Image[];\n  textures?: Texture[];\n  meshes?: Mesh[];\n  cameras?: Camera[];\n  animations?: Animation[];\n  skins?: Skin[];\n}\n"]}