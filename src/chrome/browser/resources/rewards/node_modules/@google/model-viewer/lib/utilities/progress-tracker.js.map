{"version":3,"file":"progress-tracker.js","sourceRoot":"","sources":["../../src/utilities/progress-tracker.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAEH,OAAO,EAAC,KAAK,EAAC,MAAM,iBAAiB,CAAC;AA2BtC;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAM,OAAO,eAAgB,SAAQ,WAAW;IAAhD;;QACU,sBAAiB,GAAyB,IAAI,GAAG,EAAE,CAAC;QACpD,kBAAa,GAAG,CAAC,CAAC;IAqF5B,CAAC;IAnFC;;OAEG;IACH,IAAI,oBAAoB;QACtB,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC;IACrC,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,aAAa;QACX,MAAM,QAAQ,GAAoB,EAAC,QAAQ,EAAE,CAAC,EAAE,SAAS,EAAE,KAAK,EAAC,CAAC;QAElE,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAErC,IAAI,IAAI,CAAC,oBAAoB,KAAK,CAAC,EAAE;YACnC,kEAAkE;YAClE,mBAAmB;YACnB,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;SACzC;QAED,OAAO,CAAC,QAAgB,EAAU,EAAE;YAClC,IAAI,YAAoB,CAAC;YAEzB,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;YAElE,IAAI,YAAY,KAAK,QAAQ,CAAC,QAAQ,EAAE;gBACtC,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;aACpD;YAED,OAAO,QAAQ,CAAC,QAAQ,CAAC;QAC3B,CAAC,CAAC;IACJ,CAAC;IAEO,qBAAqB,CACzB,eAAgC,EAAE,YAAoB;QACxD,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,mBAAmB,GAAG,CAAC,CAAC;QAE5B,IAAI,YAAY,IAAI,GAAG;YACrB,eAAe,CAAC,SAAS,GAAG,IAAI,CAAC;QAEnC,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC7C,MAAM,EAAC,QAAQ,EAAC,GAAG,QAAQ,CAAC;YAC5B,YAAY,IAAI,GAAG,GAAG,QAAQ,CAAC;YAE/B,IAAI,QAAQ,CAAC,SAAS,KAAK,IAAI,EAAE;gBAC/B,mBAAmB,EAAE,CAAC;aACvB;SACF;QAED,MAAM,YAAY,GAAG,eAAe,CAAC,QAAQ,CAAC;QAC9C,eAAe,CAAC,QAAQ,GAAG,YAAY,CAAC;QAExC,yEAAyE;QACzE,wBAAwB;QACxB,IAAI,CAAC,aAAa,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;YAC/C,CAAC,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,YAAY,CAAC;QAE9C,MAAM,aAAa,GAAG,mBAAmB,KAAK,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACrE,GAAG,CAAC,CAAC;YACL,IAAI,CAAC,aAAa,CAAC;QAEvB,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,CAC9B,UAAU,EAAE,EAAC,MAAM,EAAE,EAAC,aAAa,EAAC,EAAC,CAAC,CAAC,CAAC;QAE5C,IAAI,mBAAmB,KAAK,IAAI,CAAC,oBAAoB,EAAE;YACrD,IAAI,CAAC,aAAa,GAAG,GAAG,CAAC;YACzB,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;SAChC;IACH,CAAC;CACF","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {clamp} from '../utilities.js';\n\ninterface OngoingActivity {\n  progress: number;\n  completed: boolean;\n}\n\n/**\n * An Activity is represented by a callback that accepts values from 0 to 1,\n * where 1 represents the completion of the activity. The callback returns the\n * actual progress as it is stored by the ProgressTracker (which may be clamped,\n * and can never be lower than its previous value).\n */\nexport type Activity = (progress: number) => number;\n\n/**\n * A progress event contains the total progress of all ongoing activities in the\n * ProgressTracker. The total progress is a heuristic, but has some useful\n * properties: for a single activity, it equals the input progress; for multiple\n * activities that progress in lockstep, it will also equal each input progress.\n * When more activities overlap as time goes on, total progress will tend to\n * decelerate.\n */\nexport interface ProgressDetails {\n  totalProgress: number;\n}\n\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents a abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\nexport class ProgressTracker extends EventTarget {\n  private ongoingActivities: Set<OngoingActivity> = new Set();\n  private totalProgress = 0;\n\n  /**\n   * The total number of activities currently being tracked.\n   */\n  get ongoingActivityCount(): number {\n    return this.ongoingActivities.size;\n  }\n\n  /**\n   * Registers a new activity to be tracked by the progress tracker. The method\n   * returns a special callback that should be invoked whenever new progress is\n   * ready to be reported. The progress should be reported as a value between 0\n   * and 1, where 0 would represent the beginning of the action and 1 would\n   * represent its completion.\n   *\n   * There is no built-in notion of a time-out for ongoing activities, so once\n   * an ongoing activity is begun, it is up to the consumer of this API to\n   * update the progress until that activity is no longer ongoing.\n   *\n   * Progress is only allowed to move forward for any given activity. If a lower\n   * progress is reported than the previously reported progress, it will be\n   * ignored.\n   */\n  beginActivity(): Activity {\n    const activity: OngoingActivity = {progress: 0, completed: false};\n\n    this.ongoingActivities.add(activity);\n\n    if (this.ongoingActivityCount === 1) {\n      // Announce the first progress event (which should always be 0 / 1\n      // total progress):\n      this.announceTotalProgress(activity, 0);\n    }\n\n    return (progress: number): number => {\n      let nextProgress: number;\n\n      nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n\n      if (nextProgress !== activity.progress) {\n        this.announceTotalProgress(activity, nextProgress);\n      }\n\n      return activity.progress;\n    };\n  }\n\n  private announceTotalProgress(\n      updatedActivity: OngoingActivity, nextProgress: number) {\n    let progressLeft = 0;\n    let completedActivities = 0;\n\n    if (nextProgress == 1.0)\n      updatedActivity.completed = true;\n\n    for (const activity of this.ongoingActivities) {\n      const {progress} = activity;\n      progressLeft += 1.0 - progress;\n\n      if (activity.completed === true) {\n        completedActivities++;\n      }\n    }\n\n    const lastProgress = updatedActivity.progress;\n    updatedActivity.progress = nextProgress;\n\n    // Advance the total progress by the fraction of total remaining progress\n    // due to this activity.\n    this.totalProgress += (nextProgress - lastProgress) *\n        (1.0 - this.totalProgress) / progressLeft;\n\n    const totalProgress = completedActivities === this.ongoingActivityCount ?\n        1.0 :\n        this.totalProgress;\n\n    this.dispatchEvent(new CustomEvent<ProgressDetails>(\n        'progress', {detail: {totalProgress}}));\n\n    if (completedActivities === this.ongoingActivityCount) {\n      this.totalProgress = 0.0;\n      this.ongoingActivities.clear();\n    }\n  }\n}\n"]}