{"version":3,"file":"decorators.js","sourceRoot":"","sources":["../src/decorators.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ReactiveElement} from 'lit';\nimport {EvaluatedStyle, Intrinsics, StyleEvaluator} from './styles/evaluators';\nimport {parseExpressions, Unit} from './styles/parsers';\nimport {StyleEffector} from './styles/style-effector';\n\n// An IntrinsicsFactory generates up-to-date intrinsics for a given ModelViewer\n// element instance when it is invoked.\nexport type IntrinsicsFactory<T extends Intrinsics<Array<Unit>>,\n                                        U extends ReactiveElement> =\n    (element: U) => T;\n\n// When applying the @style decorator, it needs to be configured with\n// corresponding Intrinsics and the property key of a method to receive updated\n// values. Optionally, it can also be configured to observe environment effects,\n// which causes a StyleEffector to be created for the property.\nexport interface StyleDecoratorConfig<T extends Intrinsics<Array<Unit>>,\n                                                U extends ReactiveElement> {\n  intrinsics: T|IntrinsicsFactory<T, U>;\n  updateHandler: symbol;\n  observeEffects?: boolean;\n}\n\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\nexport const style =\n    <T extends Intrinsics<Array<Unit>>, U extends ReactiveElement>(\n        config: StyleDecoratorConfig<T, U>) => {\n      const observeEffects: boolean = config.observeEffects || false;\n      const getIntrinsics = config.intrinsics instanceof Function ?\n          config.intrinsics :\n          (() => config.intrinsics) as IntrinsicsFactory<T, U>;\n\n      return <U extends typeof ReactiveElement['prototype']>(\n                 proto: U, propertyName: string) => {\n        const originalUpdated = (proto as any).updated;\n        const originalConnectedCallback = proto.connectedCallback;\n        const originalDisconnectedCallback = proto.disconnectedCallback;\n\n        const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n        const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n        const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n        const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n\n        Object.defineProperties(proto, {\n          [$styleEffector]:\n              {value: null as StyleEffector | null, writable: true},\n          [$styleEvaluator]:\n              {value: null as StyleEvaluator<T>| null, writable: true},\n\n          [$updateEvaluator]: {\n            value: function() {\n              const ast = parseExpressions(\n                  this[propertyName as keyof ReactiveElement] as string);\n              this[$styleEvaluator] =\n                  new StyleEvaluator(ast, getIntrinsics(this));\n\n              if (this[$styleEffector] == null && observeEffects) {\n                this[$styleEffector] =\n                    new StyleEffector(() => this[$evaluateAndSync]());\n              }\n\n              if (this[$styleEffector] != null) {\n                this[$styleEffector].observeEffectsFor(ast);\n              }\n            }\n          },\n\n          [$evaluateAndSync]: {\n            value: function() {\n              if (this[$styleEvaluator] == null) {\n                return;\n              }\n\n              const result = this[$styleEvaluator].evaluate();\n\n              // @see https://github.com/microsoft/TypeScript/pull/30769\n              // @see https://github.com/Microsoft/TypeScript/issues/1863\n              (this as unknown as Record<\n                   string,\n                   (style: EvaluatedStyle<T>) =>\n                       void>)[config.updateHandler as unknown as string](\n                  result);\n            }\n          },\n\n          updated: {\n            value: function(changedProperties: Map<string, any>) {\n              // Always invoke updates to styles first. This gives a class that\n              // uses this decorator the opportunity to override the effect, or\n              // respond to it, in its own implementation of `updated`.\n              if (changedProperties.has(propertyName)) {\n                this[$updateEvaluator]();\n                this[$evaluateAndSync]();\n              }\n\n              originalUpdated.call(this, changedProperties);\n            }\n          },\n\n          connectedCallback: {\n            value: function() {\n              originalConnectedCallback.call(this);\n              this.requestUpdate(propertyName, this[propertyName]);\n            }\n          },\n\n          disconnectedCallback: {\n            value: function() {\n              originalDisconnectedCallback.call(this);\n              if (this[$styleEffector] != null) {\n                this[$styleEffector].dispose();\n                this[$styleEffector] = null;\n              }\n            }\n          }\n        });\n      };\n    };"]}