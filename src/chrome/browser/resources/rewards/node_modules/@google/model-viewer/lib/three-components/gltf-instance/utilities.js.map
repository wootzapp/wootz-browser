{"version":3,"file":"utilities.js","sourceRoot":"","sources":["../../../src/three-components/gltf-instance/utilities.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {GLTF, GLTFElement, GLTFElementMap} from '../../three-components/gltf-instance/gltf-2.0.js';\n\n/**\n * A VisitorCallback is used to access an element of a GLTF scene graph. The\n * callback receives a reference to the element, the element's index relative\n * to other elements of its type (as it would appear in the top-level element\n * array in the corresponding GLTF) and a hierarchy array that is the list of\n * ancestor elements (inclusive of the current element) that preceded the\n * currently accessed element in the GLTF scene graph hierarchy.\n */\nexport type VisitorCallback<T extends GLTFElement> =\n    (element: T, index: number, hierarchy: GLTFElement[]) => void;\n\n/**\n * There is a corresponding VisitorCallback type for every type of GLTFElement.\n */\nexport type VisitorCallbacks = {\n  [T in keyof GLTFElementMap]?: VisitorCallback<GLTFElementMap[T]>;\n}\n\n/**\n * Supported options for configuring a GLTFTreeVisitor include:\n *  - allScenes: if true, all scenes (not just the active one) will be visited\n *  - sparse: if true, elements that have been visited once will not be visited\n *    again if and when they are encountered a second time in the scene graph\n *\n * Note that glTF defines a top-level field (\"scene\") that refers to the scene\n * that will be presented first (\"at load time\"). In the case of <model-viewer>,\n * there is no way to specify an alternative scene to display (although we plan\n * to add configuration for this). Consequently, the ability to traverse all\n * scenes is not likely to be used at this time. However, some cases will call\n * for visiting all nodes in a glTF regardless of whether they are a part of\n * the current scene. Eventually, <model-viewer> will support changing the\n * active scene, and the ability to traverse all scenes at once will become\n * handy.\n *\n * @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n * @see https://github.com/google/model-viewer/issues/195\n */\nexport interface VisitOptions {\n  allScenes?: boolean;\n  sparse?: boolean;\n}\n\ninterface VisitorTraversalState {\n  hierarchy: GLTFElement[];\n  visited: Set<GLTFElement>;\n  sparse: boolean;\n  gltf: GLTF;\n}\n\nconst $callbacks = Symbol('callbacks');\nconst $visitMesh = Symbol('visitMesh');\nconst $visitElement = Symbol('visitElement');\nconst $visitNode = Symbol('visitNode');\nconst $visitScene = Symbol('visitScene');\nconst $visitMaterial = Symbol('visitMaterial');\n\n/**\n * GLTFTreeVisitor implements a deterministic traversal order of a valid,\n * deserialized glTF 2.0 model. It supports selective element visitation via\n * callbacks configured based on element type. For example, to visit all\n * materials in all scenes in a glTF:\n *\n * ```javascript\n * const visitor = new GLTFTreeVisitor({\n *   material: (material, index, hierarchy) => {\n *     // material is a glTF 2.0 Material\n *     // index is the index of material in gltf.materials\n *     // hierarchy includes ancestors of material in the glTF\n *   }\n * });\n *\n * visitor.visit(someInMemoryGLTF, { allScenes: true });\n * ```\n *\n * The traversal order of the visitor is pre-order, depth-first.\n *\n * Note that the traversal order is not guaranteed to correspond to the\n * index of a given element in any way. Rather, traversal order is based\n * on the hierarchical order of the scene graph.\n */\nexport class GLTFTreeVisitor {\n  private[$callbacks]: VisitorCallbacks;\n\n  constructor(callbacks: VisitorCallbacks) {\n    this[$callbacks] = callbacks;\n  }\n\n  /**\n   * Visit a given in-memory glTF via the configured callbacks of this visitor.\n   * Optionally, all scenes may be visited (as opposed to just the active one).\n   * Sparse traversal can also be specified, in which case elements that\n   * re-appear multiple times in the scene graph will only be visited once.\n   */\n  visit(gltf: GLTF, options: VisitOptions = {}): void {\n    const allScenes = !!options.allScenes;\n    const sparse = !!options.sparse;\n    const scenes = allScenes ?\n        gltf.scenes || [] :\n        (gltf.scenes && gltf.scene != null) ? [gltf.scenes[gltf.scene]] : [];\n\n    const state: VisitorTraversalState =\n        {hierarchy: [], visited: new Set(), sparse, gltf};\n\n    for (const scene of scenes) {\n      this[$visitScene](gltf.scenes!.indexOf(scene), state);\n    }\n  }\n\n  private[$visitElement]<T extends GLTFElement>(\n      index: number, elementList: T[]|undefined, state: VisitorTraversalState,\n      visit?: VisitorCallback<T>, traverse?: (element: T) => void) {\n    if (elementList == null) {\n      return;\n    }\n\n    const element = elementList[index];\n    const {sparse, hierarchy, visited} = state;\n\n    if (element == null) {\n      return;\n    }\n\n    if (sparse && visited.has(element)) {\n      return;\n    }\n\n    visited.add(element);\n    hierarchy.push(element);\n\n    if (visit != null) {\n      visit(element, index, hierarchy);\n    }\n\n    if (traverse != null) {\n      traverse(element);\n    }\n\n    hierarchy.pop();\n  }\n\n  private[$visitScene](index: number, state: VisitorTraversalState) {\n    const {gltf} = state;\n    const {scene: visit} = this[$callbacks];\n\n    this[$visitElement](index, gltf.scenes, state, visit, (scene) => {\n      // A scene is not required to have a list of nodes\n      if (scene.nodes == null) {\n        return;\n      }\n\n      for (const nodeIndex of scene.nodes) {\n        this[$visitNode](nodeIndex, state);\n      }\n    });\n  }\n\n  private[$visitNode](index: number, state: VisitorTraversalState) {\n    const {gltf} = state;\n    const {node: visit} = this[$callbacks];\n    this[$visitElement](index, gltf.nodes, state, visit, (node) => {\n      if (node.mesh != null) {\n        this[$visitMesh](node.mesh, state);\n      }\n\n      if (node.children != null) {\n        for (const childNodeIndex of node.children) {\n          this[$visitNode](childNodeIndex, state);\n        }\n      }\n    });\n  }\n\n  private[$visitMesh](index: number, state: VisitorTraversalState) {\n    const {gltf} = state;\n    const {mesh: visit} = this[$callbacks];\n\n    this[$visitElement](index, gltf.meshes, state, visit, (mesh) => {\n      for (const primitive of mesh.primitives) {\n        if (primitive.material != null) {\n          this[$visitMaterial](primitive.material, state);\n        }\n      }\n    });\n  }\n\n  private[$visitMaterial](index: number, state: VisitorTraversalState) {\n    const {gltf} = state;\n    const {material: visit} = this[$callbacks];\n    this[$visitElement](index, gltf.materials, state, visit);\n  }\n}\n"]}