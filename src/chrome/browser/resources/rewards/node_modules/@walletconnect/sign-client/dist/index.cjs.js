"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var p=require("@walletconnect/core"),j=require("@walletconnect/logger"),ge=require("@walletconnect/types"),i=require("@walletconnect/utils"),Ee=require("events"),w=require("@walletconnect/time"),E=require("@walletconnect/jsonrpc-utils");function Le(N){return N&&typeof N=="object"&&"default"in N?N:{default:N}}var be=Le(Ee);const re="wc",ne=2,oe="client",Q=`${re}@${ne}:${oe}:`,X={name:oe,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},De={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},xe={database:":memory:"},ae="WALLETCONNECT_DEEPLINK_CHOICE",Me={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ue="history",ke="0.3",ye="proposal",$e=w.THIRTY_DAYS,_e="Proposal expired",Se="session",x=w.SEVEN_DAYS,me="engine",f={wc_sessionPropose:{req:{ttl:w.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1104},res:{ttl:w.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1106},res:{ttl:w.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:w.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:w.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1112},res:{ttl:w.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1114},res:{ttl:w.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:w.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:w.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1119}}},J={min:w.FIVE_MINUTES,max:w.SEVEN_DAYS},A={idle:"IDLE",active:"ACTIVE"},we="request",Re=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Ie="wc",Ke=1.5,Te="auth",Ne="authKeys",ve="pairingTopics",fe="requests",K=`${Ie}@${1.5}:${Te}:`,G=`${K}:PUB_KEY`;var Ge=Object.defineProperty,Ye=Object.defineProperties,Fe=Object.getOwnPropertyDescriptors,Pe=Object.getOwnPropertySymbols,He=Object.prototype.hasOwnProperty,je=Object.prototype.propertyIsEnumerable,Oe=(N,a,e)=>a in N?Ge(N,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):N[a]=e,v=(N,a)=>{for(var e in a||(a={}))He.call(a,e)&&Oe(N,e,a[e]);if(Pe)for(var e of Pe(a))je.call(a,e)&&Oe(N,e,a[e]);return N},C=(N,a)=>Ye(N,Fe(a));class Qe extends ge.IEngine{constructor(a){super(a),this.name=me,this.events=new be.default,this.initialized=!1,this.requestQueue={state:A.idle,queue:[]},this.sessionRequestQueue={state:A.idle,queue:[]},this.requestQueueDelay=w.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(f)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},w.toMiliseconds(this.requestQueueDelay)))},this.connect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const t=C(v({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t);const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:o,relays:c}=t;let l=s,u,d=!1;try{l&&(d=this.client.core.pairing.pairings.get(l).active)}catch(R){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),R}if(!l||!d){const{topic:R,uri:T}=await this.client.core.pairing.create();l=R,u=T}if(!l){const{message:R}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(R)}const g=await this.client.core.crypto.generateKeyPair(),h=f.wc_sessionPropose.req.ttl||w.FIVE_MINUTES,_=i.calcExpiry(h),S=v({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:p.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:g,metadata:this.client.metadata},expiryTimestamp:_,pairingTopic:l},o&&{sessionProperties:o}),{reject:y,resolve:m,done:I}=i.createDelayedPromise(h,_e);this.events.once(i.engineEvent("session_connect"),async({error:R,session:T})=>{if(R)y(R);else if(T){T.self.publicKey=g;const L=C(v({},T),{pairingTopic:S.pairingTopic,requiredNamespaces:S.requiredNamespaces,optionalNamespaces:S.optionalNamespaces,transportType:p.TRANSPORT_TYPES.relay});await this.client.session.set(T.topic,L),await this.setExpiry(T.topic,T.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:T.peer.metadata}),this.cleanupDuplicatePairings(L),m(L)}});const V=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:S,throwOnFailedPublish:!0});return await this.setProposal(V,v({id:V},S)),{uri:u,approval:I}},this.pair=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}},this.approve=async e=>{var t,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:(t=e?.id)==null?void 0:t.toString(),trace:[p.EVENT_CLIENT_SESSION_TRACES.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(O){throw n.setError(p.EVENT_CLIENT_SESSION_ERRORS.no_internet_connection),O}try{await this.isValidProposalId(e?.id)}catch(O){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),n.setError(p.EVENT_CLIENT_SESSION_ERRORS.proposal_not_found),O}try{await this.isValidApprove(e)}catch(O){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(p.EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure),O}const{id:o,relayProtocol:c,namespaces:l,sessionProperties:u,sessionConfig:d}=e,g=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:h,proposer:_,requiredNamespaces:S,optionalNamespaces:y}=g;let m=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:h});m||(m=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:p.EVENT_CLIENT_SESSION_TRACES.session_approve_started,properties:{topic:h,trace:[p.EVENT_CLIENT_SESSION_TRACES.session_approve_started,p.EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success]}}));const I=await this.client.core.crypto.generateKeyPair(),V=_.publicKey,R=await this.client.core.crypto.generateSharedKey(I,V),T=v(v({relay:{protocol:c??"irn"},namespaces:l,controller:{publicKey:I,metadata:this.client.metadata},expiry:i.calcExpiry(x)},u&&{sessionProperties:u}),d&&{sessionConfig:d}),L=p.TRANSPORT_TYPES.relay;m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);try{await this.client.core.relayer.subscribe(R,{transportType:L})}catch(O){throw m.setError(p.EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure),O}m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);const M=C(v({},T),{topic:R,requiredNamespaces:S,optionalNamespaces:y,pairingTopic:h,acknowledged:!1,self:T.controller,peer:{publicKey:_.publicKey,metadata:_.metadata},controller:I,transportType:p.TRANSPORT_TYPES.relay});await this.client.session.set(R,M),m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.store_session);try{m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.publishing_session_settle),await this.sendRequest({topic:R,method:"wc_sessionSettle",params:T,throwOnFailedPublish:!0}).catch(O=>{throw m?.setError(p.EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure),O}),m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success),m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.publishing_session_approve),await this.sendResult({id:o,topic:h,result:{relay:{protocol:c??"irn"},responderPublicKey:I},throwOnFailedPublish:!0}).catch(O=>{throw m?.setError(p.EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure),O}),m.addTrace(p.EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success)}catch(O){throw this.client.logger.error(O),this.client.session.delete(R,i.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(R),O}return this.client.core.eventClient.deleteEvent({eventId:m.eventId}),await this.client.core.pairing.updateMetadata({topic:h,metadata:_.metadata}),await this.client.proposal.delete(o,i.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:h}),await this.setExpiry(R,i.calcExpiry(x)),{topic:R,acknowledged:()=>Promise.resolve(this.client.session.get(R))}},this.reject=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:t,reason:s}=e;let r;try{r=this.client.proposal.get(t).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),n}r&&(await this.sendError({id:t,topic:r,error:s,rpcOpts:f.wc_sessionPropose.reject}),await this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")))},this.update=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(d){throw this.client.logger.error("update() -> isValidUpdate() failed"),d}const{topic:t,namespaces:s}=e,{done:r,resolve:n,reject:o}=i.createDelayedPromise(),c=E.payloadId(),l=E.getBigIntRpcId().toString(),u=this.client.session.get(t).namespaces;return this.events.once(i.engineEvent("session_update",c),({error:d})=>{d?o(d):n()}),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(d=>{this.client.logger.error(d),this.client.session.update(t,{namespaces:u}),o(d)}),{acknowledged:r}},this.extend=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:t}=e,s=E.payloadId(),{done:r,resolve:n,reject:o}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",s),({error:c})=>{c?o(c):n()}),await this.setExpiry(t,i.calcExpiry(x)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{o(c)}),{acknowledged:r}},this.request=async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(_){throw this.client.logger.error("request() -> isValidRequest() failed"),_}const{chainId:t,request:s,topic:r,expiry:n=f.wc_sessionRequest.req.ttl}=e,o=this.client.session.get(r);o?.transportType===p.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=E.payloadId(),l=E.getBigIntRpcId().toString(),{done:u,resolve:d,reject:g}=i.createDelayedPromise(n,"Request expired. Please try again.");this.events.once(i.engineEvent("session_request",c),({error:_,result:S})=>{_?g(_):d(S)});const h=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);return h?(await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:C(v({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0,appLink:h}).catch(_=>g(_)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:t,id:c}),await u()):await Promise.all([new Promise(async _=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:C(v({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0}).catch(S=>g(S)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:t,id:c}),_()}),new Promise(async _=>{var S;if(!((S=o.sessionConfig)!=null&&S.disableDeepLink)){const y=await i.getDeepLink(this.client.core.storage,ae);i.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:y})}_()}),u()]).then(_=>_[2])},this.respond=async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:s}=e,{id:r}=s,n=this.client.session.get(t);n.transportType===p.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const o=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);E.isJsonRpcResult(s)?await this.sendResult({id:r,topic:t,result:s.result,throwOnFailedPublish:!0,appLink:o}):E.isJsonRpcError(s)&&await this.sendError({id:r,topic:t,error:s.error,appLink:o}),this.cleanupAfterResponse(e)},this.ping=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=E.payloadId(),r=E.getBigIntRpcId().toString(),{done:n,resolve:o,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",s),({error:l})=>{l?c(l):o()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(t)&&await this.client.core.pairing.ping({topic:t})},this.emit=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:r}=e,n=E.getBigIntRpcId().toString();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n})},this.disconnect=async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:i.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:s}=i.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(s)}},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(t=>i.isSessionCompatible(t,e))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const r=t&&this.client.core.linkModeSupportedApps.includes(t)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),n=r?p.TRANSPORT_TYPES.link_mode:p.TRANSPORT_TYPES.relay;n===p.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:c="",uri:l,domain:u,nonce:d,type:g,exp:h,nbf:_,methods:S=[],expiry:y}=e,m=[...e.resources||[]],{topic:I,uri:V}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:I,uri:V}});const R=await this.client.core.crypto.generateKeyPair(),T=i.hashKey(R);if(await Promise.all([this.client.auth.authKeys.set(G,{responseTopic:T,publicKey:R}),this.client.auth.pairingTopics.set(T,{topic:T,pairingTopic:I})]),await this.client.core.relayer.subscribe(T,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${I}`),S.length>0){const{namespace:q}=i.parseChainId(o[0]);let P=i.createEncodedRecap(q,"request",S);i.getRecapFromResources(m)&&(P=i.mergeEncodedRecaps(P,m.pop())),m.push(P)}const L=y&&y>f.wc_sessionAuthenticate.req.ttl?y:f.wc_sessionAuthenticate.req.ttl,M={authPayload:{type:g??"caip122",chains:o,statement:c,aud:l,domain:u,version:"1",nonce:d,iat:new Date().toISOString(),exp:h,nbf:_,resources:m},requester:{publicKey:R,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(L)},O={eip155:{chains:o,methods:[...new Set(["personal_sign",...S])],events:["chainChanged","accountsChanged"]}},ce={requiredNamespaces:{},optionalNamespaces:O,relays:[{protocol:"irn"}],pairingTopic:I,proposer:{publicKey:R,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(f.wc_sessionPropose.req.ttl)},{done:Ae,resolve:le,reject:B}=i.createDelayedPromise(L,"Request expired"),Y=async({error:q,session:P})=>{if(this.events.off(i.engineEvent("session_request",b),W),q)B(q);else if(P){P.self.publicKey=R,await this.client.session.set(P.topic,P),await this.setExpiry(P.topic,P.expiry),I&&await this.client.core.pairing.updateMetadata({topic:I,metadata:P.peer.metadata});const F=this.client.session.get(P.topic);await this.deleteProposal(U),le({session:F})}},W=async q=>{var P,F,pe;if(await this.deletePendingAuthRequest(b,{message:"fulfilled",code:0}),q.error){const $=i.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return q.error.code===$.code?void 0:(this.events.off(i.engineEvent("session_connect"),Y),B(q.error.message))}await this.deleteProposal(U),this.events.off(i.engineEvent("session_connect"),Y);const{cacaos:he,responder:D}=q.result,ee=[],de=[];for(const $ of he){await i.validateSignedCacao({cacao:$,projectId:this.client.core.projectId})||(this.client.logger.error($,"Signature verification failed"),B(i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:te}=$,se=i.getRecapFromResources(te.resources),ue=[i.getNamespacedDidChainId(te.iss)],Ce=i.getDidAddress(te.iss);if(se){const ie=i.getMethodsFromRecap(se),Ve=i.getChainsFromRecap(se);ee.push(...ie),ue.push(...Ve)}for(const ie of ue)de.push(`${ie}:${Ce}`)}const k=await this.client.core.crypto.generateSharedKey(R,D.publicKey);let H;ee.length>0&&(H={topic:k,acknowledged:!0,self:{publicKey:R,metadata:this.client.metadata},peer:D,controller:D.publicKey,expiry:i.calcExpiry(x),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:I,namespaces:i.buildNamespacesFromAuth([...new Set(ee)],[...new Set(de)]),transportType:n},await this.client.core.relayer.subscribe(k,{transportType:n}),await this.client.session.set(k,H),I&&await this.client.core.pairing.updateMetadata({topic:I,metadata:D.metadata}),H=this.client.session.get(k)),(P=this.client.metadata.redirect)!=null&&P.linkMode&&(F=D.metadata.redirect)!=null&&F.linkMode&&(pe=D.metadata.redirect)!=null&&pe.universal&&t&&(this.client.core.addLinkModeSupportedApp(D.metadata.redirect.universal),this.client.session.update(k,{transportType:p.TRANSPORT_TYPES.link_mode})),le({auths:he,session:H})},b=E.payloadId(),U=E.payloadId();this.events.once(i.engineEvent("session_connect"),Y),this.events.once(i.engineEvent("session_request",b),W);let Z;try{if(r){const q=E.formatJsonRpcRequest("wc_sessionAuthenticate",M,b);this.client.core.history.set(I,q);const P=await this.client.core.crypto.encode("",q,{type:i.TYPE_2,encoding:i.BASE64URL});Z=i.getLinkModeURL(t,I,P)}else await Promise.all([this.sendRequest({topic:I,method:"wc_sessionAuthenticate",params:M,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:b}),this.sendRequest({topic:I,method:"wc_sessionPropose",params:ce,expiry:f.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:U})])}catch(q){throw this.events.off(i.engineEvent("session_connect"),Y),this.events.off(i.engineEvent("session_request",b),W),q}return await this.setProposal(U,v({id:U},ce)),await this.setAuthRequest(b,{request:C(v({},M),{verifyContext:{}}),pairingTopic:I,transportType:n}),{uri:Z??V,response:Ae}},this.approveSessionAuthenticate=async e=>{const{id:t,auths:s}=e,r=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[p.EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started]}});try{this.isInitialized()}catch(y){throw r.setError(p.EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection),y}const n=this.getPendingAuthRequest(t);if(!n)throw r.setError(p.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const o=n.transportType||p.TRANSPORT_TYPES.relay;o===p.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),u=i.hashKey(c),d={type:i.TYPE_1,receiverPublicKey:c,senderPublicKey:l},g=[],h=[];for(const y of s){if(!await i.validateSignedCacao({cacao:y,projectId:this.client.core.projectId})){r.setError(p.EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);const T=i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:u,error:T,encodeOpts:d}),new Error(T.message)}r.addTrace(p.EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);const{p:m}=y,I=i.getRecapFromResources(m.resources),V=[i.getNamespacedDidChainId(m.iss)],R=i.getDidAddress(m.iss);if(I){const T=i.getMethodsFromRecap(I),L=i.getChainsFromRecap(I);g.push(...T),V.push(...L)}for(const T of V)h.push(`${T}:${R}`)}const _=await this.client.core.crypto.generateSharedKey(l,c);r.addTrace(p.EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);let S;if(g?.length>0){S={topic:_,acknowledged:!0,self:{publicKey:l,metadata:this.client.metadata},peer:{publicKey:c,metadata:n.requester.metadata},controller:c,expiry:i.calcExpiry(x),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:i.buildNamespacesFromAuth([...new Set(g)],[...new Set(h)]),transportType:o},r.addTrace(p.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(_,{transportType:o})}catch(y){throw r.setError(p.EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure),y}r.addTrace(p.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success),await this.client.session.set(_,S),r.addTrace(p.EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(p.EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);try{await this.sendResult({topic:u,id:t,result:{cacaos:s,responder:{publicKey:l,metadata:this.client.metadata}},encodeOpts:d,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,o)})}catch(y){throw r.setError(p.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure),y}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:S}},this.rejectSessionAuthenticate=async e=>{this.isInitialized();const{id:t,reason:s}=e,r=this.getPendingAuthRequest(t);if(!r)throw new Error(`Could not find pending auth request with id ${t}`);r.transportType===p.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const n=r.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),c=i.hashKey(n),l={type:i.TYPE_1,receiverPublicKey:n,senderPublicKey:o};await this.sendError({id:t,topic:c,error:s,encodeOpts:l,rpcOpts:f.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED"))},this.formatAuthMessage=e=>{this.isInitialized();const{request:t,iss:s}=e;return i.formatMessage(t,s)},this.processRelayMessageCache=()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)},this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,o;return((n=r.peerMetadata)==null?void 0:n.url)&&((o=r.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&r.topic&&r.topic!==t.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}},this.deleteSession=async e=>{var t;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:o=0}=e,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,i.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(ae).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===s&&this.deletePendingSessionRequest(l.id,i.getSdkError("USER_DISCONNECTED"))}),s===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=A.idle),n&&this.client.events.emit("session_delete",{id:o,topic:s})},this.deleteProposal=async(e,t)=>{if(t)try{const s=this.client.proposal.get(e),r=this.client.core.eventClient.getEvent({topic:s.pairingTopic});r?.setError(p.EVENT_CLIENT_SESSION_ERRORS.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")},this.deletePendingSessionRequest=async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==e),s&&(this.sessionRequestQueue.state=A.idle,this.client.events.emit("session_request_expire",{id:e}))},this.deletePendingAuthRequest=async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])},this.setExpiry=async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))},this.setProposal=async(e,t)=>{this.client.core.expirer.set(e,i.calcExpiry(f.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)},this.setAuthRequest=async(e,t)=>{const{request:s,pairingTopic:r,transportType:n=p.TRANSPORT_TYPES.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:r,verifyContext:s.verifyContext,transportType:n})},this.setPendingSessionRequest=async e=>{const{id:t,topic:s,params:r,verifyContext:n}=e,o=r.request.expiryTimestamp||i.calcExpiry(f.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,o),await this.client.pendingRequest.set(t,{id:t,topic:s,params:r,verifyContext:n})},this.sendRequest=async e=>{const{topic:t,method:s,params:r,expiry:n,relayRpcId:o,clientRpcId:c,throwOnFailedPublish:l,appLink:u}=e,d=E.formatJsonRpcRequest(s,r,c);let g;const h=!!u;try{const y=h?i.BASE64URL:i.BASE64;g=await this.client.core.crypto.encode(t,d,{encoding:y})}catch(y){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),y}let _;if(Re.includes(s)){const y=i.hashMessage(JSON.stringify(d)),m=i.hashMessage(g);_=await this.client.core.verify.register({id:m,decryptedId:y})}const S=f[s].req;if(S.attestation=_,n&&(S.ttl=n),o&&(S.id=o),this.client.core.history.set(t,d),h){const y=i.getLinkModeURL(u,t,g);await global.Linking.openURL(y,this.client.name)}else{const y=f[s].req;n&&(y.ttl=n),o&&(y.id=o),l?(y.internal=C(v({},y.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,g,y)):this.client.core.relayer.publish(t,g,y).catch(m=>this.client.logger.error(m))}return d.id},this.sendResult=async e=>{const{id:t,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:o,appLink:c}=e,l=E.formatJsonRpcResult(t,r);let u;const d=c&&typeof(global==null?void 0:global.Linking)<"u";try{const h=d?i.BASE64URL:i.BASE64;u=await this.client.core.crypto.encode(s,l,C(v({},o||{}),{encoding:h}))}catch(h){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),h}let g;try{g=await this.client.core.history.get(s,t)}catch(h){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`),h}if(d){const h=i.getLinkModeURL(c,s,u);await global.Linking.openURL(h,this.client.name)}else{const h=f[g.request.method].res;n?(h.internal=C(v({},h.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,u,h)):this.client.core.relayer.publish(s,u,h).catch(_=>this.client.logger.error(_))}await this.client.core.history.resolve(l)},this.sendError=async e=>{const{id:t,topic:s,error:r,encodeOpts:n,rpcOpts:o,appLink:c}=e,l=E.formatJsonRpcError(t,r);let u;const d=c&&typeof(global==null?void 0:global.Linking)<"u";try{const h=d?i.BASE64URL:i.BASE64;u=await this.client.core.crypto.encode(s,l,C(v({},n||{}),{encoding:h}))}catch(h){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),h}let g;try{g=await this.client.core.history.get(s,t)}catch(h){throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`),h}if(d){const h=i.getLinkModeURL(c,s,u);await global.Linking.openURL(h,this.client.name)}else{const h=o||f[g.request.method].res;this.client.core.relayer.publish(s,u,h)}await this.client.core.history.resolve(l)},this.cleanup=async()=>{const e=[],t=[];this.client.session.getAll().forEach(s=>{let r=!1;i.isExpired(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&e.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{i.isExpired(s.expiryTimestamp)&&t.push(s.id)}),await Promise.all([...e.map(s=>this.deleteSession({topic:s})),...t.map(s=>this.deleteProposal(s))])},this.onRelayEventRequest=async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===A.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=A.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=A.idle},this.processRequest=async e=>{const{topic:t,payload:s,attestation:r,transportType:n,encryptedId:o}=e,c=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:r,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:r,encryptedId:o,transportType:n});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:r,encryptedId:o,transportType:n});default:return this.client.logger.info(`Unsupported request method ${c}`)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:s,transportType:r}=e,n=(await this.client.core.history.get(t,s.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,r);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:t}=e,{message:s}=i.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)},this.shouldIgnorePairingRequest=e=>{const{topic:t,requestMethod:s}=e,r=this.expectedPairingMethodMap.get(t);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async e=>{const{topic:t,payload:s,attestation:r,encryptedId:n}=e,{params:o,id:c}=s;try{const l=this.client.core.eventClient.getEvent({topic:t});this.isValidConnect(v({},s.params));const u=o.expiryTimestamp||i.calcExpiry(f.wc_sessionPropose.req.ttl),d=v({id:c,pairingTopic:t,expiryTimestamp:u},o);await this.setProposal(c,d);const g=await this.getVerifyContext({attestationId:r,hash:i.hashMessage(JSON.stringify(s)),encryptedId:n,metadata:d.proposer.metadata});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),l?.setError(p.EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found)),l?.addTrace(p.EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:d,verifyContext:g})}catch(l){await this.sendError({id:c,topic:t,error:l,rpcOpts:f.wc_sessionPropose.autoReject}),this.client.logger.error(l)}},this.onSessionProposeResponse=async(e,t,s)=>{const{id:r}=t;if(E.isJsonRpcResult(t)){const{result:n}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const o=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const c=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const l=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:l});const u=await this.client.core.crypto.generateSharedKey(c,l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:u});const d=await this.client.core.relayer.subscribe(u,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:d}),await this.client.core.pairing.activate({topic:e})}else if(E.isJsonRpcError(t)){await this.client.proposal.delete(r,i.getSdkError("USER_DISCONNECTED"));const n=i.engineEvent("session_connect");if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners, 954`);this.events.emit(i.engineEvent("session_connect"),{error:t.error})}},this.onSessionSettleRequest=async(e,t)=>{const{id:s,params:r}=t;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:o,expiry:c,namespaces:l,sessionProperties:u,sessionConfig:d}=t.params,g=C(v(v({topic:e,relay:n,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},u&&{sessionProperties:u}),d&&{sessionConfig:d}),{transportType:p.TRANSPORT_TYPES.relay}),h=i.engineEvent("session_connect");if(this.events.listenerCount(h)===0)throw new Error(`emitting ${h} without any listeners 997`);this.events.emit(i.engineEvent("session_connect"),{session:g}),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}},this.onSessionSettleResponse=async(e,t)=>{const{id:s}=t;E.isJsonRpcResult(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",s),{})):E.isJsonRpcError(t)&&(await this.client.session.delete(e,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",s),{error:t.error}))},this.onSessionUpdateRequest=async(e,t)=>{const{params:s,id:r}=t;try{const n=`${e}_session_update`,o=i.MemoryStore.get(n);if(o&&this.isRequestOutOfSync(o,r)){this.client.logger.info(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:e,error:i.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(v({topic:e},s));try{i.MemoryStore.set(n,r),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:e,result:!0,throwOnFailedPublish:!0})}catch(c){throw i.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:e,params:s})}catch(n){await this.sendError({id:r,topic:e,error:n}),this.client.logger.error(n)}},this.isRequestOutOfSync=(e,t)=>parseInt(t.toString().slice(0,-3))<=parseInt(e.toString().slice(0,-3)),this.onSessionUpdateResponse=(e,t)=>{const{id:s}=t,r=i.engineEvent("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);E.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_update",s),{}):E.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_update",s),{error:t.error})},this.onSessionExtendRequest=async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,i.calcExpiry(x)),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}},this.onSessionExtendResponse=(e,t)=>{const{id:s}=t,r=i.engineEvent("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);E.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_extend",s),{}):E.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_extend",s),{error:t.error})},this.onSessionPingRequest=async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}},this.onSessionPingResponse=(e,t)=>{const{id:s}=t,r=i.engineEvent("session_ping",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{E.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_ping",s),{}):E.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_ping",s),{error:t.error})},500)},this.onSessionDeleteRequest=async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(p.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:e,id:s}))})}),this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:i.getSdkError("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async e=>{var t,s,r;const{topic:n,payload:o,attestation:c,encryptedId:l,transportType:u}=e,{id:d,params:g}=o;try{await this.isValidRequest(v({topic:n},g));const h=this.client.session.get(n),_=await this.getVerifyContext({attestationId:c,hash:i.hashMessage(JSON.stringify(E.formatJsonRpcRequest("wc_sessionRequest",g,d))),encryptedId:l,metadata:h.peer.metadata,transportType:u}),S={id:d,topic:n,params:g,verifyContext:_};await this.setPendingSessionRequest(S),u===p.TRANSPORT_TYPES.link_mode&&(t=h.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((s=h.peer.metadata.redirect)==null?void 0:s.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(S):(this.addSessionRequestToSessionRequestQueue(S),this.processSessionRequestQueue())}catch(h){await this.sendError({id:d,topic:n,error:h}),this.client.logger.error(h)}},this.onSessionRequestResponse=(e,t)=>{const{id:s}=t,r=i.engineEvent("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);E.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_request",s),{result:t.result}):E.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_request",s),{error:t.error})},this.onSessionEventRequest=async(e,t)=>{const{id:s,params:r}=t;try{const n=`${e}_session_event_${r.event.name}`,o=i.MemoryStore.get(n);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(v({topic:e},r)),this.client.events.emit("session_event",{id:s,topic:e,params:r}),i.MemoryStore.set(n,s)}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}},this.onSessionAuthenticateResponse=(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),E.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_request",s),{result:t.result}):E.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_request",s),{error:t.error})},this.onSessionAuthenticateRequest=async e=>{var t;const{topic:s,payload:r,attestation:n,encryptedId:o,transportType:c}=e;try{const{requester:l,authPayload:u,expiryTimestamp:d}=r.params,g=await this.getVerifyContext({attestationId:n,hash:i.hashMessage(JSON.stringify(r)),encryptedId:o,metadata:l.metadata,transportType:c}),h={requester:l,pairingTopic:s,id:r.id,authPayload:u,verifyContext:g,expiryTimestamp:d};await this.setAuthRequest(r.id,{request:h,pairingTopic:s,transportType:c}),c===p.TRANSPORT_TYPES.link_mode&&(t=l.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:r.params,id:r.id,verifyContext:g})}catch(l){this.client.logger.error(l);const u=r.params.requester.publicKey,d=await this.client.core.crypto.generateKeyPair(),g=this.getAppLinkIfEnabled(r.params.requester.metadata,c),h={type:i.TYPE_1,receiverPublicKey:u,senderPublicKey:d};await this.sendError({id:r.id,topic:s,error:l,encodeOpts:h,rpcOpts:f.wc_sessionAuthenticate.autoReject,appLink:g})}},this.addSessionRequestToSessionRequestQueue=e=>{this.sessionRequestQueue.queue.push(e)},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=A.idle,this.processSessionRequestQueue()},w.toMiliseconds(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===e&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,o=i.engineEvent("session_request",n);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(i.engineEvent("session_request",r.request.id),{error:t})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===A.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=A.active,this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}},this.emitSessionRequest=e=>{this.client.events.emit("session_request",e)},this.onPairingCreated=e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(s=>s.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:E.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties},t.id)})},this.isValidConnect=async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(c)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,relays:o}=e;if(i.isUndefined(t)||await this.isValidPairingTopic(t),!i.isValidRelays(o,!0)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(c)}!i.isUndefined(s)&&i.isValidObject(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(e,t)=>{const s=i.isValidRequiredNamespaces(e,"connect()",t);if(s)throw new Error(s.message)},this.isValidApprove=async e=>{if(!i.isValidParams(e))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:r,sessionProperties:n}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const o=this.client.proposal.get(t),c=i.isValidNamespaces(s,"approve()");if(c)throw new Error(c.message);const l=i.isConformingNamespaces(o.requiredNamespaces,s,"approve()");if(l)throw new Error(l.message);if(!i.isValidString(r,!0)){const{message:u}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(u)}i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async e=>{if(!i.isValidParams(e)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(r)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!i.isValidErrorReason(s)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidSessionSettleRequest=e=>{if(!i.isValidParams(e)){const{message:l}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(l)}const{relay:t,controller:s,namespaces:r,expiry:n}=e;if(!i.isValidRelay(t)){const{message:l}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const o=i.isValidController(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const c=i.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(i.isExpired(n)){const{message:l}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(c)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const r=this.client.session.get(t),n=i.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const o=i.isConformingNamespaces(r.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!i.isValidParams(e)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)},this.isValidRequest=async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(c)}const{topic:t,request:s,chainId:r,expiry:n}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:o}=this.client.session.get(t);if(!i.isValidNamespacesChainId(o,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!i.isValidRequest(s)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!i.isValidNamespacesRequest(o,r,s.method)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!i.isValidRequestExpiry(n,J)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${J.min} and ${J.max}`);throw new Error(c)}},this.isValidRespond=async e=>{var t;if(!i.isValidParams(e)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(n)}const{topic:s,response:r}=e;try{await this.isValidSessionTopic(s)}catch(n){throw(t=e?.response)!=null&&t.id&&this.cleanupAfterResponse(e),n}if(!i.isValidResponse(r)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}},this.isValidPing=async e=>{if(!i.isValidParams(e)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidEmit=async e=>{if(!i.isValidParams(e)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:t,event:s,chainId:r}=e;await this.isValidSessionTopic(t);const{namespaces:n}=this.client.session.get(t);if(!i.isValidNamespacesChainId(n,r)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(o)}if(!i.isValidEvent(s)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!i.isValidNamespacesEvent(n,r,s.name)){const{message:o}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!i.isValidParams(e)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)},this.isValidAuthenticate=e=>{const{chains:t,uri:s,domain:r,nonce:n}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!i.isValidString(s,!1))throw new Error("uri is required parameter");if(!i.isValidString(r,!1))throw new Error("domain is required parameter");if(!i.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(c=>i.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=i.parseChainId(t[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async e=>{const{attestationId:t,hash:s,encryptedId:r,metadata:n,transportType:o}=e,c={verified:{verifyUrl:n.verifyUrl||p.VERIFY_SERVER,validation:"UNKNOWN",origin:n.url||""}};try{if(o===p.TRANSPORT_TYPES.link_mode){const u=this.getAppLinkIfEnabled(n,o);return c.verified.validation=u&&new URL(u).origin===new URL(n.url).origin?"VALID":"INVALID",c}const l=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});l&&(c.verified.origin=l.origin,c.verified.isScam=l.isScam,c.verified.validation=l.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(l){this.client.logger.warn(l)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c},this.validateSessionProps=(e,t)=>{Object.values(e).forEach(s=>{if(!i.isValidString(s,!1)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(r)}})},this.getPendingAuthRequest=e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0},this.addToRecentlyDeleted=(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}},this.checkRecentlyDeleted=e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}},this.isLinkModeEnabled=(e,t)=>{var s,r,n,o,c,l,u,d,g;return!e||t!==p.TRANSPORT_TYPES.link_mode?!1:((r=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:r.linkMode)===!0&&((o=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:o.universal)!==void 0&&((l=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:l.universal)!==""&&((u=e?.redirect)==null?void 0:u.universal)!==void 0&&((d=e?.redirect)==null?void 0:d.universal)!==""&&((g=e?.redirect)==null?void 0:g.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"},this.getAppLinkIfEnabled=(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?(s=e?.redirect)==null?void 0:s.universal:void 0},this.handleLinkModeMessage=({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=i.getSearchParamFromURL(e,"topic")||"",s=decodeURIComponent(i.getSearchParamFromURL(e,"wc_ev")||""),r=this.client.session.keys.includes(t);r&&this.client.session.update(t,{transportType:p.TRANSPORT_TYPES.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:r})},this.registerLinkModeListeners=async()=>{var e;if(typeof process<"u"&&process.env.IS_VITEST||i.isReactNative()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await t.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}}isInitialized(){if(!this.initialized){const{message:a}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(a)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(p.RELAYER_EVENTS.message,a=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(a):this.onRelayMessage(a)})}async onRelayMessage(a){const{topic:e,message:t,attestation:s,transportType:r}=a,{publicKey:n}=this.client.auth.authKeys.keys.includes(G)?this.client.auth.authKeys.get(G):{responseTopic:void 0,publicKey:void 0},o=await this.client.core.crypto.decode(e,t,{receiverPublicKey:n,encoding:r===p.TRANSPORT_TYPES.link_mode?i.BASE64URL:i.BASE64});try{E.isJsonRpcRequest(o)?(this.client.core.history.set(e,o),this.onRelayEventRequest({topic:e,payload:o,attestation:s,transportType:r,encryptedId:i.hashMessage(t)})):E.isJsonRpcResponse(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:e,payload:o,transportType:r}),this.client.core.history.delete(e,o.id)):this.onRelayEventUnknownPayload({topic:e,payload:o,transportType:r})}catch(c){this.client.logger.error(c)}}registerExpirerEvents(){this.client.core.expirer.on(p.EXPIRER_EVENTS.expired,async a=>{const{topic:e,id:t}=i.parseExpirerTarget(a.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,i.getInternalError("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,i.getInternalError("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(p.PAIRING_EVENTS.create,a=>this.onPairingCreated(a)),this.client.core.pairing.events.on(p.PAIRING_EVENTS.delete,a=>{this.addToRecentlyDeleted(a.topic,"pairing")})}isValidPairingTopic(a){if(!i.isValidString(a,!1)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${a}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(a)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${a}`);throw new Error(e)}if(i.isExpired(this.client.core.pairing.pairings.get(a).expiry)){const{message:e}=i.getInternalError("EXPIRED",`pairing topic: ${a}`);throw new Error(e)}}async isValidSessionTopic(a){if(!i.isValidString(a,!1)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${a}`);throw new Error(e)}if(this.checkRecentlyDeleted(a),!this.client.session.keys.includes(a)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${a}`);throw new Error(e)}if(i.isExpired(this.client.session.get(a).expiry)){await this.deleteSession({topic:a});const{message:e}=i.getInternalError("EXPIRED",`session topic: ${a}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(a)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${a}`);throw await this.deleteSession({topic:a}),new Error(e)}}async isValidSessionOrPairingTopic(a){if(this.checkRecentlyDeleted(a),this.client.session.keys.includes(a))await this.isValidSessionTopic(a);else if(this.client.core.pairing.pairings.keys.includes(a))this.isValidPairingTopic(a);else if(i.isValidString(a,!1)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${a}`);throw new Error(e)}else{const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${a}`);throw new Error(e)}}async isValidProposalId(a){if(!i.isValidId(a)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${a}`);throw new Error(e)}if(!this.client.proposal.keys.includes(a)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${a}`);throw new Error(e)}if(i.isExpired(this.client.proposal.get(a).expiryTimestamp)){await this.deleteProposal(a);const{message:e}=i.getInternalError("EXPIRED",`proposal id: ${a}`);throw new Error(e)}}}class Xe extends p.Store{constructor(a,e){super(a,e,ye,Q),this.core=a,this.logger=e}}class qe extends p.Store{constructor(a,e){super(a,e,Se,Q),this.core=a,this.logger=e}}class Je extends p.Store{constructor(a,e){super(a,e,we,Q,t=>t.id),this.core=a,this.logger=e}}class ze extends p.Store{constructor(a,e){super(a,e,Ne,K,()=>G),this.core=a,this.logger=e}}class Be extends p.Store{constructor(a,e){super(a,e,ve,K),this.core=a,this.logger=e}}class We extends p.Store{constructor(a,e){super(a,e,fe,K,t=>t.id),this.core=a,this.logger=e}}class Ze{constructor(a,e){this.core=a,this.logger=e,this.authKeys=new ze(this.core,this.logger),this.pairingTopics=new Be(this.core,this.logger),this.requests=new We(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class z extends ge.ISignClient{constructor(a){super(a),this.protocol=re,this.version=ne,this.name=X.name,this.events=new Ee.EventEmitter,this.on=(t,s)=>this.events.on(t,s),this.once=(t,s)=>this.events.once(t,s),this.off=(t,s)=>this.events.off(t,s),this.removeListener=(t,s)=>this.events.removeListener(t,s),this.removeAllListeners=t=>this.events.removeAllListeners(t),this.connect=async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}},this.pair=async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}},this.approve=async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}},this.reject=async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}},this.update=async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}},this.extend=async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}},this.request=async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}},this.respond=async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}},this.ping=async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}},this.emit=async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}},this.disconnect=async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}},this.find=t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}},this.authenticate=async(t,s)=>{try{return await this.engine.authenticate(t,s)}catch(r){throw this.logger.error(r.message),r}},this.formatAuthMessage=t=>{try{return this.engine.formatAuthMessage(t)}catch(s){throw this.logger.error(s.message),s}},this.approveSessionAuthenticate=async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}},this.rejectSessionAuthenticate=async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}},this.name=a?.name||X.name,this.metadata=a?.metadata||i.getAppMetadata(),this.signConfig=a?.signConfig;const e=typeof a?.logger<"u"&&typeof a?.logger!="string"?a.logger:j.pino(j.getDefaultLoggerOptions({level:a?.logger||X.logger}));this.core=a?.core||new p.Core(a),this.logger=j.generateChildLogger(e,this.name),this.session=new qe(this.core,this.logger),this.proposal=new Xe(this.core,this.logger),this.pendingRequest=new Je(this.core,this.logger),this.engine=new Qe(this),this.auth=new Ze(this.core,this.logger)}static async init(a){const e=new z(a);return await e.initialize(),e}get context(){return j.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),this.engine.processRelayMessageCache()}catch(a){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(a.message),a}}}const et=qe,tt=z;exports.AUTH_CONTEXT=Te,exports.AUTH_KEYS_CONTEXT=Ne,exports.AUTH_PAIRING_TOPIC_CONTEXT=ve,exports.AUTH_PROTOCOL=Ie,exports.AUTH_PUBLIC_KEY_NAME=G,exports.AUTH_REQUEST_CONTEXT=fe,exports.AUTH_STORAGE_PREFIX=K,exports.AUTH_VERSION=Ke,exports.ENGINE_CONTEXT=me,exports.ENGINE_QUEUE_STATES=A,exports.ENGINE_RPC_OPTS=f,exports.HISTORY_CONTEXT=Ue,exports.HISTORY_EVENTS=Me,exports.HISTORY_STORAGE_VERSION=ke,exports.METHODS_TO_VERIFY=Re,exports.PROPOSAL_CONTEXT=ye,exports.PROPOSAL_EXPIRY=$e,exports.PROPOSAL_EXPIRY_MESSAGE=_e,exports.REQUEST_CONTEXT=we,exports.SESSION_CONTEXT=Se,exports.SESSION_EXPIRY=x,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=J,exports.SIGN_CLIENT_CONTEXT=oe,exports.SIGN_CLIENT_DEFAULT=X,exports.SIGN_CLIENT_EVENTS=De,exports.SIGN_CLIENT_PROTOCOL=re,exports.SIGN_CLIENT_STORAGE_OPTIONS=xe,exports.SIGN_CLIENT_STORAGE_PREFIX=Q,exports.SIGN_CLIENT_VERSION=ne,exports.SessionStore=et,exports.SignClient=tt,exports.WALLETCONNECT_DEEPLINK_CHOICE=ae,exports.default=z;
//# sourceMappingURL=index.cjs.js.map
