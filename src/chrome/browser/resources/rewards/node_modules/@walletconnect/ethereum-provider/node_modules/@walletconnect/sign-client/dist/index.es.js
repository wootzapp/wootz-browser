import{RELAYER_DEFAULT_PROTOCOL as ot,EVENT_CLIENT_SESSION_TRACES as C,EVENT_CLIENT_SESSION_ERRORS as U,EVENT_CLIENT_AUTHENTICATE_TRACES as G,EVENT_CLIENT_AUTHENTICATE_ERRORS as Z,EVENT_CLIENT_PAIRING_ERRORS as at,EVENT_CLIENT_PAIRING_TRACES as ct,RELAYER_EVENTS as Ae,VERIFY_SERVER as lt,EXPIRER_EVENTS as ht,PAIRING_EVENTS as Ce,Store as H,Core as pt}from"@walletconnect/core";import{pino as dt,getDefaultLoggerOptions as ut,generateChildLogger as gt,getLoggerContext as wt}from"@walletconnect/logger";import{IEngine as yt,ISignClient as mt}from"@walletconnect/types";import{getInternalError as p,calcExpiry as T,createDelayedPromise as z,engineEvent as w,getSdkError as N,getDeepLink as _t,handleDeeplinkRedirect as Et,isSessionCompatible as Rt,hashKey as _e,parseChainId as Ee,createEncodedRecap as St,getRecapFromResources as Re,mergeEncodedRecaps as It,validateSignedCacao as be,getNamespacedDidChainId as xe,getDidAddress as De,getMethodsFromRecap as Ve,getChainsFromRecap as Me,buildNamespacesFromAuth as Le,formatMessage as ft,hashMessage as Y,isExpired as X,MemoryStore as ee,isValidParams as b,isUndefined as te,isValidRelays as qt,isValidObject as $e,isValidRequiredNamespaces as vt,isValidNamespaces as Se,isConformingNamespaces as Ke,isValidString as V,isValidErrorReason as Nt,isValidRelay as Pt,isValidController as Tt,isValidNamespacesChainId as Ue,isValidRequest as Ot,isValidNamespacesRequest as At,isValidRequestExpiry as Ct,isValidResponse as bt,isValidEvent as xt,isValidNamespacesEvent as Dt,parseExpirerTarget as Vt,isValidId as Mt,TYPE_1 as Ie,getAppMetadata as Lt}from"@walletconnect/utils";import $t,{EventEmitter as Kt}from"events";import{THIRTY_DAYS as Ut,SEVEN_DAYS as Ge,FIVE_MINUTES as P,ONE_DAY as M,ONE_HOUR as ke,ONE_SECOND as Gt,toMiliseconds as je}from"@walletconnect/time";import{payloadId as J,getBigIntRpcId as ae,isJsonRpcResult as L,isJsonRpcError as $,formatJsonRpcRequest as fe,formatJsonRpcResult as kt,formatJsonRpcError as jt,isJsonRpcRequest as Ft,isJsonRpcResponse as Qt}from"@walletconnect/jsonrpc-utils";const qe="wc",ve=2,Ne="client",ce=`${qe}@${ve}:${Ne}:`,le={name:Ne,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Ht={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},zt={database:":memory:"},Pe="WALLETCONNECT_DEEPLINK_CHOICE",Yt={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Xt="history",Jt="0.3",Fe="proposal",Bt=Ut,Qe="Proposal expired",He="session",k=Ge,ze="engine",S={wc_sessionPropose:{req:{ttl:P,prompt:!0,tag:1100},res:{ttl:P,prompt:!1,tag:1101},reject:{ttl:P,prompt:!1,tag:1120},autoReject:{ttl:P,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:P,prompt:!1,tag:1102},res:{ttl:P,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:M,prompt:!1,tag:1104},res:{ttl:M,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:M,prompt:!1,tag:1106},res:{ttl:M,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:P,prompt:!0,tag:1108},res:{ttl:P,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:P,prompt:!0,tag:1110},res:{ttl:P,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:M,prompt:!1,tag:1112},res:{ttl:M,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:M,prompt:!1,tag:1114},res:{ttl:M,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:ke,prompt:!0,tag:1116},res:{ttl:ke,prompt:!1,tag:1117},reject:{ttl:P,prompt:!1,tag:1118},autoReject:{ttl:P,prompt:!1,tag:1119}}},he={min:P,max:Ge},x={idle:"IDLE",active:"ACTIVE"},Ye="request",Xe=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Je="wc",Wt=1.5,Be="auth",We="authKeys",Ze="pairingTopics",et="requests",se=`${Je}@${1.5}:${Be}:`,ie=`${se}:PUB_KEY`;var Zt=Object.defineProperty,es=Object.defineProperties,ts=Object.getOwnPropertyDescriptors,tt=Object.getOwnPropertySymbols,ss=Object.prototype.hasOwnProperty,is=Object.prototype.propertyIsEnumerable,st=(I,n,t)=>n in I?Zt(I,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):I[n]=t,E=(I,n)=>{for(var t in n||(n={}))ss.call(n,t)&&st(I,t,n[t]);if(tt)for(var t of tt(n))is.call(n,t)&&st(I,t,n[t]);return I},j=(I,n)=>es(I,ts(n));class rs extends yt{constructor(n){super(n),this.name=ze,this.events=new $t,this.initialized=!1,this.requestQueue={state:x.idle,queue:[]},this.sessionRequestQueue={state:x.idle,queue:[]},this.requestQueueDelay=Gt,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(S)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},je(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=j(E({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:o,relays:a}=e;let c=s,h,l=!1;try{c&&(l=this.client.core.pairing.pairings.get(c).active)}catch(y){throw this.client.logger.error(`connect() -> pairing.get(${c}) failed`),y}if(!c||!l){const{topic:y,uri:R}=await this.client.core.pairing.create();c=y,h=R}if(!c){const{message:y}=p("NO_MATCHING_KEY",`connect() pairing topic: ${c}`);throw new Error(y)}const g=await this.client.core.crypto.generateKeyPair(),d=S.wc_sessionPropose.req.ttl||P,u=T(d),_=E({requiredNamespaces:i,optionalNamespaces:r,relays:a??[{protocol:ot}],proposer:{publicKey:g,metadata:this.client.metadata},expiryTimestamp:u,pairingTopic:c},o&&{sessionProperties:o}),{reject:q,resolve:m,done:O}=z(d,Qe);this.events.once(w("session_connect"),async({error:y,session:R})=>{if(y)q(y);else if(R){R.self.publicKey=g;const K=j(E({},R),{pairingTopic:_.pairingTopic,requiredNamespaces:_.requiredNamespaces,optionalNamespaces:_.optionalNamespaces});await this.client.session.set(R.topic,K),await this.setExpiry(R.topic,R.expiry),c&&await this.client.core.pairing.updateMetadata({topic:c,metadata:R.peer.metadata}),this.cleanupDuplicatePairings(K),m(K)}});const D=await this.sendRequest({topic:c,method:"wc_sessionPropose",params:_,throwOnFailedPublish:!0});return await this.setProposal(D,E({id:D},_)),{uri:h,approval:O}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{var e,s,i;const r=this.client.core.eventClient.createEvent({properties:{topic:(e=t?.id)==null?void 0:e.toString(),trace:[C.session_approve_started]}});try{await this.isInitialized()}catch(f){throw r.setError(U.no_internet_connection),f}try{await this.isValidProposalId(t?.id)}catch(f){throw this.client.logger.error(`approve() -> proposal.get(${t?.id}) failed`),r.setError(U.proposal_not_found),f}try{await this.isValidApprove(t)}catch(f){throw this.client.logger.error("approve() -> isValidApprove() failed"),r.setError(U.session_approve_namespace_validation_failure),f}const{id:o,relayProtocol:a,namespaces:c,sessionProperties:h,sessionConfig:l}=t,g=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:r.eventId});const{pairingTopic:d,proposer:u,requiredNamespaces:_,optionalNamespaces:q}=g;let m=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:d});m||(m=(i=this.client.core.eventClient)==null?void 0:i.createEvent({type:C.session_approve_started,properties:{topic:d,trace:[C.session_approve_started,C.session_namespaces_validation_success]}}));const O=await this.client.core.crypto.generateKeyPair(),D=u.publicKey,y=await this.client.core.crypto.generateSharedKey(O,D),R=E(E({relay:{protocol:a??"irn"},namespaces:c,controller:{publicKey:O,metadata:this.client.metadata},expiry:T(k)},h&&{sessionProperties:h}),l&&{sessionConfig:l});m.addTrace(C.subscribing_session_topic);try{await this.client.core.relayer.subscribe(y)}catch(f){throw m.setError(U.subscribe_session_topic_failure),f}m.addTrace(C.subscribe_session_topic_success);const K=j(E({},R),{topic:y,requiredNamespaces:_,optionalNamespaces:q,pairingTopic:d,acknowledged:!1,self:R.controller,peer:{publicKey:u.publicKey,metadata:u.metadata},controller:O});await this.client.session.set(y,K),m.addTrace(C.store_session);try{m.addTrace(C.publishing_session_settle),await this.sendRequest({topic:y,method:"wc_sessionSettle",params:R,throwOnFailedPublish:!0}).catch(f=>{throw m?.setError(U.session_settle_publish_failure),f}),m.addTrace(C.session_settle_publish_success),m.addTrace(C.publishing_session_approve),await this.sendResult({id:o,topic:d,result:{relay:{protocol:a??"irn"},responderPublicKey:O},throwOnFailedPublish:!0}).catch(f=>{throw m?.setError(U.session_approve_publish_failure),f}),m.addTrace(C.session_approve_publish_success)}catch(f){throw this.client.logger.error(f),this.client.session.delete(y,N("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(y),f}return this.client.core.eventClient.deleteEvent({eventId:m.eventId}),await this.client.core.pairing.updateMetadata({topic:d,metadata:u.metadata}),await this.client.proposal.delete(o,N("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:d}),await this.setExpiry(y,T(k)),{topic:y,acknowledged:()=>Promise.resolve(this.client.session.get(y))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(r){throw this.client.logger.error("reject() -> isValidReject() failed"),r}const{id:e,reason:s}=t;let i;try{i=this.client.proposal.get(e).pairingTopic}catch(r){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),r}i&&(await this.sendError({id:e,topic:i,error:s,rpcOpts:S.wc_sessionPropose.reject}),await this.client.proposal.delete(e,N("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(l){throw this.client.logger.error("update() -> isValidUpdate() failed"),l}const{topic:e,namespaces:s}=t,{done:i,resolve:r,reject:o}=z(),a=J(),c=ae().toString(),h=this.client.session.get(e).namespaces;return this.events.once(w("session_update",a),({error:l})=>{l?o(l):r()}),await this.client.session.update(e,{namespaces:s}),await this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:c}).catch(l=>{this.client.logger.error(l),this.client.session.update(e,{namespaces:h}),o(l)}),{acknowledged:i}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(a){throw this.client.logger.error("extend() -> isValidExtend() failed"),a}const{topic:e}=t,s=J(),{done:i,resolve:r,reject:o}=z();return this.events.once(w("session_extend",s),({error:a})=>{a?o(a):r()}),await this.setExpiry(e,T(k)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(a=>{o(a)}),{acknowledged:i}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(d){throw this.client.logger.error("request() -> isValidRequest() failed"),d}const{chainId:e,request:s,topic:i,expiry:r=S.wc_sessionRequest.req.ttl}=t,o=this.client.session.get(i),a=J(),c=ae().toString(),{done:h,resolve:l,reject:g}=z(r,"Request expired. Please try again.");return this.events.once(w("session_request",a),({error:d,result:u})=>{d?g(d):l(u)}),await Promise.all([new Promise(async d=>{await this.sendRequest({clientRpcId:a,relayRpcId:c,topic:i,method:"wc_sessionRequest",params:{request:j(E({},s),{expiryTimestamp:T(r)}),chainId:e},expiry:r,throwOnFailedPublish:!0}).catch(u=>g(u)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:e,id:a}),d()}),new Promise(async d=>{var u;if(!((u=o.sessionConfig)!=null&&u.disableDeepLink)){const _=await _t(this.client.core.storage,Pe);Et({id:a,topic:i,wcDeepLink:_})}d()}),h()]).then(d=>d[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:s}=t,{id:i}=s;L(s)?await this.sendResult({id:i,topic:e,result:s.result,throwOnFailedPublish:!0}):$(s)&&await this.sendError({id:i,topic:e,error:s.error}),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:e}=t;if(this.client.session.keys.includes(e)){const s=J(),i=ae().toString(),{done:r,resolve:o,reject:a}=z();this.events.once(w("session_ping",s),({error:c})=>{c?a(c):o()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:i}),r()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:s,chainId:i}=t,r=ae().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:s,chainId:i},throwOnFailedPublish:!0,relayRpcId:r})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:N("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:s}=p("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(s)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>Rt(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async t=>{this.isInitialized(),this.isValidAuthenticate(t);const{chains:e,statement:s="",uri:i,domain:r,nonce:o,type:a,exp:c,nbf:h,methods:l=[],expiry:g}=t,d=[...t.resources||[]],{topic:u,uri:_}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"]});this.client.logger.info({message:"Generated new pairing",pairing:{topic:u,uri:_}});const q=await this.client.core.crypto.generateKeyPair(),m=_e(q);if(await Promise.all([this.client.auth.authKeys.set(ie,{responseTopic:m,publicKey:q}),this.client.auth.pairingTopics.set(m,{topic:m,pairingTopic:u})]),await this.client.core.relayer.subscribe(m),this.client.logger.info(`sending request to new pairing topic: ${u}`),l.length>0){const{namespace:A}=Ee(e[0]);let v=St(A,"request",l);Re(d)&&(v=It(v,d.pop())),d.push(v)}const O=g&&g>S.wc_sessionAuthenticate.req.ttl?g:S.wc_sessionAuthenticate.req.ttl,D={authPayload:{type:a??"caip122",chains:e,statement:s,aud:i,domain:r,version:"1",nonce:o,iat:new Date().toISOString(),exp:c,nbf:h,resources:d},requester:{publicKey:q,metadata:this.client.metadata},expiryTimestamp:T(O)},y={eip155:{chains:e,methods:[...new Set(["personal_sign",...l])],events:["chainChanged","accountsChanged"]}},R={requiredNamespaces:{},optionalNamespaces:y,relays:[{protocol:"irn"}],pairingTopic:u,proposer:{publicKey:q,metadata:this.client.metadata},expiryTimestamp:T(S.wc_sessionPropose.req.ttl)},{done:K,resolve:f,reject:de}=z(O,"Request expired"),re=async({error:A,session:v})=>{if(this.events.off(w("session_request",F),ue),A)de(A);else if(v){v.self.publicKey=q,await this.client.session.set(v.topic,v),await this.setExpiry(v.topic,v.expiry),u&&await this.client.core.pairing.updateMetadata({topic:u,metadata:v.peer.metadata});const Q=this.client.session.get(v.topic);await this.deleteProposal(B),f({session:Q})}},ue=async A=>{if(await this.deletePendingAuthRequest(F,{message:"fulfilled",code:0}),A.error){const W=N("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return A.error.code===W.code?void 0:(this.events.off(w("session_connect"),re),de(A.error.message))}await this.deleteProposal(B),this.events.off(w("session_connect"),re);const{cacaos:v,responder:Q}=A.result,ge=[],Te=[];for(const W of v){await be({cacao:W,projectId:this.client.core.projectId})||(this.client.logger.error(W,"Signature verification failed"),de(N("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:we}=W,ye=Re(we.resources),Oe=[xe(we.iss)],rt=De(we.iss);if(ye){const me=Ve(ye),nt=Me(ye);ge.push(...me),Oe.push(...nt)}for(const me of Oe)Te.push(`${me}:${rt}`)}const ne=await this.client.core.crypto.generateSharedKey(q,Q.publicKey);let oe;ge.length>0&&(oe={topic:ne,acknowledged:!0,self:{publicKey:q,metadata:this.client.metadata},peer:Q,controller:Q.publicKey,expiry:T(k),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:u,namespaces:Le([...new Set(ge)],[...new Set(Te)])},await this.client.core.relayer.subscribe(ne),await this.client.session.set(ne,oe),u&&await this.client.core.pairing.updateMetadata({topic:u,metadata:Q.metadata}),oe=this.client.session.get(ne)),f({auths:v,session:oe})},F=J(),B=J();this.events.once(w("session_connect"),re),this.events.once(w("session_request",F),ue);try{await Promise.all([this.sendRequest({topic:u,method:"wc_sessionAuthenticate",params:D,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:F}),this.sendRequest({topic:u,method:"wc_sessionPropose",params:R,expiry:S.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:B})])}catch(A){throw this.events.off(w("session_connect"),re),this.events.off(w("session_request",F),ue),A}return await this.setProposal(B,E({id:B},R)),await this.setAuthRequest(F,{request:j(E({},D),{verifyContext:{}}),pairingTopic:u}),{uri:_,response:K}},this.approveSessionAuthenticate=async t=>{const{id:e,auths:s}=t,i=this.client.core.eventClient.createEvent({properties:{topic:e.toString(),trace:[G.authenticated_session_approve_started]}});try{this.isInitialized()}catch(_){throw i.setError(Z.no_internet_connection),_}const r=this.getPendingAuthRequest(e);if(!r)throw i.setError(Z.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${e}`);const o=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=_e(o),h={type:Ie,receiverPublicKey:o,senderPublicKey:a},l=[],g=[];for(const _ of s){if(!await be({cacao:_,projectId:this.client.core.projectId})){i.setError(Z.invalid_cacao);const y=N("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:c,error:y,encodeOpts:h}),new Error(y.message)}i.addTrace(G.cacaos_verified);const{p:q}=_,m=Re(q.resources),O=[xe(q.iss)],D=De(q.iss);if(m){const y=Ve(m),R=Me(m);l.push(...y),O.push(...R)}for(const y of O)g.push(`${y}:${D}`)}const d=await this.client.core.crypto.generateSharedKey(a,o);i.addTrace(G.create_authenticated_session_topic);let u;if(l?.length>0){u={topic:d,acknowledged:!0,self:{publicKey:a,metadata:this.client.metadata},peer:{publicKey:o,metadata:r.requester.metadata},controller:o,expiry:T(k),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:r.pairingTopic,namespaces:Le([...new Set(l)],[...new Set(g)])},i.addTrace(G.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(d)}catch(_){throw i.setError(Z.subscribe_authenticated_session_topic_failure),_}i.addTrace(G.subscribe_authenticated_session_topic_success),await this.client.session.set(d,u),i.addTrace(G.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:r.pairingTopic,metadata:r.requester.metadata})}i.addTrace(G.publishing_authenticated_session_approve);try{await this.sendResult({topic:c,id:e,result:{cacaos:s,responder:{publicKey:a,metadata:this.client.metadata}},encodeOpts:h,throwOnFailedPublish:!0})}catch(_){throw i.setError(Z.authenticated_session_approve_publish_failure),_}return await this.client.auth.requests.delete(e,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:r.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:i.eventId}),{session:u}},this.rejectSessionAuthenticate=async t=>{await this.isInitialized();const{id:e,reason:s}=t,i=this.getPendingAuthRequest(e);if(!i)throw new Error(`Could not find pending auth request with id ${e}`);const r=i.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=_e(r),c={type:Ie,receiverPublicKey:r,senderPublicKey:o};await this.sendError({id:e,topic:a,error:s,encodeOpts:c,rpcOpts:S.wc_sessionAuthenticate.reject}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.client.proposal.delete(e,N("USER_DISCONNECTED"))},this.formatAuthMessage=t=>{this.isInitialized();const{request:e,iss:s}=t;return ft(e,s)},this.processRelayMessageCache=()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)},this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(i=>{var r,o;return((r=i.peerMetadata)==null?void 0:r.url)&&((o=i.peerMetadata)==null?void 0:o.url)===t.peer.metadata.url&&i.topic&&i.topic!==e.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{var e;const{topic:s,expirerHasDeleted:i=!1,emitEvent:r=!0,id:o=0}=t,{self:a}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,N("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),i||this.client.core.expirer.del(s),this.client.core.storage.removeItem(Pe).catch(c=>this.client.logger.warn(c)),this.getPendingSessionRequests().forEach(c=>{c.topic===s&&this.deletePendingSessionRequest(c.id,N("USER_DISCONNECTED"))}),s===((e=this.sessionRequestQueue.queue[0])==null?void 0:e.topic)&&(this.sessionRequestQueue.state=x.idle),r&&this.client.events.emit("session_delete",{id:o,topic:s})},this.deleteProposal=async(t,e)=>{if(e)try{const s=this.client.proposal.get(t),i=this.client.core.eventClient.getEvent({topic:s.pairingTopic});i?.setError(U.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,N("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(i=>i.id!==t),s&&(this.sessionRequestQueue.state=x.idle,this.client.events.emit("session_request_expire",{id:t}))},this.deletePendingAuthRequest=async(t,e,s=!1)=>{await Promise.all([this.client.auth.requests.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)])},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,e),await this.client.session.update(t,{expiry:e}))},this.setProposal=async(t,e)=>{this.client.core.expirer.set(t,T(S.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,e)},this.setAuthRequest=async(t,e)=>{const{request:s,pairingTopic:i}=e;this.client.core.expirer.set(t,s.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:t,pairingTopic:i,verifyContext:s.verifyContext})},this.setPendingSessionRequest=async t=>{const{id:e,topic:s,params:i,verifyContext:r}=t,o=i.request.expiryTimestamp||T(S.wc_sessionRequest.req.ttl);this.client.core.expirer.set(e,o),await this.client.pendingRequest.set(e,{id:e,topic:s,params:i,verifyContext:r})},this.sendRequest=async t=>{const{topic:e,method:s,params:i,expiry:r,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:c}=t,h=fe(s,i,a);let l;try{l=await this.client.core.crypto.encode(e,h)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),u}let g;if(Xe.includes(s)){const u=Y(JSON.stringify(h)),_=Y(l);g=await this.client.core.verify.register({id:_,decryptedId:u})}const d=S[s].req;return d.attestation=g,r&&(d.ttl=r),o&&(d.id=o),this.client.core.history.set(e,h),c?(d.internal=j(E({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,l,d)):this.client.core.relayer.publish(e,l,d).catch(u=>this.client.logger.error(u)),h.id},this.sendResult=async t=>{const{id:e,topic:s,result:i,throwOnFailedPublish:r,encodeOpts:o}=t,a=kt(e,i);let c;try{c=await this.client.core.crypto.encode(s,a,o)}catch(g){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),g}let h;try{h=await this.client.core.history.get(s,e)}catch(g){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`),g}const l=S[h.request.method].res;r?(l.internal=j(E({},l.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,c,l)):this.client.core.relayer.publish(s,c,l).catch(g=>this.client.logger.error(g)),await this.client.core.history.resolve(a)},this.sendError=async t=>{const{id:e,topic:s,error:i,encodeOpts:r,rpcOpts:o}=t,a=jt(e,i);let c;try{c=await this.client.core.crypto.encode(s,a,r)}catch(g){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),g}let h;try{h=await this.client.core.history.get(s,e)}catch(g){throw this.client.logger.error(`sendError() -> history.get(${s}, ${e}) failed`),g}const l=o||S[h.request.method].res;this.client.core.relayer.publish(s,c,l),await this.client.core.history.resolve(a)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(s=>{let i=!1;X(s.expiry)&&(i=!0),this.client.core.crypto.keychain.has(s.topic)||(i=!0),i&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{X(s.expiryTimestamp)&&e.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...e.map(s=>this.deleteProposal(s))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===x.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=x.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=x.idle},this.processRequest=async t=>{const{topic:e,payload:s,attestation:i,encryptedId:r}=t,o=s.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:o}))switch(o){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:e,payload:s,attestation:i,encryptedId:r});case"wc_sessionSettle":return await this.onSessionSettleRequest(e,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(e,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(e,s);case"wc_sessionPing":return await this.onSessionPingRequest(e,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(e,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:e,payload:s,attestation:i,encryptedId:r});case"wc_sessionEvent":return await this.onSessionEventRequest(e,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:e,payload:s,attestation:i,encryptedId:r});default:return this.client.logger.info(`Unsupported request method ${o}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:s}=t,i=(await this.client.core.history.get(e,s.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(e,s);case"wc_sessionSettle":return this.onSessionSettleResponse(e,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,s);case"wc_sessionExtend":return this.onSessionExtendResponse(e,s);case"wc_sessionPing":return this.onSessionPingResponse(e,s);case"wc_sessionRequest":return this.onSessionRequestResponse(e,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,s);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:s}=p("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)},this.shouldIgnorePairingRequest=t=>{const{topic:e,requestMethod:s}=t,i=this.expectedPairingMethodMap.get(e);return!i||i.includes(s)?!1:!!(i.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async t=>{const{topic:e,payload:s,attestation:i,encryptedId:r}=t,{params:o,id:a}=s;try{const c=this.client.core.eventClient.getEvent({topic:e});this.isValidConnect(E({},s.params));const h=o.expiryTimestamp||T(S.wc_sessionPropose.req.ttl),l=E({id:a,pairingTopic:e,expiryTimestamp:h},o);await this.setProposal(a,l);const g=await this.getVerifyContext({attestationId:i,hash:Y(JSON.stringify(s)),encryptedId:r,metadata:l.proposer.metadata});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),c?.setError(at.proposal_listener_not_found)),c?.addTrace(ct.emit_session_proposal),this.client.events.emit("session_proposal",{id:a,params:l,verifyContext:g})}catch(c){await this.sendError({id:a,topic:e,error:c,rpcOpts:S.wc_sessionPropose.autoReject}),this.client.logger.error(c)}},this.onSessionProposeResponse=async(t,e)=>{const{id:s}=e;if(L(e)){const{result:i}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const r=this.client.proposal.get(s);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:r});const o=r.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const c=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:c});const h=await this.client.core.relayer.subscribe(c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:t})}else if($(e)){await this.client.proposal.delete(s,N("USER_DISCONNECTED"));const i=w("session_connect");if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners, 954`);this.events.emit(w("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:s,params:i}=e;try{this.isValidSessionSettleRequest(i);const{relay:r,controller:o,expiry:a,namespaces:c,sessionProperties:h,sessionConfig:l}=e.params,g=E(E({topic:t,relay:r,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},h&&{sessionProperties:h}),l&&{sessionConfig:l}),d=w("session_connect");if(this.events.listenerCount(d)===0)throw new Error(`emitting ${d} without any listeners 997`);this.events.emit(w("session_connect"),{session:g}),await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionSettleResponse=async(t,e)=>{const{id:s}=e;L(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(w("session_approve",s),{})):$(e)&&(await this.client.session.delete(t,N("USER_DISCONNECTED")),this.events.emit(w("session_approve",s),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:s,id:i}=e;try{const r=`${t}_session_update`,o=ee.get(r);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.info(`Discarding out of sync request - ${i}`),this.sendError({id:i,topic:t,error:N("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(E({topic:t},s));try{ee.set(r,i),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0})}catch(a){throw ee.delete(r),a}this.client.events.emit("session_update",{id:i,topic:t,params:s})}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:s}=e,i=w("session_update",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);L(e)?this.events.emit(w("session_update",s),{}):$(e)&&this.events.emit(w("session_update",s),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:s}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,T(k)),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(i){await this.sendError({id:s,topic:t,error:i}),this.client.logger.error(i)}},this.onSessionExtendResponse=(t,e)=>{const{id:s}=e,i=w("session_extend",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);L(e)?this.events.emit(w("session_extend",s),{}):$(e)&&this.events.emit(w("session_extend",s),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:s}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(i){await this.sendError({id:s,topic:t,error:i}),this.client.logger.error(i)}},this.onSessionPingResponse=(t,e)=>{const{id:s}=e,i=w("session_ping",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);setTimeout(()=>{L(e)?this.events.emit(w("session_ping",s),{}):$(e)&&this.events.emit(w("session_ping",s),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:s}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(i=>{this.client.core.relayer.once(Ae.publish,async()=>{i(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:N("USER_DISCONNECTED")})])}catch(i){this.client.logger.error(i)}},this.onSessionRequest=async t=>{var e;const{topic:s,payload:i,attestation:r,encryptedId:o}=t,{id:a,params:c}=i;try{await this.isValidRequest(E({topic:s},c));const h=this.client.session.get(s),l=await this.getVerifyContext({attestationId:r,hash:Y(JSON.stringify(fe("wc_sessionRequest",c,a))),encryptedId:o,metadata:h.peer.metadata}),g={id:a,topic:s,params:c,verifyContext:l};await this.setPendingSessionRequest(g),(e=this.client.signConfig)!=null&&e.disableRequestQueue?this.emitSessionRequest(g):(this.addSessionRequestToSessionRequestQueue(g),this.processSessionRequestQueue())}catch(h){await this.sendError({id:a,topic:s,error:h}),this.client.logger.error(h)}},this.onSessionRequestResponse=(t,e)=>{const{id:s}=e,i=w("session_request",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);L(e)?this.events.emit(w("session_request",s),{result:e.result}):$(e)&&this.events.emit(w("session_request",s),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:s,params:i}=e;try{const r=`${t}_session_event_${i.event.name}`,o=ee.get(r);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(E({topic:t},i)),this.client.events.emit("session_event",{id:s,topic:t,params:i}),ee.set(r,s)}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionAuthenticateResponse=(t,e)=>{const{id:s}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),L(e)?this.events.emit(w("session_request",s),{result:e.result}):$(e)&&this.events.emit(w("session_request",s),{error:e.error})},this.onSessionAuthenticateRequest=async t=>{const{topic:e,payload:s,attestation:i,encryptedId:r}=t;try{const{requester:o,authPayload:a,expiryTimestamp:c}=s.params,h=await this.getVerifyContext({attestationId:i,hash:Y(JSON.stringify(s)),encryptedId:r,metadata:this.client.metadata}),l={requester:o,pairingTopic:e,id:s.id,authPayload:a,verifyContext:h,expiryTimestamp:c};await this.setAuthRequest(s.id,{request:l,pairingTopic:e}),this.client.events.emit("session_authenticate",{topic:e,params:s.params,id:s.id,verifyContext:h})}catch(o){this.client.logger.error(o);const a=s.params.requester.publicKey,c=await this.client.core.crypto.generateKeyPair(),h={type:Ie,receiverPublicKey:a,senderPublicKey:c};await this.sendError({id:s.id,topic:e,error:o,encodeOpts:h,rpcOpts:S.wc_sessionAuthenticate.autoReject})}},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=x.idle,this.processSessionRequestQueue()},je(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(i=>i.topic===t&&i.request.method==="wc_sessionRequest").forEach(i=>{const r=i.request.id,o=w("session_request",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(w("session_request",i.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===x.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=x.active,this.emitSessionRequest(t)}catch(e){this.client.logger.error(e)}},this.emitSessionRequest=t=>{this.client.events.emit("session_request",t)},this.onPairingCreated=t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);e&&this.onSessionProposeRequest({topic:t.topic,payload:fe("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id)})},this.isValidConnect=async t=>{if(!b(t)){const{message:a}=p("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(a)}const{pairingTopic:e,requiredNamespaces:s,optionalNamespaces:i,sessionProperties:r,relays:o}=t;if(te(e)||await this.isValidPairingTopic(e),!qt(o,!0)){const{message:a}=p("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!te(s)&&$e(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!te(i)&&$e(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),te(r)||this.validateSessionProps(r,"sessionProperties")},this.validateNamespaces=(t,e)=>{const s=vt(t,"connect()",e);if(s)throw new Error(s.message)},this.isValidApprove=async t=>{if(!b(t))throw new Error(p("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:s,relayProtocol:i,sessionProperties:r}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const o=this.client.proposal.get(e),a=Se(s,"approve()");if(a)throw new Error(a.message);const c=Ke(o.requiredNamespaces,s,"approve()");if(c)throw new Error(c.message);if(!V(i,!0)){const{message:h}=p("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(h)}te(r)||this.validateSessionProps(r,"sessionProperties")},this.isValidReject=async t=>{if(!b(t)){const{message:i}=p("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(i)}const{id:e,reason:s}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!Nt(s)){const{message:i}=p("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(i)}},this.isValidSessionSettleRequest=t=>{if(!b(t)){const{message:c}=p("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(c)}const{relay:e,controller:s,namespaces:i,expiry:r}=t;if(!Pt(e)){const{message:c}=p("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(c)}const o=Tt(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=Se(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(X(r)){const{message:c}=p("EXPIRED","onSessionSettleRequest()");throw new Error(c)}},this.isValidUpdate=async t=>{if(!b(t)){const{message:a}=p("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(a)}const{topic:e,namespaces:s}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const i=this.client.session.get(e),r=Se(s,"update()");if(r)throw new Error(r.message);const o=Ke(i.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async t=>{if(!b(t)){const{message:s}=p("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!b(t)){const{message:a}=p("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(a)}const{topic:e,request:s,chainId:i,expiry:r}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:o}=this.client.session.get(e);if(!Ue(o,i)){const{message:a}=p("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!Ot(s)){const{message:a}=p("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(a)}if(!At(o,i,s.method)){const{message:a}=p("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(a)}if(r&&!Ct(r,he)){const{message:a}=p("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${he.min} and ${he.max}`);throw new Error(a)}},this.isValidRespond=async t=>{var e;if(!b(t)){const{message:r}=p("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(r)}const{topic:s,response:i}=t;try{await this.isValidSessionTopic(s)}catch(r){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),r}if(!bt(i)){const{message:r}=p("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(r)}},this.isValidPing=async t=>{if(!b(t)){const{message:s}=p("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!b(t)){const{message:o}=p("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(o)}const{topic:e,event:s,chainId:i}=t;await this.isValidSessionTopic(e);const{namespaces:r}=this.client.session.get(e);if(!Ue(r,i)){const{message:o}=p("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!xt(s)){const{message:o}=p("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!Dt(r,i,s.name)){const{message:o}=p("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}},this.isValidDisconnect=async t=>{if(!b(t)){const{message:s}=p("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidAuthenticate=t=>{const{chains:e,uri:s,domain:i,nonce:r}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!V(s,!1))throw new Error("uri is required parameter");if(!V(i,!1))throw new Error("domain is required parameter");if(!V(r,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(a=>Ee(a).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=Ee(e[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async t=>{const{attestationId:e,hash:s,encryptedId:i,metadata:r}=t,o={verified:{verifyUrl:r.verifyUrl||lt,validation:"UNKNOWN",origin:r.url||""}};try{const a=await this.client.core.verify.resolve({attestationId:e,hash:s,encryptedId:i,verifyUrl:r.verifyUrl});a&&(o.verified.origin=a.origin,o.verified.isScam=a.isScam,o.verified.validation=a.origin===new URL(r.url).origin?"VALID":"INVALID")}catch(a){this.client.logger.warn(a)}return this.client.logger.debug(`Verify context: ${JSON.stringify(o)}`),o},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(s=>{if(!V(s,!1)){const{message:i}=p("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(i)}})},this.getPendingAuthRequest=t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const i=this.recentlyDeletedLimit/2;for(const r of this.recentlyDeletedMap.keys()){if(s++>=i)break;this.recentlyDeletedMap.delete(r)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:s}=p("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(s)}}}async isInitialized(){if(!this.initialized){const{message:n}=p("NOT_INITIALIZED",this.name);throw new Error(n)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(Ae.message,n=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(n):this.onRelayMessage(n)})}async onRelayMessage(n){const{topic:t,message:e,attestation:s}=n,{publicKey:i}=this.client.auth.authKeys.keys.includes(ie)?this.client.auth.authKeys.get(ie):{responseTopic:void 0,publicKey:void 0},r=await this.client.core.crypto.decode(t,e,{receiverPublicKey:i});try{Ft(r)?(this.client.core.history.set(t,r),this.onRelayEventRequest({topic:t,payload:r,attestation:s,encryptedId:Y(e)})):Qt(r)?(await this.client.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.client.core.history.delete(t,r.id)):this.onRelayEventUnknownPayload({topic:t,payload:r})}catch(o){this.client.logger.error(o)}}registerExpirerEvents(){this.client.core.expirer.on(ht.expired,async n=>{const{topic:t,id:e}=Vt(n.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,p("EXPIRED"),!0);if(e&&this.client.auth.requests.keys.includes(e))return await this.deletePendingAuthRequest(e,p("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(Ce.create,n=>this.onPairingCreated(n)),this.client.core.pairing.events.on(Ce.delete,n=>{this.addToRecentlyDeleted(n.topic,"pairing")})}isValidPairingTopic(n){if(!V(n,!1)){const{message:t}=p("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:t}=p("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(t)}if(X(this.client.core.pairing.pairings.get(n).expiry)){const{message:t}=p("EXPIRED",`pairing topic: ${n}`);throw new Error(t)}}async isValidSessionTopic(n){if(!V(n,!1)){const{message:t}=p("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(t)}if(this.checkRecentlyDeleted(n),!this.client.session.keys.includes(n)){const{message:t}=p("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(t)}if(X(this.client.session.get(n).expiry)){await this.deleteSession({topic:n});const{message:t}=p("EXPIRED",`session topic: ${n}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(n)){const{message:t}=p("MISSING_OR_INVALID",`session topic does not exist in keychain: ${n}`);throw await this.deleteSession({topic:n}),new Error(t)}}async isValidSessionOrPairingTopic(n){if(this.checkRecentlyDeleted(n),this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(V(n,!1)){const{message:t}=p("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(t)}else{const{message:t}=p("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(t)}}async isValidProposalId(n){if(!Mt(n)){const{message:t}=p("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(t)}if(!this.client.proposal.keys.includes(n)){const{message:t}=p("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(t)}if(X(this.client.proposal.get(n).expiryTimestamp)){await this.deleteProposal(n);const{message:t}=p("EXPIRED",`proposal id: ${n}`);throw new Error(t)}}}class ns extends H{constructor(n,t){super(n,t,Fe,ce),this.core=n,this.logger=t}}class it extends H{constructor(n,t){super(n,t,He,ce),this.core=n,this.logger=t}}class os extends H{constructor(n,t){super(n,t,Ye,ce,e=>e.id),this.core=n,this.logger=t}}class as extends H{constructor(n,t){super(n,t,We,se,()=>ie),this.core=n,this.logger=t}}class cs extends H{constructor(n,t){super(n,t,Ze,se),this.core=n,this.logger=t}}class ls extends H{constructor(n,t){super(n,t,et,se,e=>e.id),this.core=n,this.logger=t}}class hs{constructor(n,t){this.core=n,this.logger=t,this.authKeys=new as(this.core,this.logger),this.pairingTopics=new cs(this.core,this.logger),this.requests=new ls(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class pe extends mt{constructor(n){super(n),this.protocol=qe,this.version=ve,this.name=le.name,this.events=new Kt,this.on=(e,s)=>this.events.on(e,s),this.once=(e,s)=>this.events.once(e,s),this.off=(e,s)=>this.events.off(e,s),this.removeListener=(e,s)=>this.events.removeListener(e,s),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(s){throw this.logger.error(s.message),s}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(s){throw this.logger.error(s.message),s}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(s){throw this.logger.error(s.message),s}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(s){throw this.logger.error(s.message),s}},this.update=async e=>{try{return await this.engine.update(e)}catch(s){throw this.logger.error(s.message),s}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(s){throw this.logger.error(s.message),s}},this.request=async e=>{try{return await this.engine.request(e)}catch(s){throw this.logger.error(s.message),s}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(s){throw this.logger.error(s.message),s}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(s){throw this.logger.error(s.message),s}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(s){throw this.logger.error(s.message),s}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(s){throw this.logger.error(s.message),s}},this.find=e=>{try{return this.engine.find(e)}catch(s){throw this.logger.error(s.message),s}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async e=>{try{return await this.engine.authenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(s){throw this.logger.error(s.message),s}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.name=n?.name||le.name,this.metadata=n?.metadata||Lt(),this.signConfig=n?.signConfig;const t=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:dt(ut({level:n?.logger||le.logger}));this.core=n?.core||new pt(n),this.logger=gt(t,this.name),this.session=new it(this.core,this.logger),this.proposal=new ns(this.core,this.logger),this.pendingRequest=new os(this.core,this.logger),this.engine=new rs(this),this.auth=new hs(this.core,this.logger)}static async init(n){const t=new pe(n);return await t.initialize(),t}get context(){return wt(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),await this.auth.init(),this.logger.info("SignClient Initialization Success"),this.engine.processRelayMessageCache()}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const ps=it,ds=pe;export{Be as AUTH_CONTEXT,We as AUTH_KEYS_CONTEXT,Ze as AUTH_PAIRING_TOPIC_CONTEXT,Je as AUTH_PROTOCOL,ie as AUTH_PUBLIC_KEY_NAME,et as AUTH_REQUEST_CONTEXT,se as AUTH_STORAGE_PREFIX,Wt as AUTH_VERSION,ze as ENGINE_CONTEXT,x as ENGINE_QUEUE_STATES,S as ENGINE_RPC_OPTS,Xt as HISTORY_CONTEXT,Yt as HISTORY_EVENTS,Jt as HISTORY_STORAGE_VERSION,Xe as METHODS_TO_VERIFY,Fe as PROPOSAL_CONTEXT,Bt as PROPOSAL_EXPIRY,Qe as PROPOSAL_EXPIRY_MESSAGE,Ye as REQUEST_CONTEXT,He as SESSION_CONTEXT,k as SESSION_EXPIRY,he as SESSION_REQUEST_EXPIRY_BOUNDARIES,Ne as SIGN_CLIENT_CONTEXT,le as SIGN_CLIENT_DEFAULT,Ht as SIGN_CLIENT_EVENTS,qe as SIGN_CLIENT_PROTOCOL,zt as SIGN_CLIENT_STORAGE_OPTIONS,ce as SIGN_CLIENT_STORAGE_PREFIX,ve as SIGN_CLIENT_VERSION,ps as SessionStore,ds as SignClient,Pe as WALLETCONNECT_DEEPLINK_CHOICE,pe as default};
//# sourceMappingURL=index.es.js.map
