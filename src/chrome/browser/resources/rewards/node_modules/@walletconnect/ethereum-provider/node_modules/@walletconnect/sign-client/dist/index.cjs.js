"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var h=require("@walletconnect/core"),H=require("@walletconnect/logger"),ae=require("@walletconnect/types"),i=require("@walletconnect/utils"),ce=require("events"),y=require("@walletconnect/time"),_=require("@walletconnect/jsonrpc-utils");function fe(S){return S&&typeof S=="object"&&"default"in S?S:{default:S}}var ve=fe(ce);const te="wc",se=2,ie="client",j=`${te}@${se}:${ie}:`,Y={name:ie,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},qe={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},Pe={database:":memory:"},re="WALLETCONNECT_DEEPLINK_CHOICE",Oe={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ce="history",Ae="0.3",le="proposal",Ve=y.THIRTY_DAYS,pe="Proposal expired",he="session",D=y.SEVEN_DAYS,de="engine",T={wc_sessionPropose:{req:{ttl:y.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:y.ONE_DAY,prompt:!1,tag:1104},res:{ttl:y.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:y.ONE_DAY,prompt:!1,tag:1106},res:{ttl:y.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:y.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:y.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:y.ONE_DAY,prompt:!1,tag:1112},res:{ttl:y.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:y.ONE_DAY,prompt:!1,tag:1114},res:{ttl:y.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:y.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:y.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:y.FIVE_MINUTES,prompt:!1,tag:1119}}},Q={min:y.FIVE_MINUTES,max:y.SEVEN_DAYS},C={idle:"IDLE",active:"ACTIVE"},ue="request",ge=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Ee="wc",De=1.5,_e="auth",ye="authKeys",we="pairingTopics",me="requests",$=`${Ee}@${1.5}:${_e}:`,K=`${$}:PUB_KEY`;var xe=Object.defineProperty,be=Object.defineProperties,Le=Object.getOwnPropertyDescriptors,Se=Object.getOwnPropertySymbols,Me=Object.prototype.hasOwnProperty,Ue=Object.prototype.propertyIsEnumerable,Ie=(S,o,t)=>o in S?xe(S,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):S[o]=t,R=(S,o)=>{for(var t in o||(o={}))Me.call(o,t)&&Ie(S,t,o[t]);if(Se)for(var t of Se(o))Ue.call(o,t)&&Ie(S,t,o[t]);return S},x=(S,o)=>be(S,Le(o));class $e extends ae.IEngine{constructor(o){super(o),this.name=de,this.events=new ve.default,this.initialized=!1,this.requestQueue={state:C.idle,queue:[]},this.sessionRequestQueue={state:C.idle,queue:[]},this.requestQueueDelay=y.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.relayMessageCache=[],this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(T)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},y.toMiliseconds(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=x(R({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=e;let l=s,d,p=!1;try{l&&(p=this.client.core.pairing.pairings.get(l).active)}catch(w){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),w}if(!l||!p){const{topic:w,uri:N}=await this.client.core.pairing.create();l=w,d=N}if(!l){const{message:w}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(w)}const E=await this.client.core.crypto.generateKeyPair(),u=T.wc_sessionPropose.req.ttl||y.FIVE_MINUTES,g=i.calcExpiry(u),I=R({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:h.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:E,metadata:this.client.metadata},expiryTimestamp:g,pairingTopic:l},a&&{sessionProperties:a}),{reject:v,resolve:m,done:P}=i.createDelayedPromise(u,pe);this.events.once(i.engineEvent("session_connect"),async({error:w,session:N})=>{if(w)v(w);else if(N){N.self.publicKey=E;const V=x(R({},N),{pairingTopic:I.pairingTopic,requiredNamespaces:I.requiredNamespaces,optionalNamespaces:I.optionalNamespaces});await this.client.session.set(N.topic,V),await this.setExpiry(N.topic,N.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:N.peer.metadata}),this.cleanupDuplicatePairings(V),m(V)}});const A=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:I,throwOnFailedPublish:!0});return await this.setProposal(A,R({id:A},I)),{uri:d,approval:P}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{var e,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:(e=t?.id)==null?void 0:e.toString(),trace:[h.EVENT_CLIENT_SESSION_TRACES.session_approve_started]}});try{await this.isInitialized()}catch(f){throw n.setError(h.EVENT_CLIENT_SESSION_ERRORS.no_internet_connection),f}try{await this.isValidProposalId(t?.id)}catch(f){throw this.client.logger.error(`approve() -> proposal.get(${t?.id}) failed`),n.setError(h.EVENT_CLIENT_SESSION_ERRORS.proposal_not_found),f}try{await this.isValidApprove(t)}catch(f){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure),f}const{id:a,relayProtocol:c,namespaces:l,sessionProperties:d,sessionConfig:p}=t,E=this.client.proposal.get(a);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:u,proposer:g,requiredNamespaces:I,optionalNamespaces:v}=E;let m=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:u});m||(m=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:h.EVENT_CLIENT_SESSION_TRACES.session_approve_started,properties:{topic:u,trace:[h.EVENT_CLIENT_SESSION_TRACES.session_approve_started,h.EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success]}}));const P=await this.client.core.crypto.generateKeyPair(),A=g.publicKey,w=await this.client.core.crypto.generateSharedKey(P,A),N=R(R({relay:{protocol:c??"irn"},namespaces:l,controller:{publicKey:P,metadata:this.client.metadata},expiry:i.calcExpiry(D)},d&&{sessionProperties:d}),p&&{sessionConfig:p});m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);try{await this.client.core.relayer.subscribe(w)}catch(f){throw m.setError(h.EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure),f}m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);const V=x(R({},N),{topic:w,requiredNamespaces:I,optionalNamespaces:v,pairingTopic:u,acknowledged:!1,self:N.controller,peer:{publicKey:g.publicKey,metadata:g.metadata},controller:P});await this.client.session.set(w,V),m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.store_session);try{m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.publishing_session_settle),await this.sendRequest({topic:w,method:"wc_sessionSettle",params:N,throwOnFailedPublish:!0}).catch(f=>{throw m?.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure),f}),m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success),m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.publishing_session_approve),await this.sendResult({id:a,topic:u,result:{relay:{protocol:c??"irn"},responderPublicKey:P},throwOnFailedPublish:!0}).catch(f=>{throw m?.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure),f}),m.addTrace(h.EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success)}catch(f){throw this.client.logger.error(f),this.client.session.delete(w,i.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(w),f}return this.client.core.eventClient.deleteEvent({eventId:m.eventId}),await this.client.core.pairing.updateMetadata({topic:u,metadata:g.metadata}),await this.client.proposal.delete(a,i.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:u}),await this.setExpiry(w,i.calcExpiry(D)),{topic:w,acknowledged:()=>Promise.resolve(this.client.session.get(w))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:e,reason:s}=t;let r;try{r=this.client.proposal.get(e).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),n}r&&(await this.sendError({id:e,topic:r,error:s,rpcOpts:T.wc_sessionPropose.reject}),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(p){throw this.client.logger.error("update() -> isValidUpdate() failed"),p}const{topic:e,namespaces:s}=t,{done:r,resolve:n,reject:a}=i.createDelayedPromise(),c=_.payloadId(),l=_.getBigIntRpcId().toString(),d=this.client.session.get(e).namespaces;return this.events.once(i.engineEvent("session_update",c),({error:p})=>{p?a(p):n()}),await this.client.session.update(e,{namespaces:s}),await this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(p=>{this.client.logger.error(p),this.client.session.update(e,{namespaces:d}),a(p)}),{acknowledged:r}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:e}=t,s=_.payloadId(),{done:r,resolve:n,reject:a}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",s),({error:c})=>{c?a(c):n()}),await this.setExpiry(e,i.calcExpiry(D)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(u){throw this.client.logger.error("request() -> isValidRequest() failed"),u}const{chainId:e,request:s,topic:r,expiry:n=T.wc_sessionRequest.req.ttl}=t,a=this.client.session.get(r),c=_.payloadId(),l=_.getBigIntRpcId().toString(),{done:d,resolve:p,reject:E}=i.createDelayedPromise(n,"Request expired. Please try again.");return this.events.once(i.engineEvent("session_request",c),({error:u,result:g})=>{u?E(u):p(g)}),await Promise.all([new Promise(async u=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:x(R({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:e},expiry:n,throwOnFailedPublish:!0}).catch(g=>E(g)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:e,id:c}),u()}),new Promise(async u=>{var g;if(!((g=a.sessionConfig)!=null&&g.disableDeepLink)){const I=await i.getDeepLink(this.client.core.storage,re);i.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:I})}u()}),d()]).then(u=>u[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:s}=t,{id:r}=s;_.isJsonRpcResult(s)?await this.sendResult({id:r,topic:e,result:s.result,throwOnFailedPublish:!0}):_.isJsonRpcError(s)&&await this.sendError({id:r,topic:e,error:s.error}),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:e}=t;if(this.client.session.keys.includes(e)){const s=_.payloadId(),r=_.getBigIntRpcId().toString(),{done:n,resolve:a,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",s),({error:l})=>{l?c(l):a()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:s,chainId:r}=t,n=_.getBigIntRpcId().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:i.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:s}=i.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(s)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>i.isSessionCompatible(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async t=>{this.isInitialized(),this.isValidAuthenticate(t);const{chains:e,statement:s="",uri:r,domain:n,nonce:a,type:c,exp:l,nbf:d,methods:p=[],expiry:E}=t,u=[...t.resources||[]],{topic:g,uri:I}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"]});this.client.logger.info({message:"Generated new pairing",pairing:{topic:g,uri:I}});const v=await this.client.core.crypto.generateKeyPair(),m=i.hashKey(v);if(await Promise.all([this.client.auth.authKeys.set(K,{responseTopic:m,publicKey:v}),this.client.auth.pairingTopics.set(m,{topic:m,pairingTopic:g})]),await this.client.core.relayer.subscribe(m),this.client.logger.info(`sending request to new pairing topic: ${g}`),p.length>0){const{namespace:O}=i.parseChainId(e[0]);let q=i.createEncodedRecap(O,"request",p);i.getRecapFromResources(u)&&(q=i.mergeEncodedRecaps(q,u.pop())),u.push(q)}const P=E&&E>T.wc_sessionAuthenticate.req.ttl?E:T.wc_sessionAuthenticate.req.ttl,A={authPayload:{type:c??"caip122",chains:e,statement:s,aud:r,domain:n,version:"1",nonce:a,iat:new Date().toISOString(),exp:l,nbf:d,resources:u},requester:{publicKey:v,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(P)},w={eip155:{chains:e,methods:[...new Set(["personal_sign",...p])],events:["chainChanged","accountsChanged"]}},N={requiredNamespaces:{},optionalNamespaces:w,relays:[{protocol:"irn"}],pairingTopic:g,proposer:{publicKey:v,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(T.wc_sessionPropose.req.ttl)},{done:V,resolve:f,reject:J}=i.createDelayedPromise(P,"Request expired"),G=async({error:O,session:q})=>{if(this.events.off(i.engineEvent("session_request",b),z),O)J(O);else if(q){q.self.publicKey=v,await this.client.session.set(q.topic,q),await this.setExpiry(q.topic,q.expiry),g&&await this.client.core.pairing.updateMetadata({topic:g,metadata:q.peer.metadata});const L=this.client.session.get(q.topic);await this.deleteProposal(M),f({session:L})}},z=async O=>{if(await this.deletePendingAuthRequest(b,{message:"fulfilled",code:0}),O.error){const U=i.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return O.error.code===U.code?void 0:(this.events.off(i.engineEvent("session_connect"),G),J(O.error.message))}await this.deleteProposal(M),this.events.off(i.engineEvent("session_connect"),G);const{cacaos:q,responder:L}=O.result,B=[],ne=[];for(const U of q){await i.validateSignedCacao({cacao:U,projectId:this.client.core.projectId})||(this.client.logger.error(U,"Signature verification failed"),J(i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:W}=U,Z=i.getRecapFromResources(W.resources),oe=[i.getNamespacedDidChainId(W.iss)],Ne=i.getDidAddress(W.iss);if(Z){const ee=i.getMethodsFromRecap(Z),Te=i.getChainsFromRecap(Z);B.push(...ee),oe.push(...Te)}for(const ee of oe)ne.push(`${ee}:${Ne}`)}const k=await this.client.core.crypto.generateSharedKey(v,L.publicKey);let F;B.length>0&&(F={topic:k,acknowledged:!0,self:{publicKey:v,metadata:this.client.metadata},peer:L,controller:L.publicKey,expiry:i.calcExpiry(D),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:g,namespaces:i.buildNamespacesFromAuth([...new Set(B)],[...new Set(ne)])},await this.client.core.relayer.subscribe(k),await this.client.session.set(k,F),g&&await this.client.core.pairing.updateMetadata({topic:g,metadata:L.metadata}),F=this.client.session.get(k)),f({auths:q,session:F})},b=_.payloadId(),M=_.payloadId();this.events.once(i.engineEvent("session_connect"),G),this.events.once(i.engineEvent("session_request",b),z);try{await Promise.all([this.sendRequest({topic:g,method:"wc_sessionAuthenticate",params:A,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:b}),this.sendRequest({topic:g,method:"wc_sessionPropose",params:N,expiry:T.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:M})])}catch(O){throw this.events.off(i.engineEvent("session_connect"),G),this.events.off(i.engineEvent("session_request",b),z),O}return await this.setProposal(M,R({id:M},N)),await this.setAuthRequest(b,{request:x(R({},A),{verifyContext:{}}),pairingTopic:g}),{uri:I,response:V}},this.approveSessionAuthenticate=async t=>{const{id:e,auths:s}=t,r=this.client.core.eventClient.createEvent({properties:{topic:e.toString(),trace:[h.EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started]}});try{this.isInitialized()}catch(I){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection),I}const n=this.getPendingAuthRequest(e);if(!n)throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${e}`);const a=n.requester.publicKey,c=await this.client.core.crypto.generateKeyPair(),l=i.hashKey(a),d={type:i.TYPE_1,receiverPublicKey:a,senderPublicKey:c},p=[],E=[];for(const I of s){if(!await i.validateSignedCacao({cacao:I,projectId:this.client.core.projectId})){r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);const w=i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:l,error:w,encodeOpts:d}),new Error(w.message)}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);const{p:v}=I,m=i.getRecapFromResources(v.resources),P=[i.getNamespacedDidChainId(v.iss)],A=i.getDidAddress(v.iss);if(m){const w=i.getMethodsFromRecap(m),N=i.getChainsFromRecap(m);p.push(...w),P.push(...N)}for(const w of P)E.push(`${w}:${A}`)}const u=await this.client.core.crypto.generateSharedKey(c,a);r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);let g;if(p?.length>0){g={topic:u,acknowledged:!0,self:{publicKey:c,metadata:this.client.metadata},peer:{publicKey:a,metadata:n.requester.metadata},controller:a,expiry:i.calcExpiry(D),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:i.buildNamespacesFromAuth([...new Set(p)],[...new Set(E)])},r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(u)}catch(I){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure),I}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success),await this.client.session.set(u,g),r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);try{await this.sendResult({topic:l,id:e,result:{cacaos:s,responder:{publicKey:c,metadata:this.client.metadata}},encodeOpts:d,throwOnFailedPublish:!0})}catch(I){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure),I}return await this.client.auth.requests.delete(e,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:g}},this.rejectSessionAuthenticate=async t=>{await this.isInitialized();const{id:e,reason:s}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=i.hashKey(n),l={type:i.TYPE_1,receiverPublicKey:n,senderPublicKey:a};await this.sendError({id:e,topic:c,error:s,encodeOpts:l,rpcOpts:T.wc_sessionAuthenticate.reject}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED"))},this.formatAuthMessage=t=>{this.isInitialized();const{request:e,iss:s}=t;return i.formatMessage(e,s)},this.processRelayMessageCache=()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const t=this.relayMessageCache.shift();t&&await this.onRelayMessage(t)}catch(t){this.client.logger.error(t)}},50)},this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,a;return((n=r.peerMetadata)==null?void 0:n.url)&&((a=r.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&r.topic&&r.topic!==e.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{var e;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:a=0}=t,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,i.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(re).catch(l=>this.client.logger.warn(l)),this.getPendingSessionRequests().forEach(l=>{l.topic===s&&this.deletePendingSessionRequest(l.id,i.getSdkError("USER_DISCONNECTED"))}),s===((e=this.sessionRequestQueue.queue[0])==null?void 0:e.topic)&&(this.sessionRequestQueue.state=C.idle),n&&this.client.events.emit("session_delete",{id:a,topic:s})},this.deleteProposal=async(t,e)=>{if(e)try{const s=this.client.proposal.get(t),r=this.client.core.eventClient.getEvent({topic:s.pairingTopic});r?.setError(h.EVENT_CLIENT_SESSION_ERRORS.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),s&&(this.sessionRequestQueue.state=C.idle,this.client.events.emit("session_request_expire",{id:t}))},this.deletePendingAuthRequest=async(t,e,s=!1)=>{await Promise.all([this.client.auth.requests.delete(t,e),s?Promise.resolve():this.client.core.expirer.del(t)])},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,e),await this.client.session.update(t,{expiry:e}))},this.setProposal=async(t,e)=>{this.client.core.expirer.set(t,i.calcExpiry(T.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,e)},this.setAuthRequest=async(t,e)=>{const{request:s,pairingTopic:r}=e;this.client.core.expirer.set(t,s.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:t,pairingTopic:r,verifyContext:s.verifyContext})},this.setPendingSessionRequest=async t=>{const{id:e,topic:s,params:r,verifyContext:n}=t,a=r.request.expiryTimestamp||i.calcExpiry(T.wc_sessionRequest.req.ttl);this.client.core.expirer.set(e,a),await this.client.pendingRequest.set(e,{id:e,topic:s,params:r,verifyContext:n})},this.sendRequest=async t=>{const{topic:e,method:s,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l}=t,d=_.formatJsonRpcRequest(s,r,c);let p;try{p=await this.client.core.crypto.encode(e,d)}catch(g){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),g}let E;if(ge.includes(s)){const g=i.hashMessage(JSON.stringify(d)),I=i.hashMessage(p);E=await this.client.core.verify.register({id:I,decryptedId:g})}const u=T[s].req;return u.attestation=E,n&&(u.ttl=n),a&&(u.id=a),this.client.core.history.set(e,d),l?(u.internal=x(R({},u.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,p,u)):this.client.core.relayer.publish(e,p,u).catch(g=>this.client.logger.error(g)),d.id},this.sendResult=async t=>{const{id:e,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:a}=t,c=_.formatJsonRpcResult(e,r);let l;try{l=await this.client.core.crypto.encode(s,c,a)}catch(E){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),E}let d;try{d=await this.client.core.history.get(s,e)}catch(E){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${e}) failed`),E}const p=T[d.request.method].res;n?(p.internal=x(R({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,l,p)):this.client.core.relayer.publish(s,l,p).catch(E=>this.client.logger.error(E)),await this.client.core.history.resolve(c)},this.sendError=async t=>{const{id:e,topic:s,error:r,encodeOpts:n,rpcOpts:a}=t,c=_.formatJsonRpcError(e,r);let l;try{l=await this.client.core.crypto.encode(s,c,n)}catch(E){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),E}let d;try{d=await this.client.core.history.get(s,e)}catch(E){throw this.client.logger.error(`sendError() -> history.get(${s}, ${e}) failed`),E}const p=a||T[d.request.method].res;this.client.core.relayer.publish(s,l,p),await this.client.core.history.resolve(c)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(s=>{let r=!1;i.isExpired(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&t.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{i.isExpired(s.expiryTimestamp)&&e.push(s.id)}),await Promise.all([...t.map(s=>this.deleteSession({topic:s})),...e.map(s=>this.deleteProposal(s))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===C.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=C.active;const t=this.requestQueue.queue.shift();if(t)try{await this.processRequest(t)}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=C.idle},this.processRequest=async t=>{const{topic:e,payload:s,attestation:r,encryptedId:n}=t,a=s.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:a}))switch(a){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:e,payload:s,attestation:r,encryptedId:n});case"wc_sessionSettle":return await this.onSessionSettleRequest(e,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(e,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(e,s);case"wc_sessionPing":return await this.onSessionPingRequest(e,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(e,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:e,payload:s,attestation:r,encryptedId:n});case"wc_sessionEvent":return await this.onSessionEventRequest(e,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:e,payload:s,attestation:r,encryptedId:n});default:return this.client.logger.info(`Unsupported request method ${a}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:s}=t,r=(await this.client.core.history.get(e,s.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(e,s);case"wc_sessionSettle":return this.onSessionSettleResponse(e,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,s);case"wc_sessionExtend":return this.onSessionExtendResponse(e,s);case"wc_sessionPing":return this.onSessionPingResponse(e,s);case"wc_sessionRequest":return this.onSessionRequestResponse(e,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,s);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:s}=i.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)},this.shouldIgnorePairingRequest=t=>{const{topic:e,requestMethod:s}=t,r=this.expectedPairingMethodMap.get(e);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async t=>{const{topic:e,payload:s,attestation:r,encryptedId:n}=t,{params:a,id:c}=s;try{const l=this.client.core.eventClient.getEvent({topic:e});this.isValidConnect(R({},s.params));const d=a.expiryTimestamp||i.calcExpiry(T.wc_sessionPropose.req.ttl),p=R({id:c,pairingTopic:e,expiryTimestamp:d},a);await this.setProposal(c,p);const E=await this.getVerifyContext({attestationId:r,hash:i.hashMessage(JSON.stringify(s)),encryptedId:n,metadata:p.proposer.metadata});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),l?.setError(h.EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found)),l?.addTrace(h.EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:p,verifyContext:E})}catch(l){await this.sendError({id:c,topic:e,error:l,rpcOpts:T.wc_sessionPropose.autoReject}),this.client.logger.error(l)}},this.onSessionProposeResponse=async(t,e)=>{const{id:s}=e;if(_.isJsonRpcResult(e)){const{result:r}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(s);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const c=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const l=await this.client.core.crypto.generateSharedKey(a,c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const d=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:d}),await this.client.core.pairing.activate({topic:t})}else if(_.isJsonRpcError(e)){await this.client.proposal.delete(s,i.getSdkError("USER_DISCONNECTED"));const r=i.engineEvent("session_connect");if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(i.engineEvent("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:s,params:r}=e;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:c,namespaces:l,sessionProperties:d,sessionConfig:p}=e.params,E=R(R({topic:t,relay:n,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},d&&{sessionProperties:d}),p&&{sessionConfig:p}),u=i.engineEvent("session_connect");if(this.events.listenerCount(u)===0)throw new Error(`emitting ${u} without any listeners 997`);this.events.emit(i.engineEvent("session_connect"),{session:E}),await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0})}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionSettleResponse=async(t,e)=>{const{id:s}=e;_.isJsonRpcResult(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",s),{})):_.isJsonRpcError(e)&&(await this.client.session.delete(t,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",s),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:s,id:r}=e;try{const n=`${t}_session_update`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.info(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:i.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(R({topic:t},s));try{i.MemoryStore.set(n,r),await this.client.session.update(t,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw i.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:s})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);_.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_update",s),{}):_.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_update",s),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:s}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,i.calcExpiry(D)),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionExtendResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);_.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_extend",s),{}):_.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_extend",s),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:s}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:t})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionPingResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_ping",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{_.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_ping",s),{}):_.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_ping",s),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:s}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(r=>{this.client.core.relayer.once(h.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:t,id:s}))})}),this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:i.getSdkError("USER_DISCONNECTED")})])}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async t=>{var e;const{topic:s,payload:r,attestation:n,encryptedId:a}=t,{id:c,params:l}=r;try{await this.isValidRequest(R({topic:s},l));const d=this.client.session.get(s),p=await this.getVerifyContext({attestationId:n,hash:i.hashMessage(JSON.stringify(_.formatJsonRpcRequest("wc_sessionRequest",l,c))),encryptedId:a,metadata:d.peer.metadata}),E={id:c,topic:s,params:l,verifyContext:p};await this.setPendingSessionRequest(E),(e=this.client.signConfig)!=null&&e.disableRequestQueue?this.emitSessionRequest(E):(this.addSessionRequestToSessionRequestQueue(E),this.processSessionRequestQueue())}catch(d){await this.sendError({id:c,topic:s,error:d}),this.client.logger.error(d)}},this.onSessionRequestResponse=(t,e)=>{const{id:s}=e,r=i.engineEvent("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);_.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):_.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:s,params:r}=e;try{const n=`${t}_session_event_${r.event.name}`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(R({topic:t},r)),this.client.events.emit("session_event",{id:s,topic:t,params:r}),i.MemoryStore.set(n,s)}catch(n){await this.sendError({id:s,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionAuthenticateResponse=(t,e)=>{const{id:s}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),_.isJsonRpcResult(e)?this.events.emit(i.engineEvent("session_request",s),{result:e.result}):_.isJsonRpcError(e)&&this.events.emit(i.engineEvent("session_request",s),{error:e.error})},this.onSessionAuthenticateRequest=async t=>{const{topic:e,payload:s,attestation:r,encryptedId:n}=t;try{const{requester:a,authPayload:c,expiryTimestamp:l}=s.params,d=await this.getVerifyContext({attestationId:r,hash:i.hashMessage(JSON.stringify(s)),encryptedId:n,metadata:this.client.metadata}),p={requester:a,pairingTopic:e,id:s.id,authPayload:c,verifyContext:d,expiryTimestamp:l};await this.setAuthRequest(s.id,{request:p,pairingTopic:e}),this.client.events.emit("session_authenticate",{topic:e,params:s.params,id:s.id,verifyContext:d})}catch(a){this.client.logger.error(a);const c=s.params.requester.publicKey,l=await this.client.core.crypto.generateKeyPair(),d={type:i.TYPE_1,receiverPublicKey:c,senderPublicKey:l};await this.sendError({id:s.id,topic:e,error:a,encodeOpts:d,rpcOpts:T.wc_sessionAuthenticate.autoReject})}},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=C.idle,this.processSessionRequestQueue()},y.toMiliseconds(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,a=i.engineEvent("session_request",n);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(i.engineEvent("session_request",r.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===C.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=C.active,this.emitSessionRequest(t)}catch(e){this.client.logger.error(e)}},this.emitSessionRequest=t=>{this.client.events.emit("session_request",t)},this.onPairingCreated=t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(s=>s.pairingTopic===t.topic);e&&this.onSessionProposeRequest({topic:t.topic,payload:_.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id)})},this.isValidConnect=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(c)}const{pairingTopic:e,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,relays:a}=t;if(i.isUndefined(e)||await this.isValidPairingTopic(e),!i.isValidRelays(a,!0)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}!i.isUndefined(s)&&i.isValidObject(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(t,e)=>{const s=i.isValidRequiredNamespaces(t,"connect()",e);if(s)throw new Error(s.message)},this.isValidApprove=async t=>{if(!i.isValidParams(t))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:s,relayProtocol:r,sessionProperties:n}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const a=this.client.proposal.get(e),c=i.isValidNamespaces(s,"approve()");if(c)throw new Error(c.message);const l=i.isConformingNamespaces(a.requiredNamespaces,s,"approve()");if(l)throw new Error(l.message);if(!i.isValidString(r,!0)){const{message:d}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(d)}i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async t=>{if(!i.isValidParams(t)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:e,reason:s}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!i.isValidErrorReason(s)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidSessionSettleRequest=t=>{if(!i.isValidParams(t)){const{message:l}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(l)}const{relay:e,controller:s,namespaces:r,expiry:n}=t;if(!i.isValidRelay(e)){const{message:l}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=i.isValidController(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=i.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(i.isExpired(n)){const{message:l}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:e,namespaces:s}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const r=this.client.session.get(e),n=i.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const a=i.isConformingNamespaces(r.requiredNamespaces,s,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(s)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!i.isValidParams(t)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:e,request:s,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:a}=this.client.session.get(e);if(!i.isValidNamespacesChainId(a,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!i.isValidRequest(s)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!i.isValidNamespacesRequest(a,r,s.method)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!i.isValidRequestExpiry(n,Q)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${Q.min} and ${Q.max}`);throw new Error(c)}},this.isValidRespond=async t=>{var e;if(!i.isValidParams(t)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:s,response:r}=t;try{await this.isValidSessionTopic(s)}catch(n){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),n}if(!i.isValidResponse(r)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}},this.isValidPing=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!i.isValidParams(t)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:e,event:s,chainId:r}=t;await this.isValidSessionTopic(e);const{namespaces:n}=this.client.session.get(e);if(!i.isValidNamespacesChainId(n,r)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!i.isValidEvent(s)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}if(!i.isValidNamespacesEvent(n,r,s.name)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}},this.isValidDisconnect=async t=>{if(!i.isValidParams(t)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(s)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidAuthenticate=t=>{const{chains:e,uri:s,domain:r,nonce:n}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!i.isValidString(s,!1))throw new Error("uri is required parameter");if(!i.isValidString(r,!1))throw new Error("domain is required parameter");if(!i.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(c=>i.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=i.parseChainId(e[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async t=>{const{attestationId:e,hash:s,encryptedId:r,metadata:n}=t,a={verified:{verifyUrl:n.verifyUrl||h.VERIFY_SERVER,validation:"UNKNOWN",origin:n.url||""}};try{const c=await this.client.core.verify.resolve({attestationId:e,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});c&&(a.verified.origin=c.origin,a.verified.isScam=c.isScam,a.verified.validation=c.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(c){this.client.logger.warn(c)}return this.client.logger.debug(`Verify context: ${JSON.stringify(a)}`),a},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(s=>{if(!i.isValidString(s,!1)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(r)}})},this.getPendingAuthRequest=t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(s)}}}async isInitialized(){if(!this.initialized){const{message:o}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(o)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(h.RELAYER_EVENTS.message,o=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(o):this.onRelayMessage(o)})}async onRelayMessage(o){const{topic:t,message:e,attestation:s}=o,{publicKey:r}=this.client.auth.authKeys.keys.includes(K)?this.client.auth.authKeys.get(K):{responseTopic:void 0,publicKey:void 0},n=await this.client.core.crypto.decode(t,e,{receiverPublicKey:r});try{_.isJsonRpcRequest(n)?(this.client.core.history.set(t,n),this.onRelayEventRequest({topic:t,payload:n,attestation:s,encryptedId:i.hashMessage(e)})):_.isJsonRpcResponse(n)?(await this.client.core.history.resolve(n),await this.onRelayEventResponse({topic:t,payload:n}),this.client.core.history.delete(t,n.id)):this.onRelayEventUnknownPayload({topic:t,payload:n})}catch(a){this.client.logger.error(a)}}registerExpirerEvents(){this.client.core.expirer.on(h.EXPIRER_EVENTS.expired,async o=>{const{topic:t,id:e}=i.parseExpirerTarget(o.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,i.getInternalError("EXPIRED"),!0);if(e&&this.client.auth.requests.keys.includes(e))return await this.deletePendingAuthRequest(e,i.getInternalError("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(h.PAIRING_EVENTS.create,o=>this.onPairingCreated(o)),this.client.core.pairing.events.on(h.PAIRING_EVENTS.delete,o=>{this.addToRecentlyDeleted(o.topic,"pairing")})}isValidPairingTopic(o){if(!i.isValidString(o,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${o}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.core.pairing.pairings.get(o).expiry)){const{message:t}=i.getInternalError("EXPIRED",`pairing topic: ${o}`);throw new Error(t)}}async isValidSessionTopic(o){if(!i.isValidString(o,!1)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${o}`);throw new Error(t)}if(this.checkRecentlyDeleted(o),!this.client.session.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.session.get(o).expiry)){await this.deleteSession({topic:o});const{message:t}=i.getInternalError("EXPIRED",`session topic: ${o}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(o)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${o}`);throw await this.deleteSession({topic:o}),new Error(t)}}async isValidSessionOrPairingTopic(o){if(this.checkRecentlyDeleted(o),this.client.session.keys.includes(o))await this.isValidSessionTopic(o);else if(this.client.core.pairing.pairings.keys.includes(o))this.isValidPairingTopic(o);else if(i.isValidString(o,!1)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${o}`);throw new Error(t)}else{const{message:t}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${o}`);throw new Error(t)}}async isValidProposalId(o){if(!i.isValidId(o)){const{message:t}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${o}`);throw new Error(t)}if(!this.client.proposal.keys.includes(o)){const{message:t}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${o}`);throw new Error(t)}if(i.isExpired(this.client.proposal.get(o).expiryTimestamp)){await this.deleteProposal(o);const{message:t}=i.getInternalError("EXPIRED",`proposal id: ${o}`);throw new Error(t)}}}class Ke extends h.Store{constructor(o,t){super(o,t,le,j),this.core=o,this.logger=t}}class Re extends h.Store{constructor(o,t){super(o,t,he,j),this.core=o,this.logger=t}}class Ge extends h.Store{constructor(o,t){super(o,t,ue,j,e=>e.id),this.core=o,this.logger=t}}class ke extends h.Store{constructor(o,t){super(o,t,ye,$,()=>K),this.core=o,this.logger=t}}class Fe extends h.Store{constructor(o,t){super(o,t,we,$),this.core=o,this.logger=t}}class He extends h.Store{constructor(o,t){super(o,t,me,$,e=>e.id),this.core=o,this.logger=t}}class je{constructor(o,t){this.core=o,this.logger=t,this.authKeys=new ke(this.core,this.logger),this.pairingTopics=new Fe(this.core,this.logger),this.requests=new He(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class X extends ae.ISignClient{constructor(o){super(o),this.protocol=te,this.version=se,this.name=Y.name,this.events=new ce.EventEmitter,this.on=(e,s)=>this.events.on(e,s),this.once=(e,s)=>this.events.once(e,s),this.off=(e,s)=>this.events.off(e,s),this.removeListener=(e,s)=>this.events.removeListener(e,s),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(s){throw this.logger.error(s.message),s}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(s){throw this.logger.error(s.message),s}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(s){throw this.logger.error(s.message),s}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(s){throw this.logger.error(s.message),s}},this.update=async e=>{try{return await this.engine.update(e)}catch(s){throw this.logger.error(s.message),s}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(s){throw this.logger.error(s.message),s}},this.request=async e=>{try{return await this.engine.request(e)}catch(s){throw this.logger.error(s.message),s}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(s){throw this.logger.error(s.message),s}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(s){throw this.logger.error(s.message),s}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(s){throw this.logger.error(s.message),s}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(s){throw this.logger.error(s.message),s}},this.find=e=>{try{return this.engine.find(e)}catch(s){throw this.logger.error(s.message),s}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async e=>{try{return await this.engine.authenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(s){throw this.logger.error(s.message),s}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(s){throw this.logger.error(s.message),s}},this.name=o?.name||Y.name,this.metadata=o?.metadata||i.getAppMetadata(),this.signConfig=o?.signConfig;const t=typeof o?.logger<"u"&&typeof o?.logger!="string"?o.logger:H.pino(H.getDefaultLoggerOptions({level:o?.logger||Y.logger}));this.core=o?.core||new h.Core(o),this.logger=H.generateChildLogger(t,this.name),this.session=new Re(this.core,this.logger),this.proposal=new Ke(this.core,this.logger),this.pendingRequest=new Ge(this.core,this.logger),this.engine=new $e(this),this.auth=new je(this.core,this.logger)}static async init(o){const t=new X(o);return await t.initialize(),t}get context(){return H.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),await this.auth.init(),this.logger.info("SignClient Initialization Success"),this.engine.processRelayMessageCache()}catch(o){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(o.message),o}}}const Ye=Re,Qe=X;exports.AUTH_CONTEXT=_e,exports.AUTH_KEYS_CONTEXT=ye,exports.AUTH_PAIRING_TOPIC_CONTEXT=we,exports.AUTH_PROTOCOL=Ee,exports.AUTH_PUBLIC_KEY_NAME=K,exports.AUTH_REQUEST_CONTEXT=me,exports.AUTH_STORAGE_PREFIX=$,exports.AUTH_VERSION=De,exports.ENGINE_CONTEXT=de,exports.ENGINE_QUEUE_STATES=C,exports.ENGINE_RPC_OPTS=T,exports.HISTORY_CONTEXT=Ce,exports.HISTORY_EVENTS=Oe,exports.HISTORY_STORAGE_VERSION=Ae,exports.METHODS_TO_VERIFY=ge,exports.PROPOSAL_CONTEXT=le,exports.PROPOSAL_EXPIRY=Ve,exports.PROPOSAL_EXPIRY_MESSAGE=pe,exports.REQUEST_CONTEXT=ue,exports.SESSION_CONTEXT=he,exports.SESSION_EXPIRY=D,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=Q,exports.SIGN_CLIENT_CONTEXT=ie,exports.SIGN_CLIENT_DEFAULT=Y,exports.SIGN_CLIENT_EVENTS=qe,exports.SIGN_CLIENT_PROTOCOL=te,exports.SIGN_CLIENT_STORAGE_OPTIONS=Pe,exports.SIGN_CLIENT_STORAGE_PREFIX=j,exports.SIGN_CLIENT_VERSION=se,exports.SessionStore=Ye,exports.SignClient=Qe,exports.WALLETCONNECT_DEEPLINK_CHOICE=re,exports.default=X;
//# sourceMappingURL=index.cjs.js.map
