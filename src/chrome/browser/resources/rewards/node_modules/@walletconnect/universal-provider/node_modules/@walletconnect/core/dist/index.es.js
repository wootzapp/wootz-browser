import gi,{EventEmitter as M}from"events";import pi from"@walletconnect/keyvaluestorage";import{HEARTBEAT_EVENTS as q,HeartBeat as yi}from"@walletconnect/heartbeat";import{generateChildLogger as v,getLoggerContext as C,pino as Di,getDefaultLoggerOptions as Te,generatePlatformLogger as bi}from"@walletconnect/logger";import{IMessageTracker as mi,IPublisher as fi,ISubscriber as _i,IRelayer as Ei,IStore as vi,IJsonRpcHistory as wi,IExpirer as Ii,IVerify as Ti,IEchoClient as Ci,IEventClient as Si,ICore as Pi}from"@walletconnect/types";import{safeJsonStringify as Ri,safeJsonParse as xi}from"@walletconnect/safe-json";import*as ee from"@walletconnect/relay-auth";import{decodeJWT as Ce}from"@walletconnect/relay-auth";import{getInternalError as u,mapToObj as Se,objToMap as Pe,generateRandomBytes32 as ae,generateKeyPair as Oi,deriveSymKey as Ai,hashKey as Ni,validateEncoding as zi,isTypeOneEnvelope as Re,encrypt as Li,validateDecoding as $i,decrypt as Fi,deserialize as xe,decodeTypeByte as Ui,BASE16 as Ki,hashMessage as he,getRelayProtocolName as ce,createExpiringPromise as k,getRelayProtocolApi as G,isUndefined as le,getSdkError as H,isValidArray as Mi,isNode as ue,getBundleId as ki,isOnline as Oe,formatRelayRpcUrl as Bi,subscribeToNetworkChange as Vi,isProposalStruct as ji,isSessionStruct as qi,TYPE_1 as Gi,calcExpiry as te,formatUri as Hi,parseUri as Ae,createDelayedPromise as Yi,engineEvent as de,isExpired as Ne,isValidParams as ge,isValidUrl as Ji,isValidString as Wi,parseExpirerTarget as Xi,formatTopicTarget as Zi,formatIdTarget as Qi,isBrowser as es,verifyP256Jwt as ts,uuidv4 as is}from"@walletconnect/utils";import{toString as ss}from"uint8arrays";import{ONE_DAY as B,SIX_HOURS as rs,THIRTY_DAYS as ie,FIVE_SECONDS as ze,THIRTY_SECONDS as pe,toMiliseconds as S,ONE_MINUTE as ye,ONE_SECOND as se,Watch as ns,FIVE_MINUTES as Le,fromMiliseconds as $e}from"@walletconnect/time";import{JsonRpcProvider as os}from"@walletconnect/jsonrpc-provider";import{getBigIntRpcId as Fe,isJsonRpcRequest as Ue,isJsonRpcResponse as Ke,formatJsonRpcResult as Me,formatJsonRpcRequest as ke,formatJsonRpcError as as,isJsonRpcResult as hs,isJsonRpcError as Be}from"@walletconnect/jsonrpc-utils";import cs from"@walletconnect/jsonrpc-ws-connection";import ls from"lodash.isequal";function us(o,e){if(o.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var i=0;i<o.length;i++){var r=o.charAt(i),n=r.charCodeAt(0);if(t[n]!==255)throw new TypeError(r+" is ambiguous");t[n]=i}var a=o.length,h=o.charAt(0),c=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function g(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var p=0,_=0,D=0,E=l.length;D!==E&&l[D]===0;)D++,p++;for(var N=(E-D)*d+1>>>0,T=new Uint8Array(N);D!==E;){for(var z=l[D],U=0,x=N-1;(z!==0||U<_)&&x!==-1;x--,U++)z+=256*T[x]>>>0,T[x]=z%a>>>0,z=z/a>>>0;if(z!==0)throw new Error("Non-zero carry");_=U,D++}for(var $=N-_;$!==N&&T[$]===0;)$++;for(var Q=h.repeat(p);$<N;++$)Q+=o.charAt(T[$]);return Q}function b(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;var p=0;if(l[p]!==" "){for(var _=0,D=0;l[p]===h;)_++,p++;for(var E=(l.length-p)*c+1>>>0,N=new Uint8Array(E);l[p];){var T=t[l.charCodeAt(p)];if(T===255)return;for(var z=0,U=E-1;(T!==0||z<D)&&U!==-1;U--,z++)T+=a*N[U]>>>0,N[U]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");D=z,p++}if(l[p]!==" "){for(var x=E-D;x!==E&&N[x]===0;)x++;for(var $=new Uint8Array(_+(E-x)),Q=_;x!==E;)$[Q++]=N[x++];return $}}}function m(l){var p=b(l);if(p)return p;throw new Error(`Non-${e} character`)}return{encode:g,decodeUnsafe:b,decode:m}}var ds=us,gs=ds;const Ve=o=>{if(o instanceof Uint8Array&&o.constructor.name==="Uint8Array")return o;if(o instanceof ArrayBuffer)return new Uint8Array(o);if(ArrayBuffer.isView(o))return new Uint8Array(o.buffer,o.byteOffset,o.byteLength);throw new Error("Unknown type, must be binary type")},ps=o=>new TextEncoder().encode(o),ys=o=>new TextDecoder().decode(o);class Ds{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class bs{constructor(e,t,s){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=s}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return je(this,e)}}class ms{constructor(e){this.decoders=e}or(e){return je(this,e)}decode(e){const t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const je=(o,e)=>new ms({...o.decoders||{[o.prefix]:o},...e.decoders||{[e.prefix]:e}});class fs{constructor(e,t,s,i){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=i,this.encoder=new Ds(e,t,s),this.decoder=new bs(e,t,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const re=({name:o,prefix:e,encode:t,decode:s})=>new fs(o,e,t,s),Y=({prefix:o,name:e,alphabet:t})=>{const{encode:s,decode:i}=gs(t,e);return re({prefix:o,name:e,encode:s,decode:r=>Ve(i(r))})},_s=(o,e,t,s)=>{const i={};for(let d=0;d<e.length;++d)i[e[d]]=d;let r=o.length;for(;o[r-1]==="=";)--r;const n=new Uint8Array(r*t/8|0);let a=0,h=0,c=0;for(let d=0;d<r;++d){const g=i[o[d]];if(g===void 0)throw new SyntaxError(`Non-${s} character`);h=h<<t|g,a+=t,a>=8&&(a-=8,n[c++]=255&h>>a)}if(a>=t||255&h<<8-a)throw new SyntaxError("Unexpected end of data");return n},Es=(o,e,t)=>{const s=e[e.length-1]==="=",i=(1<<t)-1;let r="",n=0,a=0;for(let h=0;h<o.length;++h)for(a=a<<8|o[h],n+=8;n>t;)n-=t,r+=e[i&a>>n];if(n&&(r+=e[i&a<<t-n]),s)for(;r.length*t&7;)r+="=";return r},f=({name:o,prefix:e,bitsPerChar:t,alphabet:s})=>re({prefix:e,name:o,encode(i){return Es(i,s,t)},decode(i){return _s(i,s,t,o)}}),vs=re({prefix:"\0",name:"identity",encode:o=>ys(o),decode:o=>ps(o)});var ws=Object.freeze({__proto__:null,identity:vs});const Is=f({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Ts=Object.freeze({__proto__:null,base2:Is});const Cs=f({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Ss=Object.freeze({__proto__:null,base8:Cs});const Ps=Y({prefix:"9",name:"base10",alphabet:"0123456789"});var Rs=Object.freeze({__proto__:null,base10:Ps});const xs=f({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Os=f({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var As=Object.freeze({__proto__:null,base16:xs,base16upper:Os});const Ns=f({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),zs=f({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ls=f({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),$s=f({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Fs=f({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Us=f({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ks=f({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Ms=f({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ks=f({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Bs=Object.freeze({__proto__:null,base32:Ns,base32upper:zs,base32pad:Ls,base32padupper:$s,base32hex:Fs,base32hexupper:Us,base32hexpad:Ks,base32hexpadupper:Ms,base32z:ks});const Vs=Y({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),js=Y({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var qs=Object.freeze({__proto__:null,base36:Vs,base36upper:js});const Gs=Y({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Hs=Y({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Ys=Object.freeze({__proto__:null,base58btc:Gs,base58flickr:Hs});const Js=f({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ws=f({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Xs=f({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Zs=f({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Qs=Object.freeze({__proto__:null,base64:Js,base64pad:Ws,base64url:Xs,base64urlpad:Zs});const qe=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),er=qe.reduce((o,e,t)=>(o[t]=e,o),[]),tr=qe.reduce((o,e,t)=>(o[e.codePointAt(0)]=t,o),[]);function ir(o){return o.reduce((e,t)=>(e+=er[t],e),"")}function sr(o){const e=[];for(const t of o){const s=tr[t.codePointAt(0)];if(s===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(s)}return new Uint8Array(e)}const rr=re({prefix:"\u{1F680}",name:"base256emoji",encode:ir,decode:sr});var nr=Object.freeze({__proto__:null,base256emoji:rr}),or=He,Ge=128,ar=127,hr=~ar,cr=Math.pow(2,31);function He(o,e,t){e=e||[],t=t||0;for(var s=t;o>=cr;)e[t++]=o&255|Ge,o/=128;for(;o&hr;)e[t++]=o&255|Ge,o>>>=7;return e[t]=o|0,He.bytes=t-s+1,e}var lr=De,ur=128,Ye=127;function De(o,s){var t=0,s=s||0,i=0,r=s,n,a=o.length;do{if(r>=a)throw De.bytes=0,new RangeError("Could not decode varint");n=o[r++],t+=i<28?(n&Ye)<<i:(n&Ye)*Math.pow(2,i),i+=7}while(n>=ur);return De.bytes=r-s,t}var dr=Math.pow(2,7),gr=Math.pow(2,14),pr=Math.pow(2,21),yr=Math.pow(2,28),Dr=Math.pow(2,35),br=Math.pow(2,42),mr=Math.pow(2,49),fr=Math.pow(2,56),_r=Math.pow(2,63),Er=function(o){return o<dr?1:o<gr?2:o<pr?3:o<yr?4:o<Dr?5:o<br?6:o<mr?7:o<fr?8:o<_r?9:10},vr={encode:or,decode:lr,encodingLength:Er},Je=vr;const We=(o,e,t=0)=>(Je.encode(o,e,t),e),Xe=o=>Je.encodingLength(o),be=(o,e)=>{const t=e.byteLength,s=Xe(o),i=s+Xe(t),r=new Uint8Array(i+t);return We(o,r,0),We(t,r,s),r.set(e,i),new wr(o,t,e,r)};class wr{constructor(e,t,s,i){this.code=e,this.size=t,this.digest=s,this.bytes=i}}const Ze=({name:o,code:e,encode:t})=>new Ir(o,e,t);class Ir{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?be(this.code,t):t.then(s=>be(this.code,s))}else throw Error("Unknown type, must be binary type")}}const Qe=o=>async e=>new Uint8Array(await crypto.subtle.digest(o,e)),Tr=Ze({name:"sha2-256",code:18,encode:Qe("SHA-256")}),Cr=Ze({name:"sha2-512",code:19,encode:Qe("SHA-512")});var Sr=Object.freeze({__proto__:null,sha256:Tr,sha512:Cr});const et=0,Pr="identity",tt=Ve,Rr=o=>be(et,tt(o)),xr={code:et,name:Pr,encode:tt,digest:Rr};var Or=Object.freeze({__proto__:null,identity:xr});new TextEncoder,new TextDecoder;const it={...ws,...Ts,...Ss,...Rs,...As,...Bs,...qs,...Ys,...Qs,...nr};({...Sr,...Or});function Ar(o=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(o):new Uint8Array(o)}function st(o,e,t,s){return{name:o,prefix:e,encoder:{name:o,prefix:e,encode:t},decoder:{decode:s}}}const rt=st("utf8","u",o=>"u"+new TextDecoder("utf8").decode(o),o=>new TextEncoder().encode(o.substring(1))),me=st("ascii","a",o=>{let e="a";for(let t=0;t<o.length;t++)e+=String.fromCharCode(o[t]);return e},o=>{o=o.substring(1);const e=Ar(o.length);for(let t=0;t<o.length;t++)e[t]=o.charCodeAt(t);return e}),Nr={utf8:rt,"utf-8":rt,hex:it.base16,latin1:me,ascii:me,binary:me,...it};function zr(o,e="utf8"){const t=Nr[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(o,"utf8"):t.decoder.decode(`${t.prefix}${o}`)}const fe="wc",_e=2,ne="core",O=`${fe}@2:${ne}:`,nt={name:ne,logger:"error"},ot={database:":memory:"},at="crypto",Ee="client_ed25519_seed",ht=B,ct="keychain",lt="0.3",ut="messages",dt="0.3",gt=rs,pt="publisher",yt="irn",Dt="error",ve="wss://relay.walletconnect.org",bt="relayer",w={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},mt="_subscription",I={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},ft=.1,Lr={database:":memory:"},we="2.15.2",_t=1e4,Et="0.3",vt="WALLETCONNECT_CLIENT_ID",A={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},$r=ie,wt="subscription",It="0.3",Tt=ze*1e3,Ct="pairing",St="0.3",Fr=ie,V={wc_pairingDelete:{req:{ttl:B,prompt:!1,tag:1e3},res:{ttl:B,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:pe,prompt:!1,tag:1002},res:{ttl:pe,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:B,prompt:!1,tag:0},res:{ttl:B,prompt:!1,tag:0}}},J={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},P={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Pt="history",Rt="0.3",xt="expirer",R={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},Ot="0.3",Ur=B,At="verify-api",Kr="https://verify.walletconnect.com",Nt="https://verify.walletconnect.org",W=Nt,zt=`${W}/v3`,Lt=[Kr,Nt],$t="echo",Ft="https://echo.walletconnect.com",Mr="event-client",L={pairing_started:"pairing_started",pairing_uri_validation_success:"pairing_uri_validation_success",pairing_uri_not_expired:"pairing_uri_not_expired",store_new_pairing:"store_new_pairing",subscribing_pairing_topic:"subscribing_pairing_topic",subscribe_pairing_topic_success:"subscribe_pairing_topic_success",existing_pairing:"existing_pairing",pairing_not_expired:"pairing_not_expired",emit_inactive_pairing:"emit_inactive_pairing",emit_session_proposal:"emit_session_proposal",subscribing_to_pairing_topic:"subscribing_to_pairing_topic"},F={no_wss_connection:"no_wss_connection",no_internet_connection:"no_internet_connection",malformed_pairing_uri:"malformed_pairing_uri",active_pairing_already_exists:"active_pairing_already_exists",subscribe_pairing_topic_failure:"subscribe_pairing_topic_failure",pairing_expired:"pairing_expired",proposal_expired:"proposal_expired",proposal_listener_not_found:"proposal_listener_not_found"},kr={session_approve_started:"session_approve_started",proposal_not_expired:"proposal_not_expired",session_namespaces_validation_success:"session_namespaces_validation_success",create_session_topic:"create_session_topic",subscribing_session_topic:"subscribing_session_topic",subscribe_session_topic_success:"subscribe_session_topic_success",publishing_session_approve:"publishing_session_approve",session_approve_publish_success:"session_approve_publish_success",store_session:"store_session",publishing_session_settle:"publishing_session_settle",session_settle_publish_success:"session_settle_publish_success"},Br={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",proposal_expired:"proposal_expired",subscribe_session_topic_failure:"subscribe_session_topic_failure",session_approve_publish_failure:"session_approve_publish_failure",session_settle_publish_failure:"session_settle_publish_failure",session_approve_namespace_validation_failure:"session_approve_namespace_validation_failure",proposal_not_found:"proposal_not_found"},Vr={authenticated_session_approve_started:"authenticated_session_approve_started",authenticated_session_not_expired:"authenticated_session_not_expired",chains_caip2_compliant:"chains_caip2_compliant",chains_evm_compliant:"chains_evm_compliant",create_authenticated_session_topic:"create_authenticated_session_topic",cacaos_verified:"cacaos_verified",store_authenticated_session:"store_authenticated_session",subscribing_authenticated_session_topic:"subscribing_authenticated_session_topic",subscribe_authenticated_session_topic_success:"subscribe_authenticated_session_topic_success",publishing_authenticated_session_approve:"publishing_authenticated_session_approve",authenticated_session_approve_publish_success:"authenticated_session_approve_publish_success"},jr={no_internet_connection:"no_internet_connection",no_wss_connection:"no_wss_connection",missing_session_authenticate_request:"missing_session_authenticate_request",session_authenticate_request_expired:"session_authenticate_request_expired",chains_caip2_compliant_failure:"chains_caip2_compliant_failure",chains_evm_compliant_failure:"chains_evm_compliant_failure",invalid_cacao:"invalid_cacao",subscribe_authenticated_session_topic_failure:"subscribe_authenticated_session_topic_failure",authenticated_session_approve_publish_failure:"authenticated_session_approve_publish_failure",authenticated_session_pending_request_not_found:"authenticated_session_pending_request_not_found"},Ut=.1,Kt="event-client",Mt=86400,kt="https://pulse.walletconnect.com/batch";class Bt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=ct,this.version=lt,this.initialized=!1,this.storagePrefix=O,this.init=async()=>{if(!this.initialized){const s=await this.getKeyChain();typeof s<"u"&&(this.keychain=s),this.initialized=!0}},this.has=s=>(this.isInitialized(),this.keychain.has(s)),this.set=async(s,i)=>{this.isInitialized(),this.keychain.set(s,i),await this.persist()},this.get=s=>{this.isInitialized();const i=this.keychain.get(s);if(typeof i>"u"){const{message:r}=u("NO_MATCHING_KEY",`${this.name}: ${s}`);throw new Error(r)}return i},this.del=async s=>{this.isInitialized(),this.keychain.delete(s),await this.persist()},this.core=e,this.logger=v(t,this.name)}get context(){return C(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,Se(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?Pe(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Vt{constructor(e,t,s){this.core=e,this.logger=t,this.name=at,this.randomSessionIdentifier=ae(),this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=i=>(this.isInitialized(),this.keychain.has(i)),this.getClientId=async()=>{this.isInitialized();const i=await this.getClientSeed(),r=ee.generateKeyPair(i);return ee.encodeIss(r.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const i=Oi();return this.setPrivateKey(i.publicKey,i.privateKey)},this.signJWT=async i=>{this.isInitialized();const r=await this.getClientSeed(),n=ee.generateKeyPair(r),a=this.randomSessionIdentifier,h=ht;return await ee.signJWT(a,i,h,n)},this.generateSharedKey=(i,r,n)=>{this.isInitialized();const a=this.getPrivateKey(i),h=Ai(a,r);return this.setSymKey(h,n)},this.setSymKey=async(i,r)=>{this.isInitialized();const n=r||Ni(i);return await this.keychain.set(n,i),n},this.deleteKeyPair=async i=>{this.isInitialized(),await this.keychain.del(i)},this.deleteSymKey=async i=>{this.isInitialized(),await this.keychain.del(i)},this.encode=async(i,r,n)=>{this.isInitialized();const a=zi(n),h=Ri(r);if(Re(a)){const b=a.senderPublicKey,m=a.receiverPublicKey;i=await this.generateSharedKey(b,m)}const c=this.getSymKey(i),{type:d,senderPublicKey:g}=a;return Li({type:d,symKey:c,message:h,senderPublicKey:g})},this.decode=async(i,r,n)=>{this.isInitialized();const a=$i(r,n);if(Re(a)){const h=a.receiverPublicKey,c=a.senderPublicKey;i=await this.generateSharedKey(h,c)}try{const h=this.getSymKey(i),c=Fi({symKey:h,encoded:r});return xi(c)}catch(h){this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`),this.logger.error(h)}},this.getPayloadType=i=>{const r=xe(i);return Ui(r.type)},this.getPayloadSenderPublicKey=i=>{const r=xe(i);return r.senderPublicKey?ss(r.senderPublicKey,Ki):void 0},this.core=e,this.logger=v(t,this.name),this.keychain=s||new Bt(this.core,this.logger)}get context(){return C(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(Ee)}catch{e=ae(),await this.keychain.set(Ee,e)}return zr(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}}class jt extends mi{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=ut,this.version=dt,this.initialized=!1,this.storagePrefix=O,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const s=await this.getRelayerMessages();typeof s<"u"&&(this.messages=s),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(s){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(s)}finally{this.initialized=!0}}},this.set=async(s,i)=>{this.isInitialized();const r=he(i);let n=this.messages.get(s);return typeof n>"u"&&(n={}),typeof n[r]<"u"||(n[r]=i,this.messages.set(s,n),await this.persist()),r},this.get=s=>{this.isInitialized();let i=this.messages.get(s);return typeof i>"u"&&(i={}),i},this.has=(s,i)=>{this.isInitialized();const r=this.get(s),n=he(i);return typeof r[n]<"u"},this.del=async s=>{this.isInitialized(),this.messages.delete(s),await this.persist()},this.logger=v(e,this.name),this.core=t}get context(){return C(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,Se(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?Pe(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}}class qr extends fi{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new M,this.name=pt,this.queue=new Map,this.publishTimeout=S(ye),this.failedPublishTimeout=S(se),this.needsTransportRestart=!1,this.publish=async(s,i,r)=>{var n;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:s,message:i,opts:r}});const a=r?.ttl||gt,h=ce(r),c=r?.prompt||!1,d=r?.tag||0,g=r?.id||Fe().toString(),b={topic:s,message:i,opts:{ttl:a,relay:h,prompt:c,tag:d,id:g,attestation:r?.attestation}},m=`Failed to publish payload, please try again. id:${g} tag:${d}`,l=Date.now();let p,_=1;try{for(;p===void 0;){if(Date.now()-l>this.publishTimeout)throw new Error(m);this.logger.trace({id:g,attempts:_},`publisher.publish - attempt ${_}`),p=await await k(this.rpcPublish(s,i,a,h,c,d,g,r?.attestation).catch(D=>this.logger.warn(D)),this.publishTimeout,m),_++,p||await new Promise(D=>setTimeout(D,this.failedPublishTimeout))}this.relayer.events.emit(w.publish,b),this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{id:g,topic:s,message:i,opts:r}})}catch(D){if(this.logger.debug("Failed to Publish Payload"),this.logger.error(D),(n=r?.internal)!=null&&n.throwOnFailedPublish)throw D;this.queue.set(g,b)}},this.on=(s,i)=>{this.events.on(s,i)},this.once=(s,i)=>{this.events.once(s,i)},this.off=(s,i)=>{this.events.off(s,i)},this.removeListener=(s,i)=>{this.events.removeListener(s,i)},this.relayer=e,this.logger=v(t,this.name),this.registerEventListeners()}get context(){return C(this.logger)}rpcPublish(e,t,s,i,r,n,a,h){var c,d,g,b;const m={method:G(i.protocol).publish,params:{topic:e,message:t,ttl:s,prompt:r,tag:n,attestation:h},id:a};return le((c=m.params)==null?void 0:c.prompt)&&((d=m.params)==null||delete d.prompt),le((g=m.params)==null?void 0:g.tag)&&((b=m.params)==null||delete b.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:m}),this.relayer.request(m)}removeRequestFromQueue(e){this.queue.delete(e)}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:s,opts:i}=e;await this.publish(t,s,i)})}registerEventListeners(){this.relayer.core.heartbeat.on(q.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(w.connection_stalled);return}this.checkQueue()}),this.relayer.on(w.message_ack,e=>{this.removeRequestFromQueue(e.id.toString())})}}class Gr{constructor(){this.map=new Map,this.set=(e,t)=>{const s=this.get(e);this.exists(e,t)||this.map.set(e,[...s,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const s=this.get(e);if(!this.exists(e,t))return;const i=s.filter(r=>r!==t);if(!i.length){this.map.delete(e);return}this.map.set(e,i)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var Hr=Object.defineProperty,Yr=Object.defineProperties,Jr=Object.getOwnPropertyDescriptors,qt=Object.getOwnPropertySymbols,Wr=Object.prototype.hasOwnProperty,Xr=Object.prototype.propertyIsEnumerable,Gt=(o,e,t)=>e in o?Hr(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,X=(o,e)=>{for(var t in e||(e={}))Wr.call(e,t)&&Gt(o,t,e[t]);if(qt)for(var t of qt(e))Xr.call(e,t)&&Gt(o,t,e[t]);return o},Ie=(o,e)=>Yr(o,Jr(e));class Ht extends _i{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new Gr,this.events=new M,this.name=wt,this.version=It,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=O,this.subscribeTimeout=S(ye),this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.pendingBatchMessages=[],this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),this.clientId=await this.relayer.core.crypto.getClientId())},this.subscribe=async(s,i)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:i}});try{const r=ce(i),n={topic:s,relay:r};this.pending.set(s,n);const a=await this.rpcSubscribe(s,r);return typeof a=="string"&&(this.onSubscribe(a,n),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:s,opts:i}})),a}catch(r){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(r),r}},this.unsubscribe=async(s,i)=>{await this.restartToComplete(),this.isInitialized(),typeof i?.id<"u"?await this.unsubscribeById(s,i.id,i):await this.unsubscribeByTopic(s,i)},this.isSubscribed=async s=>{if(this.topics.includes(s))return!0;const i=`${this.pendingSubscriptionWatchLabel}_${s}`;return await new Promise((r,n)=>{const a=new ns;a.start(i);const h=setInterval(()=>{!this.pending.has(s)&&this.topics.includes(s)&&(clearInterval(h),a.stop(i),r(!0)),a.elapsed(i)>=Tt&&(clearInterval(h),a.stop(i),n(new Error("Subscription resolution timeout")))},this.pollingInterval)}).catch(()=>!1)},this.on=(s,i)=>{this.events.on(s,i)},this.once=(s,i)=>{this.events.once(s,i)},this.off=(s,i)=>{this.events.off(s,i)},this.removeListener=(s,i)=>{this.events.removeListener(s,i)},this.start=async()=>{await this.onConnect()},this.stop=async()=>{await this.onDisconnect()},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=v(t,this.name),this.clientId=""}get context(){return C(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let s=!1;try{s=this.getSubscription(e).topic===t}catch{}return s}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const s=this.topicMap.get(e);await Promise.all(s.map(async i=>await this.unsubscribeById(e,i,t)))}async unsubscribeById(e,t,s){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}});try{const i=ce(s);await this.rpcUnsubscribe(e,t,i);const r=H("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:s}})}catch(i){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(i),i}}async rpcSubscribe(e,t){const s={method:G(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});try{return await await k(this.relayer.request(s).catch(i=>this.logger.warn(i)),this.subscribeTimeout)?he(e+this.clientId):null}catch{this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(w.connection_stalled)}return null}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,s={method:G(t.protocol).batchSubscribe,params:{topics:e.map(i=>i.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});try{return await await k(this.relayer.request(s).catch(i=>this.logger.warn(i)),this.subscribeTimeout)}catch{this.relayer.events.emit(w.connection_stalled)}}async rpcBatchFetchMessages(e){if(!e.length)return;const t=e[0].relay,s={method:G(t.protocol).batchFetchMessages,params:{topics:e.map(r=>r.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s});let i;try{i=await await k(this.relayer.request(s).catch(r=>this.logger.warn(r)),this.subscribeTimeout)}catch{this.relayer.events.emit(w.connection_stalled)}return i}rpcUnsubscribe(e,t,s){const i={method:G(s.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i}),this.relayer.request(i)}onSubscribe(e,t){this.setSubscription(e,Ie(X({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,X({},t)),this.pending.delete(t.topic)})}async onUnsubscribe(e,t,s){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,s),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t)}addSubscription(e,t){this.subscriptions.set(e,X({},t)),this.topicMap.set(t.topic,e),this.events.emit(A.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:s}=u("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const s=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(s.topic,e),this.events.emit(A.deleted,Ie(X({},s),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(A.sync)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const s=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchFetchMessages(s),await this.batchSubscribe(s)}}this.events.emit(A.resubscribed)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=u("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);Mi(t)&&this.onBatchSubscribe(t.map((s,i)=>Ie(X({},e[i]),{id:s})))}async batchFetchMessages(e){if(!e.length)return;this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);const t=await this.rpcBatchFetchMessages(e);t&&t.messages&&(this.pendingBatchMessages=this.pendingBatchMessages.concat(t.messages))}async onConnect(){await this.restart(),this.onEnable()}onDisconnect(){this.onDisable()}async checkPending(){if(!this.initialized||!this.relayer.connected)return;const e=[];this.pending.forEach(t=>{e.push(t)}),await this.batchSubscribe(e),this.pendingBatchMessages.length&&(await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages),this.pendingBatchMessages=[])}registerEventListeners(){this.relayer.core.heartbeat.on(q.pulse,async()=>{await this.checkPending()}),this.events.on(A.created,async e=>{const t=A.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}),this.events.on(A.deleted,async e=>{const t=A.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise(e=>{const t=setInterval(()=>{this.restartInProgress||(clearInterval(t),e())},this.pollingInterval)})}}var Zr=Object.defineProperty,Yt=Object.getOwnPropertySymbols,Qr=Object.prototype.hasOwnProperty,en=Object.prototype.propertyIsEnumerable,Jt=(o,e,t)=>e in o?Zr(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,tn=(o,e)=>{for(var t in e||(e={}))Qr.call(e,t)&&Jt(o,t,e[t]);if(Yt)for(var t of Yt(e))en.call(e,t)&&Jt(o,t,e[t]);return o};class Wt extends Ei{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new M,this.name=bt,this.transportExplicitlyClosed=!1,this.initialized=!1,this.connectionAttemptInProgress=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","stalled","interrupted"],this.hasExperiencedNetworkDisruption=!1,this.requestsInFlight=new Map,this.heartBeatTimeout=S(pe+se),this.request=async t=>{var s,i;this.logger.debug("Publishing Request Payload");const r=t.id||Fe().toString();await this.toEstablishConnection();try{const n=this.provider.request(t);this.requestsInFlight.set(r,{promise:n,request:t}),this.logger.trace({id:r,method:t.method,topic:(s=t.params)==null?void 0:s.topic},"relayer.request - attempt to publish...");const a=await new Promise(async(h,c)=>{const d=()=>{c(new Error(`relayer.request - publish interrupted, id: ${r}`))};this.provider.on(I.disconnect,d);const g=await n;this.provider.off(I.disconnect,d),h(g)});return this.logger.trace({id:r,method:t.method,topic:(i=t.params)==null?void 0:i.topic},"relayer.request - published"),a}catch(n){throw this.logger.debug(`Failed to Publish Request: ${r}`),n}finally{this.requestsInFlight.delete(r)}},this.resetPingTimeout=()=>{if(ue())try{clearTimeout(this.pingTimeout),this.pingTimeout=setTimeout(()=>{var t,s,i;(i=(s=(t=this.provider)==null?void 0:t.connection)==null?void 0:s.socket)==null||i.terminate()},this.heartBeatTimeout)}catch(t){this.logger.warn(t)}},this.onPayloadHandler=t=>{this.onProviderPayload(t),this.resetPingTimeout()},this.onConnectHandler=()=>{this.logger.trace("relayer connected"),this.startPingTimeout(),this.events.emit(w.connect)},this.onDisconnectHandler=()=>{this.logger.trace("relayer disconnected"),this.onProviderDisconnect()},this.onProviderErrorHandler=t=>{this.logger.error(t),this.events.emit(w.error,t),this.logger.info("Fatal socket error received, closing transport"),this.transportClose()},this.registerProviderListeners=()=>{this.provider.on(I.payload,this.onPayloadHandler),this.provider.on(I.connect,this.onConnectHandler),this.provider.on(I.disconnect,this.onDisconnectHandler),this.provider.on(I.error,this.onProviderErrorHandler)},this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?v(e.logger,this.name):Di(Te({level:e.logger||Dt})),this.messages=new jt(this.logger,e.core),this.subscriber=new Ht(this,this.logger),this.publisher=new qr(this,this.logger),this.relayUrl=e?.relayUrl||ve,this.projectId=e.projectId,this.bundleId=ki(),this.provider={}}async init(){this.logger.trace("Initialized"),this.registerEventListeners(),await Promise.all([this.messages.init(),this.subscriber.init()]),await this.transportOpen(),this.initialized=!0,setTimeout(async()=>{this.subscriber.topics.length===0&&this.subscriber.pending.size===0&&(this.logger.info("No topics subscribed to after init, closing transport"),await this.transportClose(),this.transportExplicitlyClosed=!1)},_t)}get context(){return C(this.logger)}get connected(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===1}get connecting(){var e,t,s;return((s=(t=(e=this.provider)==null?void 0:e.connection)==null?void 0:t.socket)==null?void 0:s.readyState)===0}async publish(e,t,s){this.isInitialized(),await this.publisher.publish(e,t,s),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()})}async subscribe(e,t){var s;this.isInitialized();let i=((s=this.subscriber.topicMap.get(e))==null?void 0:s[0])||"",r;const n=a=>{a.topic===e&&(this.subscriber.off(A.created,n),r())};return await Promise.all([new Promise(a=>{r=a,this.subscriber.on(A.created,n)}),new Promise(async a=>{i=await this.subscriber.subscribe(e,t)||i,a()})]),i}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportDisconnect(){if(!this.hasExperiencedNetworkDisruption&&this.connected&&this.requestsInFlight.size>0)try{await Promise.all(Array.from(this.requestsInFlight.values()).map(e=>e.promise))}catch(e){this.logger.warn(e)}this.hasExperiencedNetworkDisruption||this.connected?await k(this.provider.disconnect(),2e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.onProviderDisconnect()}async transportClose(){this.transportExplicitlyClosed=!0,await this.transportDisconnect()}async transportOpen(e){await this.confirmOnlineStateOrThrow(),e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportDisconnect()),await this.createProvider(),this.connectionAttemptInProgress=!0,this.transportExplicitlyClosed=!1;try{await new Promise(async(t,s)=>{const i=()=>{this.provider.off(I.disconnect,i),s(new Error("Connection interrupted while trying to subscribe"))};this.provider.on(I.disconnect,i),await k(this.provider.connect(),S(ye),`Socket stalled when trying to connect to ${this.relayUrl}`).catch(r=>{s(r)}).finally(()=>{clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0}),this.subscriber.start().catch(r=>{this.logger.error(r),this.onDisconnectHandler()}),this.hasExperiencedNetworkDisruption=!1,t()})}catch(t){this.logger.error(t);const s=t;if(this.hasExperiencedNetworkDisruption=!0,!this.isConnectionStalled(s.message))throw t}finally{this.connectionAttemptInProgress=!1}}async restartTransport(e){this.connectionAttemptInProgress||(this.relayUrl=e||this.relayUrl,await this.confirmOnlineStateOrThrow(),await this.transportClose(),await this.transportOpen())}async confirmOnlineStateOrThrow(){if(!await Oe())throw new Error("No internet connection detected. Please restart your network and try again.")}async handleBatchMessageEvents(e){if(e?.length===0){this.logger.trace("Batch message events is empty. Ignoring...");return}const t=e.sort((s,i)=>s.publishedAt-i.publishedAt);this.logger.trace(`Batch of ${t.length} message events sorted`);for(const s of t)try{await this.onMessageEvent(s)}catch(i){this.logger.warn(i)}this.logger.trace(`Batch of ${t.length} message events processed`)}startPingTimeout(){var e,t,s,i,r;if(ue())try{(t=(e=this.provider)==null?void 0:e.connection)!=null&&t.socket&&((r=(i=(s=this.provider)==null?void 0:s.connection)==null?void 0:i.socket)==null||r.once("ping",()=>{this.resetPingTimeout()})),this.resetPingTimeout()}catch(n){this.logger.warn(n)}}isConnectionStalled(e){return this.staleConnectionErrors.some(t=>e.includes(t))}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new os(new cs(Bi({sdkVersion:we,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:s}=e;await this.messages.set(t,s)}async shouldIgnoreMessageEvent(e){const{topic:t,message:s}=e;if(!s||s.length===0)return this.logger.debug(`Ignoring invalid/empty message: ${s}`),!0;if(!await this.subscriber.isSubscribed(t))return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`),!0;const i=this.messages.has(t,s);return i&&this.logger.debug(`Ignoring duplicate message: ${s}`),i}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),Ue(e)){if(!e.method.endsWith(mt))return;const t=e.params,{topic:s,message:i,publishedAt:r,attestation:n}=t.data,a={topic:s,message:i,publishedAt:r,attestation:n};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(tn({type:"event",event:t.id},a)),this.events.emit(t.id,a),await this.acknowledgePayload(e),await this.onMessageEvent(a)}else Ke(e)&&this.events.emit(w.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(w.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=Me(e.id,!0);await this.provider.connection.send(t)}unregisterProviderListeners(){this.provider.off(I.payload,this.onPayloadHandler),this.provider.off(I.connect,this.onConnectHandler),this.provider.off(I.disconnect,this.onDisconnectHandler),this.provider.off(I.error,this.onProviderErrorHandler),clearTimeout(this.pingTimeout)}async registerEventListeners(){let e=await Oe();Vi(async t=>{e!==t&&(e=t,t?await this.restartTransport().catch(s=>this.logger.error(s)):(this.hasExperiencedNetworkDisruption=!0,await this.transportDisconnect(),this.transportExplicitlyClosed=!1))})}async onProviderDisconnect(){await this.subscriber.stop(),this.requestsInFlight.clear(),clearTimeout(this.pingTimeout),this.events.emit(w.disconnect),this.connectionAttemptInProgress=!1,!this.transportExplicitlyClosed&&(this.reconnectTimeout||(this.reconnectTimeout=setTimeout(async()=>{await this.transportOpen().catch(e=>this.logger.error(e))},S(ft))))}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){await this.confirmOnlineStateOrThrow(),!this.connected&&(this.connectionAttemptInProgress&&await new Promise(e=>{const t=setInterval(()=>{this.connected&&(clearInterval(t),e())},this.connectionStatusPollingInterval)}),await this.transportOpen())}}var sn=Object.defineProperty,Xt=Object.getOwnPropertySymbols,rn=Object.prototype.hasOwnProperty,nn=Object.prototype.propertyIsEnumerable,Zt=(o,e,t)=>e in o?sn(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Qt=(o,e)=>{for(var t in e||(e={}))rn.call(e,t)&&Zt(o,t,e[t]);if(Xt)for(var t of Xt(e))nn.call(e,t)&&Zt(o,t,e[t]);return o};class ei extends vi{constructor(e,t,s,i=O,r=void 0){super(e,t,s,i),this.core=e,this.logger=t,this.name=s,this.map=new Map,this.version=Et,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.recentlyDeleted=[],this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(n=>{this.getKey&&n!==null&&!le(n)?this.map.set(this.getKey(n),n):ji(n)?this.map.set(n.id,n):qi(n)&&this.map.set(n.topic,n)}),this.cached=[],this.initialized=!0)},this.set=async(n,a)=>{this.isInitialized(),this.map.has(n)?await this.update(n,a):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:n,value:a}),this.map.set(n,a),await this.persist())},this.get=n=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:n}),this.getData(n)),this.getAll=n=>(this.isInitialized(),n?this.values.filter(a=>Object.keys(n).every(h=>ls(a[h],n[h]))):this.values),this.update=async(n,a)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:n,update:a});const h=Qt(Qt({},this.getData(n)),a);this.map.set(n,h),await this.persist()},this.delete=async(n,a)=>{this.isInitialized(),this.map.has(n)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:n,reason:a}),this.map.delete(n),this.addToRecentlyDeleted(n),await this.persist())},this.logger=v(t,this.name),this.storagePrefix=i,this.getKey=r}get context(){return C(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}addToRecentlyDeleted(e){this.recentlyDeleted.push(e),this.recentlyDeleted.length>=this.recentlyDeletedLimit&&this.recentlyDeleted.splice(0,this.recentlyDeletedLimit/2)}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){if(this.recentlyDeleted.includes(e)){const{message:i}=u("MISSING_OR_INVALID",`Record was recently deleted - ${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}const{message:s}=u("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(s),new Error(s)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=u("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}}class ti{constructor(e,t){this.core=e,this.logger=t,this.name=Ct,this.version=St,this.events=new gi,this.initialized=!1,this.storagePrefix=O,this.ignoredPayloadTypes=[Gi],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:s})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...s])]},this.create=async s=>{this.isInitialized();const i=ae(),r=await this.core.crypto.setSymKey(i),n=te(Le),a={protocol:yt},h={topic:r,expiry:n,relay:a,active:!1},c=Hi({protocol:this.core.protocol,version:this.core.version,topic:r,symKey:i,relay:a,expiryTimestamp:n,methods:s?.methods});return this.core.expirer.set(r,n),await this.pairings.set(r,h),await this.core.relayer.subscribe(r),{topic:r,uri:c}},this.pair=async s=>{this.isInitialized();const i=this.core.eventClient.createEvent({properties:{topic:s?.uri,trace:[L.pairing_started]}});this.isValidPair(s,i);const{topic:r,symKey:n,relay:a,expiryTimestamp:h,methods:c}=Ae(s.uri);i.props.properties.topic=r,i.addTrace(L.pairing_uri_validation_success),i.addTrace(L.pairing_uri_not_expired);let d;if(this.pairings.keys.includes(r)){if(d=this.pairings.get(r),i.addTrace(L.existing_pairing),d.active)throw i.setError(F.active_pairing_already_exists),new Error(`Pairing already exists: ${r}. Please try again with a new connection URI.`);i.addTrace(L.pairing_not_expired)}const g=h||te(Le),b={topic:r,relay:a,expiry:g,active:!1,methods:c};this.core.expirer.set(r,g),await this.pairings.set(r,b),i.addTrace(L.store_new_pairing),s.activatePairing&&await this.activate({topic:r}),this.events.emit(J.create,b),i.addTrace(L.emit_inactive_pairing),this.core.crypto.keychain.has(r)||await this.core.crypto.setSymKey(n,r),i.addTrace(L.subscribing_pairing_topic);try{await this.core.relayer.confirmOnlineStateOrThrow()}catch{i.setError(F.no_internet_connection)}try{await this.core.relayer.subscribe(r,{relay:a})}catch(m){throw i.setError(F.subscribe_pairing_topic_failure),m}return i.addTrace(L.subscribe_pairing_topic_success),b},this.activate=async({topic:s})=>{this.isInitialized();const i=te(ie);this.core.expirer.set(s,i),await this.pairings.update(s,{active:!0,expiry:i})},this.ping=async s=>{this.isInitialized(),await this.isValidPing(s);const{topic:i}=s;if(this.pairings.keys.includes(i)){const r=await this.sendRequest(i,"wc_pairingPing",{}),{done:n,resolve:a,reject:h}=Yi();this.events.once(de("pairing_ping",r),({error:c})=>{c?h(c):a()}),await n()}},this.updateExpiry=async({topic:s,expiry:i})=>{this.isInitialized(),await this.pairings.update(s,{expiry:i})},this.updateMetadata=async({topic:s,metadata:i})=>{this.isInitialized(),await this.pairings.update(s,{peerMetadata:i})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async s=>{this.isInitialized(),await this.isValidDisconnect(s);const{topic:i}=s;this.pairings.keys.includes(i)&&(await this.sendRequest(i,"wc_pairingDelete",H("USER_DISCONNECTED")),await this.deletePairing(i))},this.sendRequest=async(s,i,r)=>{const n=ke(i,r),a=await this.core.crypto.encode(s,n),h=V[i].req;return this.core.history.set(s,n),this.core.relayer.publish(s,a,h),n.id},this.sendResult=async(s,i,r)=>{const n=Me(s,r),a=await this.core.crypto.encode(i,n),h=await this.core.history.get(i,s),c=V[h.request.method].res;await this.core.relayer.publish(i,a,c),await this.core.history.resolve(n)},this.sendError=async(s,i,r)=>{const n=as(s,r),a=await this.core.crypto.encode(i,n),h=await this.core.history.get(i,s),c=V[h.request.method]?V[h.request.method].res:V.unregistered_method.res;await this.core.relayer.publish(i,a,c),await this.core.history.resolve(n)},this.deletePairing=async(s,i)=>{await this.core.relayer.unsubscribe(s),await Promise.all([this.pairings.delete(s,H("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(s),i?Promise.resolve():this.core.expirer.del(s)])},this.cleanup=async()=>{const s=this.pairings.getAll().filter(i=>Ne(i.expiry));await Promise.all(s.map(i=>this.deletePairing(i.topic)))},this.onRelayEventRequest=s=>{const{topic:i,payload:r}=s;switch(r.method){case"wc_pairingPing":return this.onPairingPingRequest(i,r);case"wc_pairingDelete":return this.onPairingDeleteRequest(i,r);default:return this.onUnknownRpcMethodRequest(i,r)}},this.onRelayEventResponse=async s=>{const{topic:i,payload:r}=s,n=(await this.core.history.get(i,r.id)).request.method;switch(n){case"wc_pairingPing":return this.onPairingPingResponse(i,r);default:return this.onUnknownRpcMethodResponse(n)}},this.onPairingPingRequest=async(s,i)=>{const{id:r}=i;try{this.isValidPing({topic:s}),await this.sendResult(r,s,!0),this.events.emit(J.ping,{id:r,topic:s})}catch(n){await this.sendError(r,s,n),this.logger.error(n)}},this.onPairingPingResponse=(s,i)=>{const{id:r}=i;setTimeout(()=>{hs(i)?this.events.emit(de("pairing_ping",r),{}):Be(i)&&this.events.emit(de("pairing_ping",r),{error:i.error})},500)},this.onPairingDeleteRequest=async(s,i)=>{const{id:r}=i;try{this.isValidDisconnect({topic:s}),await this.deletePairing(s),this.events.emit(J.delete,{id:r,topic:s})}catch(n){await this.sendError(r,s,n),this.logger.error(n)}},this.onUnknownRpcMethodRequest=async(s,i)=>{const{id:r,method:n}=i;try{if(this.registeredMethods.includes(n))return;const a=H("WC_METHOD_UNSUPPORTED",n);await this.sendError(r,s,a),this.logger.error(a)}catch(a){await this.sendError(r,s,a),this.logger.error(a)}},this.onUnknownRpcMethodResponse=s=>{this.registeredMethods.includes(s)||this.logger.error(H("WC_METHOD_UNSUPPORTED",s))},this.isValidPair=(s,i)=>{var r;if(!ge(s)){const{message:a}=u("MISSING_OR_INVALID",`pair() params: ${s}`);throw i.setError(F.malformed_pairing_uri),new Error(a)}if(!Ji(s.uri)){const{message:a}=u("MISSING_OR_INVALID",`pair() uri: ${s.uri}`);throw i.setError(F.malformed_pairing_uri),new Error(a)}const n=Ae(s?.uri);if(!((r=n?.relay)!=null&&r.protocol)){const{message:a}=u("MISSING_OR_INVALID","pair() uri#relay-protocol");throw i.setError(F.malformed_pairing_uri),new Error(a)}if(!(n!=null&&n.symKey)){const{message:a}=u("MISSING_OR_INVALID","pair() uri#symKey");throw i.setError(F.malformed_pairing_uri),new Error(a)}if(n!=null&&n.expiryTimestamp&&S(n?.expiryTimestamp)<Date.now()){i.setError(F.pairing_expired);const{message:a}=u("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(a)}},this.isValidPing=async s=>{if(!ge(s)){const{message:r}=u("MISSING_OR_INVALID",`ping() params: ${s}`);throw new Error(r)}const{topic:i}=s;await this.isValidPairingTopic(i)},this.isValidDisconnect=async s=>{if(!ge(s)){const{message:r}=u("MISSING_OR_INVALID",`disconnect() params: ${s}`);throw new Error(r)}const{topic:i}=s;await this.isValidPairingTopic(i)},this.isValidPairingTopic=async s=>{if(!Wi(s,!1)){const{message:i}=u("MISSING_OR_INVALID",`pairing topic should be a string: ${s}`);throw new Error(i)}if(!this.pairings.keys.includes(s)){const{message:i}=u("NO_MATCHING_KEY",`pairing topic doesn't exist: ${s}`);throw new Error(i)}if(Ne(this.pairings.get(s).expiry)){await this.deletePairing(s);const{message:i}=u("EXPIRED",`pairing topic: ${s}`);throw new Error(i)}},this.core=e,this.logger=v(t,this.name),this.pairings=new ei(this.core,this.logger,this.name,this.storagePrefix)}get context(){return C(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(w.message,async e=>{const{topic:t,message:s}=e;if(!this.pairings.keys.includes(t)||this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s)))return;const i=await this.core.crypto.decode(t,s);try{Ue(i)?(this.core.history.set(t,i),this.onRelayEventRequest({topic:t,payload:i})):Ke(i)&&(await this.core.history.resolve(i),await this.onRelayEventResponse({topic:t,payload:i}),this.core.history.delete(t,i.id))}catch(r){this.logger.error(r)}})}registerExpirerEvents(){this.core.expirer.on(R.expired,async e=>{const{topic:t}=Xi(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(J.expire,{topic:t}))})}}class ii extends wi{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new M,this.name=Pt,this.version=Rt,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.records.set(s.id,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(s,i,r)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:s,request:i,chainId:r}),this.records.has(i.id))return;const n={id:i.id,topic:s,request:{method:i.method,params:i.params||null},chainId:r,expiry:te(ie)};this.records.set(n.id,n),this.persist(),this.events.emit(P.created,n)},this.resolve=async s=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:s}),!this.records.has(s.id))return;const i=await this.getRecord(s.id);typeof i.response>"u"&&(i.response=Be(s)?{error:s.error}:{result:s.result},this.records.set(i.id,i),this.persist(),this.events.emit(P.updated,i))},this.get=async(s,i)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:s,id:i}),await this.getRecord(i)),this.delete=(s,i)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:i}),this.values.forEach(r=>{if(r.topic===s){if(typeof i<"u"&&r.id!==i)return;this.records.delete(r.id),this.events.emit(P.deleted,r)}}),this.persist()},this.exists=async(s,i)=>(this.isInitialized(),this.records.has(i)?(await this.getRecord(i)).topic===s:!1),this.on=(s,i)=>{this.events.on(s,i)},this.once=(s,i)=>{this.events.once(s,i)},this.off=(s,i)=>{this.events.off(s,i)},this.removeListener=(s,i)=>{this.events.removeListener(s,i)},this.logger=v(t,this.name)}get context(){return C(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const s={topic:t.topic,request:ke(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(s)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:s}=u("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(s)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(P.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=u("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(P.created,e=>{const t=P.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(P.updated,e=>{const t=P.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.events.on(P.deleted,e=>{const t=P.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e})}),this.core.heartbeat.on(q.pulse,()=>{this.cleanup()})}cleanup(){try{this.isInitialized();let e=!1;this.records.forEach(t=>{S(t.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${t.id}`),this.records.delete(t.id),this.events.emit(P.deleted,t,!1),e=!0)}),e&&this.persist()}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}}class si extends Ii{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new M,this.name=xt,this.version=Ot,this.cached=[],this.initialized=!1,this.storagePrefix=O,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(s=>this.expirations.set(s.target,s)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=s=>{try{const i=this.formatTarget(s);return typeof this.getExpiration(i)<"u"}catch{return!1}},this.set=(s,i)=>{this.isInitialized();const r=this.formatTarget(s),n={target:r,expiry:i};this.expirations.set(r,n),this.checkExpiry(r,n),this.events.emit(R.created,{target:r,expiration:n})},this.get=s=>{this.isInitialized();const i=this.formatTarget(s);return this.getExpiration(i)},this.del=s=>{if(this.isInitialized(),this.has(s)){const i=this.formatTarget(s),r=this.getExpiration(i);this.expirations.delete(i),this.events.emit(R.deleted,{target:i,expiration:r})}},this.on=(s,i)=>{this.events.on(s,i)},this.once=(s,i)=>{this.events.once(s,i)},this.off=(s,i)=>{this.events.off(s,i)},this.removeListener=(s,i)=>{this.events.removeListener(s,i)},this.logger=v(t,this.name)}get context(){return C(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return Zi(e);if(typeof e=="number")return Qi(e);const{message:t}=u("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(R.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=u("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:s}=u("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.warn(s),new Error(s)}return t}checkExpiry(e,t){const{expiry:s}=t;S(s)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(R.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(q.pulse,()=>this.checkExpirations()),this.events.on(R.created,e=>{const t=R.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(R.expired,e=>{const t=R.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(R.deleted,e=>{const t=R.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=u("NOT_INITIALIZED",this.name);throw new Error(e)}}}var y={};Object.defineProperty(y,"__esModule",{value:!0}),y.getLocalStorage=y.getLocalStorageOrThrow=y.getCrypto=y.getCryptoOrThrow=y.getLocation=y.getLocationOrThrow=y.getNavigator=y.getNavigatorOrThrow=ri=y.getDocument=y.getDocumentOrThrow=y.getFromWindowOrThrow=y.getFromWindow=void 0;function K(o){let e;return typeof window<"u"&&typeof window[o]<"u"&&(e=window[o]),e}y.getFromWindow=K;function j(o){const e=K(o);if(!e)throw new Error(`${o} is not defined in Window`);return e}y.getFromWindowOrThrow=j;function on(){return j("document")}y.getDocumentOrThrow=on;function an(){return K("document")}var ri=y.getDocument=an;function hn(){return j("navigator")}y.getNavigatorOrThrow=hn;function cn(){return K("navigator")}y.getNavigator=cn;function ln(){return j("location")}y.getLocationOrThrow=ln;function un(){return K("location")}y.getLocation=un;function dn(){return j("crypto")}y.getCryptoOrThrow=dn;function gn(){return K("crypto")}y.getCrypto=gn;function pn(){return j("localStorage")}y.getLocalStorageOrThrow=pn;function yn(){return K("localStorage")}y.getLocalStorage=yn;class ni extends Ti{constructor(e,t,s){super(e,t,s),this.core=e,this.logger=t,this.store=s,this.name=At,this.verifyUrlV3=zt,this.storagePrefix=O,this.version=_e,this.init=async()=>{var i;this.isDevEnv||(this.publicKey=await this.store.getItem(this.storeKey),this.publicKey&&S((i=this.publicKey)==null?void 0:i.expiresAt)<Date.now()&&(this.logger.debug("verify v2 public key expired"),await this.removePublicKey()),this.publicKey||await this.fetchAndPersistPublicKey())},this.register=async i=>{if(!es()||this.isDevEnv)return;const r=window.location.origin,{id:n,decryptedId:a}=i,h=`${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r}&id=${n}&decryptedId=${a}`;try{const c=ri(),d=this.startAbortTimer(se*5),g=await new Promise((b,m)=>{const l=()=>{window.removeEventListener("message",_),c.body.removeChild(p),m("attestation aborted")};this.abortController.signal.addEventListener("abort",l);const p=c.createElement("iframe");p.src=h,p.style.display="none",p.addEventListener("error",l,{signal:this.abortController.signal});const _=D=>{if(!D.data)return;const E=JSON.parse(D.data);if(E.type==="verify_attestation"){if(Ce(E.attestation).payload.id!==n)return;clearInterval(d),c.body.removeChild(p),this.abortController.signal.removeEventListener("abort",l),window.removeEventListener("message",_),b(E.attestation===null?"":E.attestation)}};c.body.appendChild(p),window.addEventListener("message",_,{signal:this.abortController.signal})});return this.logger.debug("jwt attestation",g),g}catch(c){this.logger.warn(c)}return""},this.resolve=async i=>{if(this.isDevEnv)return"";const{attestationId:r,hash:n,encryptedId:a}=i;if(r===""){this.logger.debug("resolve: attestationId is empty, skipping");return}if(r){if(Ce(r).payload.id!==a)return;const c=await this.isValidJwtAttestation(r);if(c)return c}if(!n)return;const h=this.getVerifyUrl(i?.verifyUrl);return this.fetchAttestation(n,h)},this.fetchAttestation=async(i,r)=>{this.logger.debug(`resolving attestation: ${i} from url: ${r}`);const n=this.startAbortTimer(se*5),a=await fetch(`${r}/attestation/${i}?v2Supported=true`,{signal:this.abortController.signal});return clearTimeout(n),a.status===200?await a.json():void 0},this.getVerifyUrl=i=>{let r=i||W;return Lt.includes(r)||(this.logger.info(`verify url: ${r}, not included in trusted list, assigning default: ${W}`),r=W),r},this.fetchPublicKey=async()=>{try{this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);const i=this.startAbortTimer(ze),r=await fetch(`${this.verifyUrlV3}/public-key`,{signal:this.abortController.signal});return clearTimeout(i),await r.json()}catch(i){this.logger.warn(i)}},this.persistPublicKey=async i=>{this.logger.debug("persisting public key to local storage",i),await this.store.setItem(this.storeKey,i),this.publicKey=i},this.removePublicKey=async()=>{this.logger.debug("removing verify v2 public key from storage"),await this.store.removeItem(this.storeKey),this.publicKey=void 0},this.isValidJwtAttestation=async i=>{const r=await this.getPublicKey();try{if(r)return this.validateAttestation(i,r)}catch(a){this.logger.error(a),this.logger.warn("error validating attestation")}const n=await this.fetchAndPersistPublicKey();try{if(n)return this.validateAttestation(i,n)}catch(a){this.logger.error(a),this.logger.warn("error validating attestation")}},this.getPublicKey=async()=>this.publicKey?this.publicKey:await this.fetchAndPersistPublicKey(),this.fetchAndPersistPublicKey=async()=>{if(this.fetchPromise)return await this.fetchPromise,this.publicKey;this.fetchPromise=new Promise(async r=>{const n=await this.fetchPublicKey();n&&(await this.persistPublicKey(n),r(n))});const i=await this.fetchPromise;return this.fetchPromise=void 0,i},this.validateAttestation=(i,r)=>{const n=ts(i,r.publicKey),a={hasExpired:S(n.exp)<Date.now(),payload:n};if(a.hasExpired)throw this.logger.warn("resolve: jwt attestation expired"),new Error("JWT attestation expired");return{origin:a.payload.origin,isScam:a.payload.isScam}},this.logger=v(t,this.name),this.abortController=new AbortController,this.isDevEnv=ue()&&process.env.IS_VITEST,this.init()}get storeKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//verify:public:key"}get context(){return C(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),S(e))}}class oi extends Ci{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.context=$t,this.registerDeviceToken=async s=>{const{clientId:i,token:r,notificationType:n,enableEncrypted:a=!1}=s,h=`${Ft}/${this.projectId}/clients`;await fetch(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:i,type:n,token:r,always_raw:a})})},this.logger=v(t,this.context)}}var Dn=Object.defineProperty,ai=Object.getOwnPropertySymbols,bn=Object.prototype.hasOwnProperty,mn=Object.prototype.propertyIsEnumerable,hi=(o,e,t)=>e in o?Dn(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,Z=(o,e)=>{for(var t in e||(e={}))bn.call(e,t)&&hi(o,t,e[t]);if(ai)for(var t of ai(e))mn.call(e,t)&&hi(o,t,e[t]);return o};class ci extends Si{constructor(e,t,s=!0){super(e,t,s),this.core=e,this.logger=t,this.context=Kt,this.storagePrefix=O,this.storageVersion=Ut,this.events=new Map,this.shouldPersist=!1,this.createEvent=i=>{const{event:r="ERROR",type:n="",properties:{topic:a,trace:h}}=i,c=is(),d=this.core.projectId||"",g=Date.now(),b=Z({eventId:c,bundleId:d,timestamp:g,props:{event:r,type:n,properties:{topic:a,trace:h}}},this.setMethods(c));return this.telemetryEnabled&&(this.events.set(c,b),this.shouldPersist=!0),b},this.getEvent=i=>{const{eventId:r,topic:n}=i;if(r)return this.events.get(r);const a=Array.from(this.events.values()).find(h=>h.props.properties.topic===n);if(a)return Z(Z({},a),this.setMethods(a.eventId))},this.deleteEvent=i=>{const{eventId:r}=i;this.events.delete(r),this.shouldPersist=!0},this.setEventListeners=()=>{this.core.heartbeat.on(q.pulse,async()=>{this.shouldPersist&&await this.persist(),this.events.forEach(i=>{$e(Date.now())-$e(i.timestamp)>Mt&&(this.events.delete(i.eventId),this.shouldPersist=!0)})})},this.setMethods=i=>({addTrace:r=>this.addTrace(i,r),setError:r=>this.setError(i,r)}),this.addTrace=(i,r)=>{const n=this.events.get(i);n&&(n.props.properties.trace.push(r),this.events.set(i,n),this.shouldPersist=!0)},this.setError=(i,r)=>{const n=this.events.get(i);n&&(n.props.type=r,n.timestamp=Date.now(),this.events.set(i,n),this.shouldPersist=!0)},this.persist=async()=>{await this.core.storage.setItem(this.storageKey,Array.from(this.events.values())),this.shouldPersist=!1},this.restore=async()=>{try{const i=await this.core.storage.getItem(this.storageKey)||[];if(!i.length)return;i.forEach(r=>{this.events.set(r.eventId,Z(Z({},r),this.setMethods(r.eventId)))})}catch(i){this.logger.warn(i)}},this.submit=async()=>{if(!this.telemetryEnabled||this.events.size===0)return;const i=[];for(const[r,n]of this.events)n.props.type&&i.push(n);if(i.length!==0)try{if((await fetch(`${kt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${we}`,{method:"POST",body:JSON.stringify(i)})).ok)for(const r of i)this.events.delete(r.eventId),this.shouldPersist=!0}catch(r){this.logger.warn(r)}},this.logger=v(t,this.context),s?this.restore().then(async()=>{await this.submit(),this.setEventListeners()}):this.persist()}get storageKey(){return this.storagePrefix+this.storageVersion+this.core.customStoragePrefix+"//"+this.context}}var fn=Object.defineProperty,li=Object.getOwnPropertySymbols,_n=Object.prototype.hasOwnProperty,En=Object.prototype.propertyIsEnumerable,ui=(o,e,t)=>e in o?fn(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,di=(o,e)=>{for(var t in e||(e={}))_n.call(e,t)&&ui(o,t,e[t]);if(li)for(var t of li(e))En.call(e,t)&&ui(o,t,e[t]);return o};class oe extends Pi{constructor(e){var t;super(e),this.protocol=fe,this.version=_e,this.name=ne,this.events=new M,this.initialized=!1,this.on=(n,a)=>this.events.on(n,a),this.once=(n,a)=>this.events.once(n,a),this.off=(n,a)=>this.events.off(n,a),this.removeListener=(n,a)=>this.events.removeListener(n,a),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||ve,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const s=Te({level:typeof e?.logger=="string"&&e.logger?e.logger:nt.logger}),{logger:i,chunkLoggerController:r}=bi({opts:s,maxSizeInBytes:e?.maxLogBlobSizeInBytes,loggerOverride:e?.logger});this.logChunkController=r,(t=this.logChunkController)!=null&&t.downloadLogsBlobInBrowser&&(window.downloadLogsBlobInBrowser=async()=>{var n,a;(n=this.logChunkController)!=null&&n.downloadLogsBlobInBrowser&&((a=this.logChunkController)==null||a.downloadLogsBlobInBrowser({clientId:await this.crypto.getClientId()}))}),this.logger=v(i,this.name),this.heartbeat=new yi,this.crypto=new Vt(this,this.logger,e?.keychain),this.history=new ii(this,this.logger),this.expirer=new si(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new pi(di(di({},ot),e?.storageOptions)),this.relayer=new Wt({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new ti(this,this.logger),this.verify=new ni(this,this.logger,this.storage),this.echoClient=new oi(this.projectId||"",this.logger),this.eventClient=new ci(this,this.logger,e?.telemetryEnabled)}static async init(e){const t=new oe(e);await t.initialize();const s=await t.crypto.getClientId();return await t.storage.setItem(vt,s),t}get context(){return C(this.logger)}async start(){this.initialized||await this.initialize()}async getLogsBlob(){var e;return(e=this.logChunkController)==null?void 0:e.logsToBlob({clientId:await this.crypto.getClientId()})}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const vn=oe;export{ne as CORE_CONTEXT,nt as CORE_DEFAULT,fe as CORE_PROTOCOL,ot as CORE_STORAGE_OPTIONS,O as CORE_STORAGE_PREFIX,_e as CORE_VERSION,Ee as CRYPTO_CLIENT_SEED,at as CRYPTO_CONTEXT,ht as CRYPTO_JWT_TTL,vn as Core,Vt as Crypto,$t as ECHO_CONTEXT,Ft as ECHO_URL,kt as EVENTS_CLIENT_API_URL,Mt as EVENTS_STORAGE_CLEANUP_INTERVAL,Kt as EVENTS_STORAGE_CONTEXT,Ut as EVENTS_STORAGE_VERSION,jr as EVENT_CLIENT_AUTHENTICATE_ERRORS,Vr as EVENT_CLIENT_AUTHENTICATE_TRACES,Mr as EVENT_CLIENT_CONTEXT,F as EVENT_CLIENT_PAIRING_ERRORS,L as EVENT_CLIENT_PAIRING_TRACES,Br as EVENT_CLIENT_SESSION_ERRORS,kr as EVENT_CLIENT_SESSION_TRACES,xt as EXPIRER_CONTEXT,Ur as EXPIRER_DEFAULT_TTL,R as EXPIRER_EVENTS,Ot as EXPIRER_STORAGE_VERSION,oi as EchoClient,ci as EventClient,si as Expirer,Pt as HISTORY_CONTEXT,P as HISTORY_EVENTS,Rt as HISTORY_STORAGE_VERSION,ii as JsonRpcHistory,ct as KEYCHAIN_CONTEXT,lt as KEYCHAIN_STORAGE_VERSION,Bt as KeyChain,ut as MESSAGES_CONTEXT,dt as MESSAGES_STORAGE_VERSION,jt as MessageTracker,Ct as PAIRING_CONTEXT,Fr as PAIRING_DEFAULT_TTL,J as PAIRING_EVENTS,V as PAIRING_RPC_OPTS,St as PAIRING_STORAGE_VERSION,Tt as PENDING_SUB_RESOLUTION_TIMEOUT,pt as PUBLISHER_CONTEXT,gt as PUBLISHER_DEFAULT_TTL,ti as Pairing,bt as RELAYER_CONTEXT,Dt as RELAYER_DEFAULT_LOGGER,yt as RELAYER_DEFAULT_PROTOCOL,ve as RELAYER_DEFAULT_RELAY_URL,w as RELAYER_EVENTS,I as RELAYER_PROVIDER_EVENTS,ft as RELAYER_RECONNECT_TIMEOUT,we as RELAYER_SDK_VERSION,Lr as RELAYER_STORAGE_OPTIONS,mt as RELAYER_SUBSCRIBER_SUFFIX,_t as RELAYER_TRANSPORT_CUTOFF,Wt as Relayer,Et as STORE_STORAGE_VERSION,wt as SUBSCRIBER_CONTEXT,$r as SUBSCRIBER_DEFAULT_TTL,A as SUBSCRIBER_EVENTS,It as SUBSCRIBER_STORAGE_VERSION,ei as Store,Ht as Subscriber,Lt as TRUSTED_VERIFY_URLS,At as VERIFY_CONTEXT,W as VERIFY_SERVER,zt as VERIFY_SERVER_V3,ni as Verify,vt as WALLETCONNECT_CLIENT_ID,oe as default};
//# sourceMappingURL=index.es.js.map
