{"version":3,"file":"static/js/54863.1ea26a86.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/utils/base58/alphabet.ts","../node_modules/thirdweb/src/utils/base58/encode.ts","../node_modules/thirdweb/src/utils/bytecode/cbor-decode.ts","../node_modules/thirdweb/src/utils/bytecode/extractIPFS.ts","../node_modules/thirdweb/src/utils/bytecode/prefix.ts"],"sourcesContent":["export const ALPHABET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\" as const;\n","import { ALPHABET } from \"./alphabet.js\";\n\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source: Uint8Array): string {\n  if (!(source instanceof Uint8Array)) {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n  if (source.length === 0) {\n    return \"\";\n  }\n  // Skip & count leading zeroes.\n  let zeroes = 0;\n  let length = 0;\n  let pbegin = 0;\n  const pend = source.length;\n  while (pbegin !== pend && source[pbegin] === 0) {\n    pbegin++;\n    zeroes++;\n  }\n  // Allocate enough space in big-endian base58 representation.\n  const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n  const b58 = new Uint8Array(size);\n  // Process the bytes.\n  while (pbegin !== pend) {\n    let carry = source[pbegin] || 0;\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (\n      let it1 = size - 1;\n      (carry !== 0 || i < length) && it1 !== -1;\n      it1--, i++\n    ) {\n      carry += (256 * (b58[it1] || 0)) >>> 0;\n      b58[it1] = (carry % BASE) >>> 0;\n      carry = (carry / BASE) >>> 0;\n    }\n    if (carry !== 0) {\n      throw new Error(\"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n  // Skip leading zeroes in base58 result.\n  let it2 = size - length;\n  while (it2 !== size && b58[it2] === 0) {\n    it2++;\n  }\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it2 < size; ++it2) {\n    str += ALPHABET.charAt(b58[it2] || 0);\n  }\n  return str;\n}\n","// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n\n// TODO: re-enable typescript and properly type this\n\n// @ts-nocheck - TODO: re-enable typescript and properly type this\n\nlet src;\nlet srcEnd;\nlet position = 0;\n\nconst EMPTY_ARRAY = [];\n\nlet strings = EMPTY_ARRAY;\n\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\n\nlet packedValues;\n\nlet dataView;\n\nconst defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true,\n};\n\nfunction readFixedString(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\n\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n\n  decodeKey(key) {\n    return key;\n  }\n\n  decode(source, end? = -1) {\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView =\n        source.dataView ||\n        (source.dataView = new DataView(\n          source.buffer,\n          source.byteOffset,\n          source.byteLength,\n        ));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\n        `Source must be a Uint8Array or Buffer but was a ${source && typeof source === \"object\"\n            ? source.constructor.name\n            : typeof source}`,\n      );\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues =\n        this.sharedValues &&\n        (this.pack\n          ? new Array(this.maxPrivatePackedValues || 16).concat(\n              this.sharedValues,\n            )\n          : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\n\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (\n      error instanceof RangeError ||\n      error.message.startsWith(\"Unexpected end of buffer\")\n    ) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\n\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n\n      default:\n        throw new Error(`Unknown token ${token}`);\n    }\n  }\n  switch (majorType) {\n    case 0: // positive int\n      return token;\n    case 1: // negative int\n      return ~token;\n    case 2: // buffer\n      return readBin(token);\n    case 3: // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(\n          position - srcStringStart,\n          (position += token) - srcStringStart,\n        );\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string =\n          token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4: { // array\n      const array = new Array(token);\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    }\n\n    case 5: { // map\n      const object = {};\n      for (let i = 0; i < token; i++) {\n        object[safeKey(read())] = read();\n      }\n      return object;\n    }\n    default: // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(`Unknown CBOR token ${token}`);\n  }\n}\n\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`);\n}\n\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n        const a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n    }\n      const a = src[position++];\n      const b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      const c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n  }\n    const a = src[position++];\n    const b = src[position++];\n    const c = src[position++];\n    const d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      }\n        const e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n    }if (length < 8) {\n      const e = src[position++];\n      const f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      const g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    }\n      const e = src[position++];\n      const f = src[position++];\n      const g = src[position++];\n      const h = src[position++];\n      if (\n        (e & 0x80) > 0 ||\n        (f & 0x80) > 0 ||\n        (g & 0x80) > 0 ||\n        (h & 0x80) > 0\n      ) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        }\n          const i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n      }if (length < 12) {\n        const i = src[position++];\n        const j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        const k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      }\n        const i = src[position++];\n        const j = src[position++];\n        const k = src[position++];\n        const l = src[position++];\n        if (\n          (i & 0x80) > 0 ||\n          (j & 0x80) > 0 ||\n          (k & 0x80) > 0 ||\n          (l & 0x80) > 0\n        ) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          }\n            const m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n        }\n          const m = src[position++];\n          const n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          const o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\n\nfunction readBin(length) {\n  return currentDecoder.copyBuffers\n    ? // specifically use the copying slice (not the node one)\n      Uint8Array.prototype.slice.call(src, position, (position += length))\n    : src.subarray(position, (position += length));\n}\n\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues\n    ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n    : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\n\ncurrentExtensions[28] = (read_) => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n\n  const refEntry = { target }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */ (() =>\n    Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;","import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode: string): string | undefined {\n  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n\n  const cborLength =\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 1];\n  const cborStart = numericBytecode.length - 2 - cborLength;\n  // if the cborStart is invalid, return undefined\n  if (cborStart < 0 || cborStart > numericBytecode.length) {\n    return undefined;\n  }\n  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData) {\n    return `ipfs://${base58Encode(cborData.ipfs)}`;\n  }\n\n  return undefined;\n}\n","import { type Hex, isHex } from \"../encoding/hex.js\";\n\n/**\n * Ensures that the given bytecode has the correct prefix.\n * If the bytecode already starts with \"0x\", it is returned as is.\n * Otherwise, the prefix \"0x\" is added to the bytecode.\n * @param bytecode - The bytecode to ensure the prefix for.\n * @returns The bytecode with the correct prefix.\n * @example\n * ```ts\n * import { ensureBytecodePrefix } from \"thirdweb/utils/bytecode/prefix\";\n * const bytecode = \"363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const prefixedBytecode = ensureBytecodePrefix(bytecode);\n * console.log(prefixedBytecode);\n * ```\n * @utils\n */\nexport function ensureBytecodePrefix(bytecode: string): Hex {\n  if (isHex(bytecode, { strict: false })) {\n    return bytecode;\n  }\n  return `0x${bytecode}`;\n}\n"],"names":["ALPHABET","BASE","length","LEADER","charAt","iFACTOR","Math","log","src","srcEnd","position","EMPTY_ARRAY","currentStructures","srcString","strings","stringPosition","currentDecoder","srcStringStart","bundledStrings","referenceMap","srcStringEnd","currentExtensions","packedValues","dataView","defaultOptions","useRecords","mapsAsObjects","Decoder","constructor","Object","assign","this","decodeKey","key","decode","source","end","arguments","undefined","DataView","buffer","byteOffset","byteLength","error","Uint8Array","Error","name","sharedValues","pack","Array","maxPrivatePackedValues","concat","result","read","postBundlePosition","incomplete","RangeError","message","startsWith","checkedRead","token","majorType","copyBuffers","prototype","slice","call","subarray","string","shortStringInJS","start","bytes","i","byte","fromCharCode","apply","String","longStringInJS","decoder","units","byte1","push","byte2","byte3","unit","readFixedString","array","object","safeKey","Number","isNaN","toString","a","b","c","d","e","f","g","h","j","k","l","m","n","o","glbl","RegExp","data","read_","Map","id","target","refEntry","set","targetProperties","used","mult10","floor","extractIPFSUri","bytecode","numericBytecode","hexToBytes","isHex","strict","ensureBytecodePrefix","cborLength","cborStart","bytecodeBuffer","cborData","TypeError","zeroes","pbegin","pend","size","b58","carry","it1","it2","str","repeat","base58Encode","ipfs"],"sourceRoot":""}