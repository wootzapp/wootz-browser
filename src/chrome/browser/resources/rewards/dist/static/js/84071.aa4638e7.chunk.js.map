{"version":3,"file":"static/js/84071.aa4638e7.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/node_modules/viem/constants/unit.ts","../node_modules/thirdweb/node_modules/viem/utils/unit/formatUnits.ts","../node_modules/thirdweb/node_modules/viem/utils/unit/formatGwei.ts","../node_modules/thirdweb/node_modules/viem/errors/transaction.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/blobsToCommitments.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/blobsToProofs.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/commitmentToVersionedHash.ts","../node_modules/thirdweb/node_modules/viem/constants/blob.ts","../node_modules/thirdweb/node_modules/viem/constants/kzg.ts","../node_modules/thirdweb/node_modules/viem/errors/blob.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/toBlobSidecars.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/toBlobs.ts","../node_modules/thirdweb/node_modules/viem/errors/chain.ts","../node_modules/thirdweb/node_modules/viem/errors/node.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/assertTransaction.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/serializeAccessList.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/serializeTransaction.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/getTransactionType.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/commitmentsToVersionedHashes.ts","../node_modules/thirdweb/node_modules/viem/experimental/eip7702/utils/serializeAuthorizationList.ts","../node_modules/thirdweb/src/gas/estimate-l1-fee.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toRlp.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/sha256.ts"],"sourcesContent":["export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n","import type { ErrorType } from '../../errors/utils.js'\n\nexport type FormatUnitsErrorType = ErrorType\n\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits\n *\n * @example\n * import { formatUnits } from 'viem'\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nexport function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n","import { gweiUnits } from '../../constants/unit.js'\n\nimport { type FormatUnitsErrorType, formatUnits } from './formatUnits.js'\n\nexport type FormatGweiErrorType = FormatUnitsErrorType\n\n/**\n * Converts numerical wei to a string representation of gwei.\n *\n * - Docs: https://viem.sh/docs/utilities/formatGwei\n *\n * @example\n * import { formatGwei } from 'viem'\n *\n * formatGwei(1000000000n)\n * // '1'\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n","import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type { TransactionType } from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport type FeeConflictErrorType = FeeConflictError & {\n  name: 'FeeConflictError'\n}\nexport class FeeConflictError extends BaseError {\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n      { name: 'FeeConflictError' },\n    )\n  }\n}\n\nexport type InvalidLegacyVErrorType = InvalidLegacyVError & {\n  name: 'InvalidLegacyVError'\n}\nexport class InvalidLegacyVError extends BaseError {\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`, {\n      name: 'InvalidLegacyVError',\n    })\n  }\n}\n\nexport type InvalidSerializableTransactionErrorType =\n  InvalidSerializableTransactionError & {\n    name: 'InvalidSerializableTransactionError'\n  }\nexport class InvalidSerializableTransactionError extends BaseError {\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',\n        '- an EIP-7702 Transaction with `authorizationList`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n      name: 'InvalidSerializableTransactionError',\n    })\n  }\n}\n\nexport type InvalidSerializedTransactionTypeErrorType =\n  InvalidSerializedTransactionTypeError & {\n    name: 'InvalidSerializedTransactionTypeError'\n  }\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`, {\n      name: 'InvalidSerializedTransactionType',\n    })\n\n    this.serializedType = serializedType\n  }\n}\n\nexport type InvalidSerializedTransactionErrorType =\n  InvalidSerializedTransactionError & {\n    name: 'InvalidSerializedTransactionError'\n  }\nexport class InvalidSerializedTransactionError extends BaseError {\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n      name: 'InvalidSerializedTransactionError',\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport type InvalidStorageKeySizeErrorType = InvalidStorageKeySizeError & {\n  name: 'InvalidStorageKeySizeError'\n}\nexport class InvalidStorageKeySizeError extends BaseError {\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n      { name: 'InvalidStorageKeySizeError' },\n    )\n  }\n}\n\nexport type TransactionExecutionErrorType = TransactionExecutionError & {\n  name: 'TransactionExecutionError'\n}\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account\n      chain?: Chain | undefined\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'TransactionExecutionError',\n    })\n    this.cause = cause\n  }\n}\n\nexport type TransactionNotFoundErrorType = TransactionNotFoundError & {\n  name: 'TransactionNotFoundError'\n}\nexport class TransactionNotFoundError extends BaseError {\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash | undefined\n    blockNumber?: bigint | undefined\n    blockTag?: BlockTag | undefined\n    hash?: Hash | undefined\n    index?: number | undefined\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`, {\n      name: 'TransactionNotFoundError',\n    })\n  }\n}\n\nexport type TransactionReceiptNotFoundErrorType =\n  TransactionReceiptNotFoundError & {\n    name: 'TransactionReceiptNotFoundError'\n  }\nexport class TransactionReceiptNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n      {\n        name: 'TransactionReceiptNotFoundError',\n      },\n    )\n  }\n}\n\nexport type WaitForTransactionReceiptTimeoutErrorType =\n  WaitForTransactionReceiptTimeoutError & {\n    name: 'WaitForTransactionReceiptTimeoutError'\n  }\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n      { name: 'WaitForTransactionReceiptTimeoutError' },\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\nexport const versionedHashVersionKzg = 1\n","import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n      name: 'BlobSizeTooLargeError',\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  constructor() {\n    super('Blob data must not be empty.', { name: 'EmptyBlobError' })\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n      name: 'InvalidVersionedHashSizeError',\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n      name: 'InvalidVersionedHashVersionError',\n    })\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n","import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type CreateCursorErrorType, createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | CreateCursorErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n","import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport type ChainDoesNotSupportContractErrorType =\n  ChainDoesNotSupportContract & {\n    name: 'ChainDoesNotSupportContract'\n  }\nexport class ChainDoesNotSupportContract extends BaseError {\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint | undefined\n    chain: Chain\n    contract: { name: string; blockCreated?: number | undefined }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n        name: 'ChainDoesNotSupportContract',\n      },\n    )\n  }\n}\n\nexport type ChainMismatchErrorType = ChainMismatchError & {\n  name: 'ChainMismatchError'\n}\nexport class ChainMismatchError extends BaseError {\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id} – ${chain.name}`,\n        ],\n        name: 'ChainMismatchError',\n      },\n    )\n  }\n}\n\nexport type ChainNotFoundErrorType = ChainNotFoundError & {\n  name: 'ChainNotFoundError'\n}\nexport class ChainNotFoundError extends BaseError {\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n      {\n        name: 'ChainNotFoundError',\n      },\n    )\n  }\n}\n\nexport type ClientChainNotConfiguredErrorType =\n  ClientChainNotConfiguredError & {\n    name: 'ClientChainNotConfiguredError'\n  }\nexport class ClientChainNotConfiguredError extends BaseError {\n  constructor() {\n    super('No chain was provided to the Client.', {\n      name: 'ClientChainNotConfiguredError',\n    })\n  }\n}\n\nexport type InvalidChainIdErrorType = InvalidChainIdError & {\n  name: 'InvalidChainIdError'\n}\nexport class InvalidChainIdError extends BaseError {\n  constructor({ chainId }: { chainId?: number | undefined }) {\n    super(\n      typeof chainId === 'number'\n        ? `Chain ID \"${chainId}\" is invalid.`\n        : 'Chain ID is invalid.',\n      { name: 'InvalidChainIdError' },\n    )\n  }\n}\n","import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: 3\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError | undefined; message?: string | undefined } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n        name: 'ExecutionRevertedError',\n      },\n    )\n  }\n}\n\nexport type FeeCapTooHighErrorType = FeeCapTooHighError & {\n  name: 'FeeCapTooHighError'\n}\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n        name: 'FeeCapTooHighError',\n      },\n    )\n  }\n}\n\nexport type FeeCapTooLowErrorType = FeeCapTooLowError & {\n  name: 'FeeCapTooLowError'\n}\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n        name: 'FeeCapTooLowError',\n      },\n    )\n  }\n}\n\nexport type NonceTooHighErrorType = NonceTooHighError & {\n  name: 'NonceTooHighError'\n}\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause, name: 'NonceTooHighError' },\n    )\n  }\n}\n\nexport type NonceTooLowErrorType = NonceTooLowError & {\n  name: 'NonceTooLowError'\n}\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage =\n    /nonce too low|transaction already imported|already known/\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause, name: 'NonceTooLowError' },\n    )\n  }\n}\n\nexport type NonceMaxValueErrorType = NonceMaxValueError & {\n  name: 'NonceMaxValueError'\n}\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause, name: 'NonceMaxValueError' },\n    )\n  }\n}\n\nexport type InsufficientFundsErrorType = InsufficientFundsError & {\n  name: 'InsufficientFundsError'\n}\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage =\n    /insufficient funds|exceeds transaction sender account balance/\n  constructor({ cause }: { cause?: BaseError | undefined } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n        name: 'InsufficientFundsError',\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooHighErrorType = IntrinsicGasTooHighError & {\n  name: 'IntrinsicGasTooHighError'\n}\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n        name: 'IntrinsicGasTooHighError',\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooLowErrorType = IntrinsicGasTooLowError & {\n  name: 'IntrinsicGasTooLowError'\n}\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n        name: 'IntrinsicGasTooLowError',\n      },\n    )\n  }\n}\n\nexport type TransactionTypeNotSupportedErrorType =\n  TransactionTypeNotSupportedError & {\n    name: 'TransactionTypeNotSupportedError'\n  }\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n      name: 'TransactionTypeNotSupportedError',\n    })\n  }\n}\n\nexport type TipAboveFeeCapErrorType = TipAboveFeeCapError & {\n  name: 'TipAboveFeeCapError'\n}\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxPriorityFeePerGas?: bigint | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n        name: 'TipAboveFeeCapError',\n      },\n    )\n  }\n}\n\nexport type UnknownNodeErrorType = UnknownNodeError & {\n  name: 'UnknownNodeError'\n}\nexport class UnknownNodeError extends BaseError {\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(`An error occurred while executing: ${cause?.shortMessage}`, {\n      cause,\n      name: 'UnknownNodeError',\n    })\n  }\n}\n","import { versionedHashVersionKzg } from '../../constants/kzg.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n  InvalidVersionedHashSizeError,\n  type InvalidVersionedHashSizeErrorType,\n  InvalidVersionedHashVersionError,\n  type InvalidVersionedHashVersionErrorType,\n} from '../../errors/blob.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nexport type AssertTransactionEIP7702ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | ErrorType\n\nexport function assertTransactionEIP7702(\n  transaction: TransactionSerializableEIP7702,\n) {\n  const { authorizationList } = transaction\n  if (authorizationList) {\n    for (const authorization of authorizationList) {\n      const { contractAddress, chainId } = authorization\n      if (!isAddress(contractAddress))\n        throw new InvalidAddressError({ address: contractAddress })\n      if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP4844ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | EmptyBlobErrorType\n  | InvalidVersionedHashSizeErrorType\n  | InvalidVersionedHashVersionErrorType\n  | ErrorType\n\nexport function assertTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n) {\n  const { blobVersionedHashes } = transaction\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\n    for (const hash of blobVersionedHashes) {\n      const size_ = size(hash)\n      const version = hexToNumber(slice(hash, 0, 1))\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\n      if (version !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList | undefined,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n","import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  Signature,\n  SignatureLegacy,\n} from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedEIP7702,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from '../blob/blobsToCommitments.js'\nimport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n} from '../blob/blobsToProofs.js'\nimport {\n  type CommitmentsToVersionedHashesErrorType,\n  commitmentsToVersionedHashes,\n} from '../blob/commitmentsToVersionedHashes.js'\nimport {\n  type ToBlobSidecarsErrorType,\n  toBlobSidecars,\n} from '../blob/toBlobSidecars.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type SerializeAuthorizationListErrorType,\n  serializeAuthorizationList,\n} from '../../experimental/eip7702/utils/serializeAuthorizationList.js'\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionEIP7702ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionEIP7702,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransactionTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  transaction extends TransactionSerializable = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n> = TransactionSerialized<_transactionType>\n\nexport type SerializeTransactionFn<\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = never,\n> = typeof serializeTransaction<\n  OneOf<TransactionSerializable | transaction>,\n  _transactionType\n>\n\nexport type SerializeTransactionErrorType =\n  | GetTransactionTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionEIP4844ErrorType\n  | SerializeTransactionEIP7702ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  const transaction extends TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n>(\n  transaction: transaction,\n  signature?: Signature | undefined,\n): SerializedTransactionReturnType<transaction, _transactionType> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip4844')\n    return serializeTransactionEIP4844(\n      transaction as TransactionSerializableEIP4844,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip7702')\n    return serializeTransactionEIP7702(\n      transaction as TransactionSerializableEIP7702,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature as SignatureLegacy,\n  ) as SerializedTransactionReturnType<transaction>\n}\n\ntype SerializeTransactionEIP7702ErrorType =\n  | AssertTransactionEIP7702ErrorType\n  | SerializeAuthorizationListErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP7702(\n  transaction: TransactionSerializableEIP7702,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP7702 {\n  const {\n    authorizationList,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP7702(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n  const serializedAuthorizationList =\n    serializeAuthorizationList(authorizationList)\n\n  return concatHex([\n    '0x04',\n    toRlp([\n      toHex(chainId),\n      nonce ? toHex(nonce) : '0x',\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n      maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n      gas ? toHex(gas) : '0x',\n      to ?? '0x',\n      value ? toHex(value) : '0x',\n      data ?? '0x',\n      serializedAccessList,\n      serializedAuthorizationList,\n      ...toYParitySignatureArray(transaction, signature),\n    ]),\n  ]) as TransactionSerializedEIP7702\n}\n\ntype SerializeTransactionEIP4844ErrorType =\n  | AssertTransactionEIP4844ErrorType\n  | BlobsToCommitmentsErrorType\n  | CommitmentsToVersionedHashesErrorType\n  | blobsToProofsErrorType\n  | ToBlobSidecarsErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP4844 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP4844(transaction)\n\n  let blobVersionedHashes = transaction.blobVersionedHashes\n  let sidecars = transaction.sidecars\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (\n    transaction.blobs &&\n    (typeof blobVersionedHashes === 'undefined' ||\n      typeof sidecars === 'undefined')\n  ) {\n    const blobs = (\n      typeof transaction.blobs[0] === 'string'\n        ? transaction.blobs\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\n    ) as Hex[]\n    const kzg = transaction.kzg!\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg,\n    })\n\n    if (typeof blobVersionedHashes === 'undefined')\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments,\n      })\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\n    }\n  }\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature),\n  ] as const\n\n  const blobs: Hex[] = []\n  const commitments: Hex[] = []\n  const proofs: Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return concatHex([\n    '0x03',\n    sidecars\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\n        toRlp([serializedTransaction, blobs, commitments, proofs])\n      : // If sidecars are disabled, standard envelope is used:\n        toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP4844\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: SignatureLegacy | undefined,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    const r = trim(signature.r)\n    const s = trim(signature.s)\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      r === '0x00' ? '0x' : r,\n      s === '0x00' ? '0x' : s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\n}\n\nexport function toYParitySignatureArray(\n  transaction: TransactionSerializableGeneric,\n  signature_?: Signature | undefined,\n) {\n  const signature = signature_ ?? transaction\n  const { v, yParity } = signature\n\n  if (typeof signature.r === 'undefined') return []\n  if (typeof signature.s === 'undefined') return []\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\n\n  const r = trim(signature.r)\n  const s = trim(signature.s)\n\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\n    if (v === 0n) return '0x'\n    if (v === 1n) return toHex(1)\n\n    return v === 27n ? '0x' : toHex(1)\n  })()\n\n  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s]\n}\n","import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestEIP7702,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableEIP7702,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport type {\n  Assign,\n  ExactPartial,\n  IsNever,\n  OneOf,\n  ValueOf,\n} from '../../types/utils.js'\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends\n        | MatchKeys<TransactionSerializableLegacy, transaction>\n        | MatchKeys<TransactionRequestLegacy, transaction>\n        | LegacyProperties\n        ? 'legacy'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP1559, transaction>\n        | MatchKeys<TransactionRequestEIP1559, transaction>\n        | EIP1559Properties\n        ? 'eip1559'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP2930, transaction>\n        | MatchKeys<TransactionRequestEIP2930, transaction>\n        | EIP2930Properties\n        ? 'eip2930'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP4844, transaction>\n        | MatchKeys<TransactionRequestEIP4844, transaction>\n        | EIP4844Properties\n        ? 'eip4844'\n        : never)\n    | (transaction extends\n        | MatchKeys<TransactionSerializableEIP7702, transaction>\n        | MatchKeys<TransactionRequestEIP7702, transaction>\n        | EIP7702Properties\n        ? 'eip7702'\n        : never)\n    | (transaction['type'] extends TransactionSerializableGeneric['type']\n        ? Extract<transaction['type'], string>\n        : never),\n> = IsNever<keyof transaction> extends true\n  ? string\n  : IsNever<result> extends false\n    ? result\n    : string\n\nexport type GetTransactionTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (typeof transaction.authorizationList !== 'undefined')\n    return 'eip7702' as any\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype MatchKeys<T extends object, U extends object> = ValueOf<\n  Required<{\n    [K in keyof U]: K extends keyof T ? K : undefined\n  }>\n> extends string\n  ? T\n  : never\n\ntype BaseProperties = {\n  accessList?: undefined\n  authorizationList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesLegacy> & {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\ntype EIP7702Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP1559> & {\n    authorizationList: TransactionSerializableEIP7702['authorizationList']\n  }\n>\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport { toHex } from '../../../utils/encoding/toHex.js'\nimport { toYParitySignatureArray } from '../../../utils/transaction/serializeTransaction.js'\nimport type {\n  AuthorizationList,\n  SerializedAuthorizationList,\n} from '../types/authorization.js'\n\nexport type SerializeAuthorizationListReturnType = SerializedAuthorizationList\n\nexport type SerializeAuthorizationListErrorType = ErrorType\n\n/*\n * Serializes an EIP-7702 authorization list.\n */\nexport function serializeAuthorizationList(\n  authorizationList?: AuthorizationList<number, true> | undefined,\n): SerializeAuthorizationListReturnType {\n  if (!authorizationList || authorizationList.length === 0) return []\n\n  const serializedAuthorizationList = []\n  for (const authorization of authorizationList) {\n    const { contractAddress, chainId, nonce, ...signature } = authorization\n    serializedAuthorizationList.push([\n      toHex(chainId),\n      contractAddress,\n      toHex(nonce),\n      ...toYParitySignatureArray({}, signature),\n    ])\n  }\n\n  return serializedAuthorizationList as {} as SerializeAuthorizationListReturnType\n}\n","import { serializeTransaction } from \"viem\";\nimport { getContract } from \"../contract/contract.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { readContract } from \"../transaction/read-contract.js\";\n\nexport type EstimateL1FeeOptions = {\n  transaction: PreparedTransaction;\n  gasPriceOracleAddress?: string;\n};\n\nconst OPStackGasPriceOracleAddress =\n  \"0x420000000000000000000000000000000000000F\";\n\n/**\n * @internal\n */\nexport async function estimateL1Fee(options: EstimateL1FeeOptions) {\n  const { transaction, gasPriceOracleAddress } = options;\n  const oracleContract = getContract({\n    client: transaction.client,\n    address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n    chain: transaction.chain,\n  });\n\n  // purposefully remove gasPrice from the transaction\n\n  const { gasPrice, ...serializableTx } = await toSerializableTransaction({\n    transaction,\n  });\n  const serialized = serializeTransaction({\n    ...serializableTx,\n    type: \"eip1559\",\n  });\n  //serializeTransaction(transaction);\n  return readContract({\n    contract: oracleContract,\n    method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n    params: [serialized],\n  });\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n"],"names":["gweiUnits","ether","wei","formatUnits","value","decimals","display","toString","negative","startsWith","slice","padStart","integer","fraction","length","replace","formatGwei","arguments","undefined","prettyPrint","args","entries","Object","map","_ref","key","filter","Boolean","maxLength","reduce","acc","_ref2","Math","max","_ref3","padEnd","join","BaseError","InvalidLegacyVError","constructor","_ref4","v","super","name","InvalidSerializableTransactionError","_ref5","transaction","metaMessages","InvalidStorageKeySizeError","_ref9","storageKey","floor","blobsToCommitments","parameters","kzg","to","blobs","x","hexToBytes","commitments","blob","push","Uint8Array","from","blobToKzgCommitment","bytesToHex","blobsToProofs","proofs","i","commitment","computeBlobKzgProof","commitmentToVersionedHash","version","versionedHash","sha256","set","bytesPerFieldElement","fieldElementsPerBlob","bytesPerBlob","maxBytesPerTransaction","versionedHashVersionKzg","BlobSizeTooLargeError","maxSize","size","EmptyBlobError","InvalidVersionedHashSizeError","hash","InvalidVersionedHashVersionError","toBlobSidecars","data","size_","active","position","createCursor","bytes","pushByte","pushBytes","toBlobs","sidecars","proof","InvalidChainIdError","chainId","ExecutionRevertedError","cause","message","reason","defineProperty","FeeCapTooHighError","maxFeePerGas","FeeCapTooLowError","NonceTooHighError","nonce","NonceTooLowError","NonceMaxValueError","InsufficientFundsError","IntrinsicGasTooHighError","gas","IntrinsicGasTooLowError","TransactionTypeNotSupportedError","TipAboveFeeCapError","maxPriorityFeePerGas","assertTransactionEIP1559","isAddress","InvalidAddressError","address","serializeAccessList","accessList","serializedAccessList","storageKeys","j","strict","serializeTransaction","signature","type","authorizationList","blobVersionedHashes","maxFeePerBlobGas","gasPrice","getTransactionType","serializedTransaction","toHex","toYParitySignatureArray","concatHex","toRlp","serializeTransactionEIP1559","assertTransactionEIP2930","serializeTransactionEIP2930","hexToNumber","assertTransactionEIP4844","hashes","commitmentsToVersionedHashes","serializeTransactionEIP4844","authorization","contractAddress","assertTransactionEIP7702","serializedAuthorizationList","serializeAuthorizationList","serializeTransactionEIP7702","assertTransactionLegacy","BigInt","r","trim","s","serializeTransactionLegacy","signature_","yParity","OPStackGasPriceOracleAddress","async","estimateL1Fee","options","gasPriceOracleAddress","oracleContract","getContract","client","chain","serializableTx","toSerializableTransaction","serialized","readContract","contract","method","params","encodable","getEncodable","cursor","encode","Array","isArray","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","getEncodableBytes","to_","noble_sha256","isHex","toBytes"],"sourceRoot":""}