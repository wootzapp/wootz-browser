{"version":3,"file":"static/js/78608.0aa57af2.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/node_modules/viem/errors/request.ts","../node_modules/thirdweb/node_modules/viem/errors/rpc.ts","../node_modules/thirdweb/src/wallets/wallet-connect/controller.ts"],"sourcesContent":["import { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type HttpRequestErrorType = HttpRequestError & {\n  name: 'HttpRequestError'\n}\nexport class HttpRequestError extends BaseError {\n  body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined\n  headers?: Headers | undefined\n  status?: number | undefined\n  url: string\n\n  constructor({\n    body,\n    cause,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined\n    cause?: Error | undefined\n    details?: string | undefined\n    headers?: Headers | undefined\n    status?: number | undefined\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      cause,\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n      name: 'HttpRequestError',\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport type WebSocketRequestErrorType = WebSocketRequestError & {\n  name: 'WebSocketRequestError'\n}\nexport class WebSocketRequestError extends BaseError {\n  constructor({\n    body,\n    cause,\n    details,\n    url,\n  }: {\n    body?: { [key: string]: unknown } | undefined\n    cause?: Error | undefined\n    details?: string | undefined\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      cause,\n      details,\n      metaMessages: [\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n      name: 'WebSocketRequestError',\n    })\n  }\n}\n\nexport type RpcRequestErrorType = RpcRequestError & {\n  name: 'RpcRequestError'\n}\nexport class RpcRequestError extends BaseError {\n  code: number\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n      name: 'RpcRequestError',\n    })\n    this.code = error.code\n  }\n}\n\nexport type SocketClosedErrorType = SocketClosedError & {\n  name: 'SocketClosedError'\n}\nexport class SocketClosedError extends BaseError {\n  constructor({\n    url,\n  }: {\n    url?: string | undefined\n  } = {}) {\n    super('The socket has been closed.', {\n      metaMessages: [url && `URL: ${getUrl(url)}`].filter(Boolean) as string[],\n      name: 'SocketClosedError',\n    })\n  }\n}\n\nexport type TimeoutErrorType = TimeoutError & {\n  name: 'TimeoutError'\n}\nexport class TimeoutError extends BaseError {\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n      name: 'TimeoutError',\n    })\n  }\n}\n","import type { Prettify } from '../types/utils.js'\nimport { BaseError } from './base.js'\nimport { RpcRequestError } from './request.js'\n\nconst unknownErrorCode = -1\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042 // Method not found\n\ntype RpcErrorOptions<code extends number = RpcErrorCode> = {\n  code?: code | (number & {}) | undefined\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n  shortMessage: string\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1474\n */\nexport type RpcErrorType = RpcError & { name: 'RpcError' }\nexport class RpcError<code_ extends number = RpcErrorCode> extends BaseError {\n  code: code_ | (number & {})\n\n  constructor(\n    cause: Error,\n    {\n      code,\n      docsPath,\n      metaMessages,\n      name,\n      shortMessage,\n    }: RpcErrorOptions<code_>,\n  ) {\n    super(shortMessage, {\n      cause,\n      docsPath,\n      metaMessages:\n        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n      name: name || 'RpcError',\n    })\n    this.name = name || cause.name\n    this.code = (\n      cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode\n    ) as code_\n  }\n}\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902 // Chain Not Recognized\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1193\n */\nexport type ProviderRpcErrorType = ProviderRpcError & {\n  name: 'ProviderRpcError'\n}\nexport class ProviderRpcError<\n  T = undefined,\n> extends RpcError<ProviderRpcErrorCode> {\n  data?: T | undefined\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T | undefined\n      }\n    >,\n  ) {\n    super(cause, options)\n\n    this.data = options.data\n  }\n}\n\n/**\n * Subclass for a \"Parse error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ParseRpcErrorType = ParseRpcError & {\n  code: -32700\n  name: 'ParseRpcError'\n}\nexport class ParseRpcError extends RpcError {\n  static code = -32700 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ParseRpcError.code,\n      name: 'ParseRpcError',\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Invalid request\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidRequestRpcErrorType = InvalidRequestRpcError & {\n  code: -32600\n  name: 'InvalidRequestRpcError'\n}\nexport class InvalidRequestRpcError extends RpcError {\n  static code = -32600 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidRequestRpcError.code,\n      name: 'InvalidRequestRpcError',\n      shortMessage: 'JSON is not a valid request object.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type MethodNotFoundRpcErrorType = MethodNotFoundRpcError & {\n  code: -32601\n  name: 'MethodNotFoundRpcError'\n}\nexport class MethodNotFoundRpcError extends RpcError {\n  static code = -32601 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: MethodNotFoundRpcError.code,\n      name: 'MethodNotFoundRpcError',\n      shortMessage: `The method${method ? ` \"${method}\"` : ''} does not exist / is not available.`,\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid params\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidParamsRpcErrorType = InvalidParamsRpcError & {\n  code: -32602\n  name: 'InvalidParamsRpcError'\n}\nexport class InvalidParamsRpcError extends RpcError {\n  static code = -32602 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidParamsRpcError.code,\n      name: 'InvalidParamsRpcError',\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for an \"Internal error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InternalRpcErrorType = InternalRpcError & {\n  code: -32603\n  name: 'InternalRpcError'\n}\nexport class InternalRpcError extends RpcError {\n  static code = -32603 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InternalRpcError.code,\n      name: 'InternalRpcError',\n      shortMessage: 'An internal error was received.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid input\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidInputRpcErrorType = InvalidInputRpcError & {\n  code: -32000\n  name: 'InvalidInputRpcError'\n}\nexport class InvalidInputRpcError extends RpcError {\n  static code = -32000 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidInputRpcError.code,\n      name: 'InvalidInputRpcError',\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ResourceNotFoundRpcErrorType = ResourceNotFoundRpcError & {\n  code: -32001\n  name: 'ResourceNotFoundRpcError'\n}\nexport class ResourceNotFoundRpcError extends RpcError {\n  override name = 'ResourceNotFoundRpcError'\n  static code = -32001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceNotFoundRpcError.code,\n      name: 'ResourceNotFoundRpcError',\n      shortMessage: 'Requested resource not found.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource unavailable\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ResourceUnavailableRpcErrorType = ResourceUnavailableRpcError & {\n  code: -32002\n  name: 'ResourceUnavailableRpcError'\n}\nexport class ResourceUnavailableRpcError extends RpcError {\n  static code = -32002 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceUnavailableRpcError.code,\n      name: 'ResourceUnavailableRpcError',\n      shortMessage: 'Requested resource not available.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Transaction rejected\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type TransactionRejectedRpcErrorType = TransactionRejectedRpcError & {\n  code: -32003\n  name: 'TransactionRejectedRpcError'\n}\nexport class TransactionRejectedRpcError extends RpcError {\n  static code = -32003 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: TransactionRejectedRpcError.code,\n      name: 'TransactionRejectedRpcError',\n      shortMessage: 'Transaction creation failed.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type MethodNotSupportedRpcErrorType = MethodNotSupportedRpcError & {\n  code: -32004\n  name: 'MethodNotSupportedRpcError'\n}\nexport class MethodNotSupportedRpcError extends RpcError {\n  static code = -32004 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: MethodNotSupportedRpcError.code,\n      name: 'MethodNotSupportedRpcError',\n      shortMessage: `Method${method ? ` \"${method}\"` : ''} is not implemented.`,\n    })\n  }\n}\n\n/**\n * Subclass for a \"Limit exceeded\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type LimitExceededRpcErrorType = LimitExceededRpcError & {\n  code: -32005\n  name: 'LimitExceededRpcError'\n}\nexport class LimitExceededRpcError extends RpcError {\n  static code = -32005 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: LimitExceededRpcError.code,\n      name: 'LimitExceededRpcError',\n      shortMessage: 'Request exceeds defined limit.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"JSON-RPC version not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type JsonRpcVersionUnsupportedErrorType =\n  JsonRpcVersionUnsupportedError & {\n    code: -32006\n    name: 'JsonRpcVersionUnsupportedError'\n  }\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n  static code = -32006 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: JsonRpcVersionUnsupportedError.code,\n      name: 'JsonRpcVersionUnsupportedError',\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"User Rejected Request\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UserRejectedRequestErrorType = UserRejectedRequestError & {\n  code: 4001\n  name: 'UserRejectedRequestError'\n}\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static code = 4001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UserRejectedRequestError.code,\n      name: 'UserRejectedRequestError',\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnauthorizedProviderErrorType = UnauthorizedProviderError & {\n  code: 4100\n  name: 'UnauthorizedProviderError'\n}\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  static code = 4100 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnauthorizedProviderError.code,\n      name: 'UnauthorizedProviderError',\n      shortMessage:\n        'The requested method and/or account has not been authorized by the user.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnsupportedProviderMethodErrorType =\n  UnsupportedProviderMethodError & {\n    code: 4200\n    name: 'UnsupportedProviderMethodError'\n  }\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  static code = 4200 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: UnsupportedProviderMethodError.code,\n      name: 'UnsupportedProviderMethodError',\n      shortMessage: `The Provider does not support the requested method${method ? ` \" ${method}\"` : ''}.`,\n    })\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ProviderDisconnectedErrorType = ProviderDisconnectedError & {\n  code: 4900\n  name: 'ProviderDisconnectedError'\n}\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  static code = 4900 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ProviderDisconnectedError.code,\n      name: 'ProviderDisconnectedError',\n      shortMessage: 'The Provider is disconnected from all chains.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ChainDisconnectedErrorType = ChainDisconnectedError & {\n  code: 4901\n  name: 'ChainDisconnectedError'\n}\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static code = 4901 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ChainDisconnectedError.code,\n      name: 'ChainDisconnectedError',\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type SwitchChainErrorType = SwitchChainError & {\n  code: 4902\n  name: 'SwitchChainError'\n}\nexport class SwitchChainError extends ProviderRpcError {\n  static code = 4902 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: SwitchChainError.code,\n      name: 'SwitchChainError',\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport type UnknownRpcErrorType = UnknownRpcError & {\n  name: 'UnknownRpcError'\n}\nexport class UnknownRpcError extends RpcError {\n  constructor(cause: Error) {\n    super(cause, {\n      name: 'UnknownRpcError',\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n","import type { EthereumProvider } from \"@walletconnect/ethereum-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport {\n  getCachedChain,\n  getChainMetadata,\n  getRpcUrlForChain,\n} from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\ntype WCProvider = InstanceType<typeof EthereumProvider>;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\n\nconst defaultShowQrModal = true;\n\nconst storageKeys = {\n  requestedChains: \"tw.wc.requestedChains\",\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler && walletId !== \"walletConnect\") {\n    const walletInfo = await getWalletInfo(walletId);\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        throw new Error(\"No app url found for wallet connect to redirect to.\");\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const { rpcMap, chainsToRequest } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  if (provider.session) {\n    await provider.connect({\n      ...(wcOptions?.pairingTopic\n        ? { pairingTopic: wcOptions?.pairingTopic }\n        : {}),\n      optionalChains: chainsToRequest,\n      chains: chainToRequest\n        ? [chainToRequest.id]\n        : chainsToRequest.length > 0\n          ? [chainsToRequest[0]]\n          : [1],\n      rpcMap: rpcMap,\n    });\n  }\n\n  setRequestedChainsIds(chainsToRequest, storage);\n  // If session exists and chains are authorized, enable provider for required chain\n  const addresses = await provider.enable();\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      optionalChains: options.walletConnect?.optionalChains,\n      chain: options.chain,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (wcOptions?.onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n  }\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            pairingTopic: savedConnectParams.pairingTopic,\n            optionalChains: savedConnectParams.optionalChains,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n    true, // is auto connect\n  );\n\n  const address = provider.accounts[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void,\n  isAutoConnect = false,\n) {\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import(\n    \"@walletconnect/ethereum-provider\"\n  );\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const { rpcMap, chainsToRequest } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  const provider = await EthereumProvider.init({\n    showQrModal:\n      wcOptions?.showQrModal === undefined\n        ? sessionRequestHandler\n          ? false\n          : defaultShowQrModal\n        : wcOptions.showQrModal,\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    optionalMethods: OPTIONAL_METHODS,\n    optionalEvents: OPTIONAL_EVENTS,\n    optionalChains: chainsToRequest,\n    chains: chainToRequest\n      ? [chainToRequest.id]\n      : chainsToRequest.length > 0\n        ? [chainsToRequest[0]]\n        : [1],\n    metadata: {\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n    },\n    rpcMap: rpcMap,\n    qrModalOptions: wcOptions?.qrModalOptions,\n    disableProviderPing: true,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  // disconnect the provider if chains are stale when (if not auto connecting)\n  if (!isAutoConnect) {\n    // const isStale = await isChainsStale(provider, chainsToRequest);\n\n    if (provider.session) {\n      await provider.disconnect();\n    }\n  }\n\n  if (walletId !== \"walletConnect\") {\n    function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n    });\n  }\n\n  return provider;\n}\n\nfunction createAccount(provider: WCProvider, _address: string) {\n  const address = getAddress(_address);\n  const account: Account = {\n    address: address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, this.address],\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.address, typedData],\n      });\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount(provider, address);\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, storage),\n  ];\n}\n\n// Storage utils  -----------------------------------------------------------------------------------------------\n\nfunction getNamespaceMethods(provider: WCProvider) {\n  return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\n\nfunction getNamespaceChainsIds(provider: WCProvider): number[] {\n  const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map(\n    (chain) => Number.parseInt(chain.split(\":\")[1] || \"\"),\n  );\n\n  return chainIds ?? [];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  storage: AsyncStorage,\n) {\n  const chainId = chain.id;\n  try {\n    const namespaceChains = getNamespaceChainsIds(provider);\n    const namespaceMethods = getNamespaceMethods(provider);\n    const isChainApproved = namespaceChains.includes(chainId);\n\n    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      const apiChain = await getChainMetadata(chain);\n\n      const blockExplorerUrls = [\n        ...new Set([\n          ...(chain.blockExplorers?.map((x) => x.url) || []),\n          ...(apiChain.explorers?.map((x) => x.url) || []),\n        ]),\n      ];\n\n      await provider.request({\n        method: ADD_ETH_CHAIN_METHOD,\n        params: [\n          {\n            chainId: numberToHex(apiChain.chainId),\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no clientId on purpose\n            blockExplorerUrls:\n              blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined,\n          },\n        ],\n      });\n      const requestedChains = await getRequestedChainsIds(storage);\n      requestedChains.push(chainId);\n      setRequestedChainsIds(requestedChains, storage);\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: numberToHex(chainId) }],\n    });\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains: number[], storage: AsyncStorage) {\n  storage?.setItem(storageKeys.requestedChains, JSON.stringify(chains));\n}\n\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage: AsyncStorage): Promise<number[]> {\n  const data = await storage.getItem(storageKeys.requestedChains);\n  return data ? JSON.parse(data) : [];\n}\n\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}) {\n  const rpcMap: Record<number, string> = {};\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n  }\n\n  const optionalChainIds = optionalChains.map((c) => c.id) || [];\n\n  const chainsToRequest: ArrayOneOrMore<number> = options.chain\n    ? [options.chain.id, ...optionalChainIds]\n    : optionalChainIds.length > 0\n      ? (optionalChainIds as ArrayOneOrMore<number>)\n      : [1];\n\n  if (!options.chain && optionalChains.length === 0) {\n    rpcMap[1] = getCachedChain(1).rpc;\n  }\n\n  return {\n    rpcMap,\n    chainsToRequest,\n  };\n}\n\nconst chainsToRequestForSafe = [\n  1, // Ethereum Mainnet\n  11155111, // Sepolia Testnet\n  42161, // Arbitrum One Mainnet\n  43114, // Avalanche Mainnet\n  8453, // Base Mainnet\n  1313161554, // Aurora Mainnet\n  84532, // Base Sepolia Testnet\n  56, // Binance Smart Chain Mainnet\n  42220, // Celo Mainnet\n  100, // Gnosis Mainnet\n  10, // Optimism Mainnet\n  137, // Polygon Mainnet\n  1101, // Polygon zkEVM Mainnet\n  324, // zkSync Era mainnet\n  534352, // Scroll mainnet\n];\n"],"names":["BaseError","RpcRequestError","constructor","_ref3","body","error","url","super","cause","details","message","metaMessages","stringify","name","Object","defineProperty","this","code","RpcError","_ref","docsPath","shortMessage","ProviderRpcError","options","data","ParseRpcError","InvalidRequestRpcError","MethodNotFoundRpcError","method","arguments","length","undefined","InvalidParamsRpcError","join","InternalRpcError","InvalidInputRpcError","ResourceNotFoundRpcError","ResourceUnavailableRpcError","TransactionRejectedRpcError","MethodNotSupportedRpcError","LimitExceededRpcError","JsonRpcVersionUnsupportedError","UserRejectedRequestError","UnauthorizedProviderError","UnsupportedProviderMethodError","ProviderDisconnectedError","ChainDisconnectedError","SwitchChainError","ADD_ETH_CHAIN_METHOD","defaultShowQrModal","storageKeys","requestedChains","lastUsedChainId","async","connectWC","emitter","walletId","storage","sessionHandler","provider","initProvider","wcOptions","walletConnect","onDisplayUri","walletInfo","getWalletInfo","uri","appUrl","mobile","native","universal","Error","fullUrl","formatWalletConnectUrl","redirect","events","addListener","optionalChains","chainToRequest","chain","chainsToRequestForSafe","map","getCachedChain","includes","rpcMap","chainsToRequest","getChainsToRequest","client","session","connect","pairingTopic","chains","id","setRequestedChainsIds","address","enable","providerChainId","normalizeChainId","chainId","savedParams","saveConnectParamsToStorage","removeListener","onConnect","autoConnectWC","savedConnectParams","getSavedConnectParamsFromStorage","accounts","sessionRequestHandler","isAutoConnect","EthereumProvider","OPTIONAL_EVENTS","OPTIONAL_METHODS","init","showQrModal","projectId","DEFAULT_PROJECT_ID","optionalMethods","optionalEvents","metadata","appMetadata","getDefaultAppMetadata","description","icons","logoUrl","qrModalOptions","disableProviderPing","setMaxListeners","Number","POSITIVE_INFINITY","disconnect","handleSessionRequest","walletLinkToOpen","peer","signer","on","off","createAccount","_address","getAddress","sendTransaction","tx","transactionHash","request","params","gas","numberToHex","value","from","to","signMessage","messageToSign","stringToHex","raw","Uint8Array","uint8ArrayToHex","signTypedData","_data","parseTypedData","domain","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","typedData","serializeTypedData","account","onAccountsChanged","onChainChanged","onDisconnect","removeItem","emit","newAccount","newChainId","newChain","setItem","String","namespaceChains","chainIds","namespaces","NAMESPACE","parseInt","split","getNamespaceChainsIds","namespaceMethods","methods","getNamespaceMethods","apiChain","getChainMetadata","blockExplorerUrls","Set","blockExplorers","x","explorers","chainName","nativeCurrency","rpcUrls","getValidPublicRPCUrl","getItem","JSON","parse","getRequestedChainsIds","push","test","switchChainWC","getRpcUrlForChain","slice","optionalChainIds","c","rpc"],"sourceRoot":""}