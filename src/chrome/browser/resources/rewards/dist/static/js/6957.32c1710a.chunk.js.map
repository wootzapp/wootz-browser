{"version":3,"file":"static/js/6957.32c1710a.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/wallets/injected/index.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport {\n  type SignTypedDataParameters,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport type { Ethereum } from \"../interfaces/ethereum.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { InjectedConnectOptions, WalletId } from \"../wallet-types.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { InjectedSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\n\n/**\n * Checks if the provided wallet is an injected wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an injected wallet, false otherwise.\n */\nexport function isInjectedWallet(wallet: Wallet<WalletId>) {\n  return !!injectedProvider(wallet.id);\n}\n\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId: WalletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n  }\n\n  return provider;\n}\n\n/**\n * @internal\n */\nexport async function connectInjectedWallet(\n  id: InjectedSupportedWalletIds,\n  options: InjectedConnectOptions,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = getInjectedProvider(id);\n  const addresses = await provider.request({\n    method: \"eth_requestAccounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  let connectedChain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n\n  // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n  if (options.chain && options.chain.id !== chainId) {\n    await switchChain(provider, options.chain);\n    connectedChain = options.chain;\n  }\n\n  return onConnect(provider, address, connectedChain, emitter);\n}\n\n/**\n * @internal\n */\nexport async function autoConnectInjectedWallet(\n  id: InjectedSupportedWalletIds,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n  chain?: Chain,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = getInjectedProvider(id);\n\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  const connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  return onConnect(provider, address, connectedChain, emitter);\n}\n\nfunction createAccount(provider: Ethereum, _address: string) {\n  const account: Account = {\n    address: getAddress(_address),\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            accessList: tx.accessList,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address],\n      });\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n\n      const { domain, message, primaryType } =\n        parsedTypedData as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parsedTypedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const stringifiedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData],\n      });\n    },\n    async watchAsset(asset) {\n      const result = await provider.request(\n        {\n          method: \"wallet_watchAsset\",\n          params: asset,\n        },\n        { retryCount: 0 },\n      );\n      return result;\n    },\n  };\n\n  return account;\n}\n\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(\n  provider: Ethereum,\n  address: string,\n  chain: Chain,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n): Promise<[Account, Chain, DisconnectFn, SwitchChainFn]> {\n  const account = createAccount(provider, address);\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n  }\n\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n\n  return [\n    account,\n    chain,\n    onDisconnect,\n    (newChain) => switchChain(provider, newChain),\n  ] as const;\n}\n\n/**\n * @internal\n */\nasync function switchChain(provider: Ethereum, chain: Chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: hexChainId }],\n    });\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (e: any) {\n    // if chain does not exist, add the chain\n    if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {\n      const apiChain = await getChainMetadata(chain);\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            chainId: hexChainId,\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no client id on purpose here\n            blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n          },\n        ],\n      });\n    } else {\n      throw e;\n    }\n  }\n}\n"],"names":["getInjectedProvider","walletId","provider","injectedProvider","Error","async","connectInjectedWallet","id","options","emitter","addr","request","method","address","getAddress","chainId","then","normalizeChainId","connectedChain","chain","getCachedChain","switchChain","onConnect","autoConnectInjectedWallet","createAccount","_address","account","sendTransaction","tx","transactionHash","params","accessList","value","numberToHex","undefined","gas","from","this","to","data","signMessage","_ref","message","messageToSign","stringToHex","raw","Uint8Array","uint8ArrayToHex","signTypedData","typedData","parsedTypedData","parseTypedData","domain","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","stringifiedData","serializeTypedData","watchAsset","asset","retryCount","onDisconnect","removeListener","onAccountsChanged","onChainChanged","disconnect","emit","accounts","newAccount","newChainId","newChain","on","hexChainId","e","code","originalError","apiChain","getChainMetadata","chainName","name","nativeCurrency","rpcUrls","getValidPublicRPCUrl","blockExplorerUrls","explorers","map","x","url"],"sourceRoot":""}