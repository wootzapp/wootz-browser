{"version":3,"file":"static/js/63288.ab89c3f7.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/rpc/actions/eth_sendRawTransaction.ts","../node_modules/thirdweb/src/utils/bigint.ts","../node_modules/viem/zksync/constants/number.ts","../node_modules/viem/zksync/errors/bytecode.ts","../node_modules/thirdweb/src/transaction/actions/zksync/getEip721Domain.ts","../node_modules/viem/zksync/utils/hashBytecode.ts","../node_modules/thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts","../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../node_modules/viem/constants/number.ts","../node_modules/viem/utils/encoding/toRlp.ts","../node_modules/viem/utils/hash/sha256.ts"],"sourcesContent":["import type { EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\n/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  signedTransaction: Hex,\n) {\n  return await request({\n    method: \"eth_sendRawTransaction\",\n    params: [signedTransaction],\n  });\n}\n","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n","import { maxUint16 } from '../../constants/number.js'\n\nexport const gasPerPubdataDefault = 50000n\nexport const maxBytecodeSize = maxUint16 * 32n\n","import { BaseError } from '../../errors/base.js'\n\nexport type BytecodeLengthExceedsMaxSizeErrorType =\n  BytecodeLengthExceedsMaxSizeError & {\n    name: 'BytecodeLengthExceedsMaxSizeError'\n  }\n\nexport class BytecodeLengthExceedsMaxSizeError extends BaseError {\n  constructor({\n    givenLength,\n    maxBytecodeSize,\n  }: { givenLength: number; maxBytecodeSize: bigint }) {\n    super(\n      `Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthExceedsMaxSizeError' },\n    )\n  }\n}\n\nexport type BytecodeLengthInWordsMustBeOddErrorType =\n  BytecodeLengthInWordsMustBeOddError & {\n    name: 'BytecodeLengthInWordsMustBeOddError'\n  }\n\nexport class BytecodeLengthInWordsMustBeOddError extends BaseError {\n  constructor({ givenLengthInWords }: { givenLengthInWords: number }) {\n    super(\n      `Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`,\n      { name: 'BytecodeLengthInWordsMustBeOddError' },\n    )\n  }\n}\n\nexport type BytecodeLengthMustBeDivisibleBy32ErrorType =\n  BytecodeLengthMustBeDivisibleBy32Error & {\n    name: 'BytecodeLengthMustBeDivisibleBy32Error'\n  }\n\nexport class BytecodeLengthMustBeDivisibleBy32Error extends BaseError {\n  constructor({ givenLength }: { givenLength: number }) {\n    super(\n      `The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthMustBeDivisibleBy32Error' },\n    )\n  }\n}\n","import type { TransactionSerializable } from \"viem\";\nimport { hashBytecode } from \"viem/zksync\";\nimport type { Address } from \"../../../utils/address.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n    factoryDeps,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { pad } from '../../utils/data/pad.js'\nimport { type ToBytesErrorType, toBytes } from '../../utils/encoding/toBytes.js'\nimport { type Sha256ErrorType, sha256 } from '../../utils/hash/sha256.js'\nimport { maxBytecodeSize } from '../constants/number.js'\nimport {\n  BytecodeLengthExceedsMaxSizeError,\n  type BytecodeLengthExceedsMaxSizeErrorType,\n  BytecodeLengthInWordsMustBeOddError,\n  type BytecodeLengthInWordsMustBeOddErrorType,\n  BytecodeLengthMustBeDivisibleBy32Error,\n  type BytecodeLengthMustBeDivisibleBy32ErrorType,\n} from '../errors/bytecode.js'\n\nexport type HashBytecodeErrorType =\n  | BytecodeLengthExceedsMaxSizeErrorType\n  | BytecodeLengthInWordsMustBeOddErrorType\n  | BytecodeLengthMustBeDivisibleBy32ErrorType\n  | Sha256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashBytecode(bytecode: Hex): Uint8Array {\n  const bytecodeBytes = toBytes(bytecode)\n  if (bytecodeBytes.length % 32 !== 0)\n    throw new BytecodeLengthMustBeDivisibleBy32Error({\n      givenLength: bytecodeBytes.length,\n    })\n\n  if (bytecodeBytes.length > maxBytecodeSize)\n    throw new BytecodeLengthExceedsMaxSizeError({\n      givenLength: bytecodeBytes.length,\n      maxBytecodeSize,\n    })\n\n  const hashStr = sha256(bytecodeBytes)\n  const hash = toBytes(hashStr)\n\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords,\n    })\n  }\n\n  const bytecodeLength = toBytes(bytecodeLengthInWords)\n\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 })\n\n  const codeHashVersion = new Uint8Array([1, 0])\n  hash.set(codeHashVersion, 0)\n  hash.set(bytecodeLengthPadded, 2)\n\n  return hash\n}\n","import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\ntype SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n","import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n","export const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n"],"names":["async","eth_sendRawTransaction","request","signedTransaction","method","params","toBigInt","value","includes","Number","isInteger","Error","Uint8Array","BigInt","uint8ArrayToHex","maxBytecodeSize","maxUint16","BytecodeLengthExceedsMaxSizeError","BaseError","constructor","_ref","givenLength","super","name","BytecodeLengthInWordsMustBeOddError","_ref2","givenLengthInWords","BytecodeLengthMustBeDivisibleBy32Error","_ref3","gasPerPubdataDefault","getEip712Domain","transaction","message","gas","nonce","to","from","maxFeePerGas","maxPriorityFeePerGas","paymaster","paymasterInput","gasPerPubdata","data","factoryDeps","txType","gasLimit","gasPerPubdataByteLimit","map","dep","toHex","bytecode","bytecodeBytes","toBytes","length","hashStr","sha256","hash","bytecodeLengthInWords","bytecodeLength","bytecodeLengthPadded","pad","size","codeHashVersion","set","hashBytecode","transactionToMessage","domain","version","chainId","types","Transaction","type","primaryType","sendEip712Transaction","options","account","eip712Transaction","populateEip712Transaction","signEip712Transaction","chain","id","rpc","getRpcClient","transactionHash","client","eip712Domain","customSignature","signTypedData","serializedTransaction","concatHex","toRlp","serializeTransactionEIP712","Promise","all","encode","resolvePromisedValue","eip712","then","result","address","numberToHex","undefined","gas_limit","max_fee_per_gas","max_priority_fee_per_gas","gas_per_pubdata_limit","toSerializableTransaction","values","reduce","acc","x","replace","maxUint96","maxUint256","bytes","arguments","encodable","getEncodable","cursor","createCursor","bytesToHex","Array","isArray","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","hexToBytes","sizeOfBytesLength","pushBytes","getEncodableBytes","to_","noble_sha256","isHex","strict"],"sourceRoot":""}