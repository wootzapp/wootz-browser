{"version":3,"file":"static/js/45815.c289c325.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/rpc/actions/eth_sendRawTransaction.ts","../node_modules/thirdweb/src/utils/bigint.ts","../node_modules/thirdweb/node_modules/viem/zksync/constants/number.ts","../node_modules/thirdweb/node_modules/viem/zksync/errors/bytecode.ts","../node_modules/thirdweb/src/transaction/actions/zksync/getEip721Domain.ts","../node_modules/thirdweb/node_modules/viem/zksync/utils/hashBytecode.ts","../node_modules/thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts","../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/allowance.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/decodeEventLog.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/parseEventLogs.ts","../node_modules/thirdweb/node_modules/viem/utils/address/isAddressEqual.ts","../node_modules/thirdweb/node_modules/viem/errors/log.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/encodeEventTopics.ts","../node_modules/thirdweb/src/event/prepare-event.ts","../node_modules/thirdweb/src/event/utils.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.ts","../node_modules/thirdweb/src/wallets/smart/lib/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts","../node_modules/thirdweb/src/wallets/smart/types.ts","../node_modules/thirdweb/src/event/actions/parse-logs.ts","../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.ts","../node_modules/thirdweb/src/wallets/smart/lib/packUserOp.ts","../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts","../node_modules/thirdweb/src/wallets/smart/lib/userop.ts","../node_modules/thirdweb/src/wallets/smart/index.ts","../node_modules/thirdweb/src/utils/any-evm/zksync/isZkSyncChain.ts","../node_modules/thirdweb/node_modules/viem/constants/number.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toRlp.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/sha256.ts","../node_modules/thirdweb/node_modules/viem/utils/signature/hashTypedData.ts"],"sourcesContent":["import type { EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\n/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  signedTransaction: Hex,\n) {\n  return await request({\n    method: \"eth_sendRawTransaction\",\n    params: [signedTransaction],\n  });\n}\n","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n","import { maxUint16 } from '../../constants/number.js'\n\nexport const gasPerPubdataDefault = 50000n\nexport const maxBytecodeSize = maxUint16 * 32n\n","import { BaseError } from '../../errors/base.js'\n\nexport type BytecodeLengthExceedsMaxSizeErrorType =\n  BytecodeLengthExceedsMaxSizeError & {\n    name: 'BytecodeLengthExceedsMaxSizeError'\n  }\n\nexport class BytecodeLengthExceedsMaxSizeError extends BaseError {\n  constructor({\n    givenLength,\n    maxBytecodeSize,\n  }: { givenLength: number; maxBytecodeSize: bigint }) {\n    super(\n      `Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthExceedsMaxSizeError' },\n    )\n  }\n}\n\nexport type BytecodeLengthInWordsMustBeOddErrorType =\n  BytecodeLengthInWordsMustBeOddError & {\n    name: 'BytecodeLengthInWordsMustBeOddError'\n  }\n\nexport class BytecodeLengthInWordsMustBeOddError extends BaseError {\n  constructor({ givenLengthInWords }: { givenLengthInWords: number }) {\n    super(\n      `Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`,\n      { name: 'BytecodeLengthInWordsMustBeOddError' },\n    )\n  }\n}\n\nexport type BytecodeLengthMustBeDivisibleBy32ErrorType =\n  BytecodeLengthMustBeDivisibleBy32Error & {\n    name: 'BytecodeLengthMustBeDivisibleBy32Error'\n  }\n\nexport class BytecodeLengthMustBeDivisibleBy32Error extends BaseError {\n  constructor({ givenLength }: { givenLength: number }) {\n    super(\n      `The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthMustBeDivisibleBy32Error' },\n    )\n  }\n}\n","import type { TransactionSerializable } from \"viem\";\nimport { hashBytecode } from \"viem/zksync\";\nimport type { Address } from \"../../../utils/address.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n    factoryDeps,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { pad } from '../../utils/data/pad.js'\nimport { type ToBytesErrorType, toBytes } from '../../utils/encoding/toBytes.js'\nimport { type Sha256ErrorType, sha256 } from '../../utils/hash/sha256.js'\nimport { maxBytecodeSize } from '../constants/number.js'\nimport {\n  BytecodeLengthExceedsMaxSizeError,\n  type BytecodeLengthExceedsMaxSizeErrorType,\n  BytecodeLengthInWordsMustBeOddError,\n  type BytecodeLengthInWordsMustBeOddErrorType,\n  BytecodeLengthMustBeDivisibleBy32Error,\n  type BytecodeLengthMustBeDivisibleBy32ErrorType,\n} from '../errors/bytecode.js'\n\nexport type HashBytecodeErrorType =\n  | BytecodeLengthExceedsMaxSizeErrorType\n  | BytecodeLengthInWordsMustBeOddErrorType\n  | BytecodeLengthMustBeDivisibleBy32ErrorType\n  | Sha256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashBytecode(bytecode: Hex): Uint8Array {\n  const bytecodeBytes = toBytes(bytecode)\n  if (bytecodeBytes.length % 32 !== 0)\n    throw new BytecodeLengthMustBeDivisibleBy32Error({\n      givenLength: bytecodeBytes.length,\n    })\n\n  if (bytecodeBytes.length > maxBytecodeSize)\n    throw new BytecodeLengthExceedsMaxSizeError({\n      givenLength: bytecodeBytes.length,\n      maxBytecodeSize,\n    })\n\n  const hashStr = sha256(bytecodeBytes)\n  const hash = toBytes(hashStr)\n\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords,\n    })\n  }\n\n  const bytecodeLength = toBytes(bytecodeLengthInWords)\n\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 })\n\n  const codeHashVersion = new Uint8Array([1, 0])\n  hash.set(codeHashVersion, 0)\n  hash.set(bytecodeLengthPadded, 2)\n\n  return hash\n}\n","import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n","import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"allowance\" function.\n */\nexport type AllowanceParams = {\n  owner: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"owner\" }>;\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n};\n\nexport const FN_SELECTOR = \"0xdd62ed3e\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"owner\",\n  },\n  {\n    type: \"address\",\n    name: \"spender\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `allowance` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `allowance` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isAllowanceSupported } from \"thirdweb/extensions/erc20\";\n * const supported = isAllowanceSupported([\"0x...\"]);\n * ```\n */\nexport function isAllowanceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"allowance\" function.\n * @param options - The options for the allowance function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowanceParams } from \"thirdweb/extensions/erc20\";\n * const result = encodeAllowanceParams({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowanceParams(options: AllowanceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.owner, options.spender]);\n}\n\n/**\n * Encodes the \"allowance\" function into a Hex string with its parameters.\n * @param options - The options for the allowance function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowance } from \"thirdweb/extensions/erc20\";\n * const result = encodeAllowance({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowance(options: AllowanceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeAllowanceParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the allowance function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeAllowanceResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeAllowanceResultResult(\"...\");\n * ```\n */\nexport function decodeAllowanceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"allowance\" function on the contract.\n * @param options - The options for the allowance function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { allowance } from \"thirdweb/extensions/erc20\";\n *\n * const result = await allowance({\n *  contract,\n *  owner: ...,\n *  spender: ...,\n * });\n *\n * ```\n */\nexport async function allowance(\n  options: BaseTransactionOptions<AllowanceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.owner, options.spender],\n  });\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\n\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\nimport { getAbiItem } from './getAbiItem.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = getAbiItem({\n          abi: abi as Abi,\n          name: log.topics[0] as string,\n        }) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (!value) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (!value) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import { BaseError } from './base.js'\n\nexport type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {\n  name: 'FilterTypeNotSupportedError'\n}\nexport class FilterTypeNotSupportedError extends BaseError {\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`, {\n      name: 'FilterTypeNotSupportedError',\n    })\n  }\n}\n","import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsReturnType = [Hex, ...(Hex | Hex[] | null)[]]\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(\n  parameters: EncodeEventTopicsParameters<abi, eventName>,\n): EncodeEventTopicsReturnType {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: (Hex | Hex[] | null)[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encodeArg({ param, value: args_[i][j] }),\n            )\n          return args_[i] ? encodeArg({ param, value: args_[i] }) : null\n        }) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n","import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n","import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"PostOpRevertReason\" event.\n */\nexport type PostOpRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the PostOpRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { postOpRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  postOpRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function postOpRevertReasonEvent(\n  filters: PostOpRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event PostOpRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { concat } from \"viem\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  UserOperationV06,\n  UserOperationV06Hexed,\n  UserOperationV07,\n  UserOperationV07Hexed,\n} from \"../types.js\";\n\nexport const generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(\n  userOp: UserOperationV06 | UserOperationV07,\n): UserOperationV06Hexed | UserOperationV07Hexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      val === undefined || val === null || isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationV06Hexed | UserOperationV07Hexed;\n}\n","import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport { postOpRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/events/PostOpRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport {\n  type BundlerOptions,\n  type EstimationResult,\n  type GasPriceResult,\n  type PmTransactionData,\n  type UserOperationReceipt,\n  type UserOperationV06,\n  type UserOperationV07,\n  formatUserOperationReceipt,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Bundle a user operation.\n * @param args - The options for bundling a user operation.\n * @returns The bundle hash of the user operation.\n * @example\n * ```ts\n * import { bundleUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOpHash = await bundleUserOp({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * Estimate the gas cost of a user operation.\n * @param args - The options for estimating the gas cost of a user operation.\n * @returns The estimated gas cost of the user operation.\n * @example\n * ```ts\n * import { estimateUserOpGas } from \"thirdweb/wallets/smart\";\n *\n * const gasCost = await estimateUserOpGas({\n *  userOp,\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n    paymasterVerificationGasLimit:\n      res.paymasterVerificationGasLimit !== undefined\n        ? hexToBigInt(res.paymasterVerificationGasLimit)\n        : undefined,\n    paymasterPostOpGasLimit:\n      res.paymasterPostOpGasLimit !== undefined\n        ? hexToBigInt(res.paymasterPostOpGasLimit)\n        : undefined,\n  };\n}\n\n/**\n * Get the gas fees of a user operation.\n * @param args - The options for getting the gas price of a user operation.\n * @returns The gas price of the user operation.\n * @example\n * ```ts\n * import { getUserOpGasPrice } from \"thirdweb/wallets/smart\";\n *\n * const fees = await getUserOpGasPrice({\n *  options,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpGasFees(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceipt({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<TransactionReceipt | undefined> {\n  const res = await getUserOpReceiptRaw(args);\n\n  if (!res) {\n    return undefined;\n  }\n\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent(), postOpRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(\n        `UserOp failed at txHash: ${res.receipt.transactionHash}`,\n      );\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.receipt.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * Get the receipt of a user operation.\n * @param args - The options for getting the receipt of a user operation.\n * @returns The raw receipt of the user operation.\n * @example\n * ```ts\n * import { getUserOpReceiptRaw } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await getUserOpReceiptRaw({\n *  client,\n *  chain,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpReceiptRaw(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n  },\n): Promise<UserOperationReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    options: args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  return formatUserOperationReceipt(res as UserOperationReceipt);\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const entryPointVersion = getEntryPointVersion(\n    options.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n  const bundlerVersion = entryPointVersion === \"v0.6\" ? \"v1\" : \"v2\";\n  const bundlerUrl =\n    options.bundlerUrl ?? getDefaultBundlerUrl(options.chain, bundlerVersion);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n","import type { Address } from \"abitype\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\n\nexport type SmartWalletOptions = Prettify<\n  {\n    chain: Chain; // TODO consider making default chain optional\n    factoryAddress?: string;\n    overrides?: {\n      bundlerUrl?: string;\n      accountAddress?: string;\n      accountSalt?: string;\n      entrypointAddress?: string;\n      erc20Paymaster?: {\n        address: string;\n        token: string;\n      };\n      paymaster?: (\n        userOp: UserOperationV06 | UserOperationV07,\n      ) => Promise<PaymasterResult>;\n      predictAddress?: (factoryContract: ThirdwebContract) => Promise<string>;\n      createAccount?: (\n        factoryContract: ThirdwebContract,\n      ) => PreparedTransaction;\n      execute?: (\n        accountContract: ThirdwebContract,\n        transaction: SendTransactionOption,\n      ) => PreparedTransaction;\n      executeBatch?: (\n        accountContract: ThirdwebContract,\n        transactions: SendTransactionOption[],\n      ) => PreparedTransaction;\n      getAccountNonce?: (accountContract: ThirdwebContract) => Promise<bigint>;\n    };\n  } & (\n    | {\n        /**\n         * @deprecated use 'sponsorGas' instead\n         */\n        gasless: boolean;\n      }\n    | {\n        sponsorGas: boolean;\n      }\n  )\n>;\n\n// internal type\nexport type SmartAccountOptions = Prettify<\n  Omit<SmartWalletOptions, \"chain\" | \"gasless\" | \"sponsorGas\"> & {\n    chain: Chain;\n    sponsorGas: boolean;\n    personalAccount: Account;\n    factoryContract: ThirdwebContract;\n    accountContract: ThirdwebContract;\n    client: ThirdwebClient;\n  }\n>;\n\nexport type BundlerOptions = {\n  bundlerUrl?: string;\n  entrypointAddress?: string;\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\nexport type SmartWalletConnectionOptions = {\n  personalAccount: Account;\n  client: ThirdwebClient;\n  chain?: Chain;\n};\n\nexport type UserOperationV06 = {\n  sender: Address;\n  nonce: bigint;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07 = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  factory: string | undefined; // address\n  factoryData: Hex; // bytes\n  callData: Hex; // bytes\n  callGasLimit: bigint; // uint256\n  verificationGasLimit: bigint; // uint256\n  preVerificationGas: bigint; // uint256\n  maxFeePerGas: bigint; // uint256\n  maxPriorityFeePerGas: bigint; // uint256\n  paymaster: string | undefined; // address\n  paymasterData: Hex; // bytes\n  paymasterVerificationGasLimit: bigint; // uint256\n  paymasterPostOpGasLimit: bigint; // uint256\n  signature: Hex; // bytes\n};\n\nexport type PackedUserOperation = {\n  sender: string; // address\n  nonce: bigint; // uint256\n  initCode: Hex; // bytes\n  callData: Hex; // bytes\n  accountGasLimits: Hex; // bytes32\n  preVerificationGas: bigint; // uint256\n  gasFees: Hex; // bytes32\n  paymasterAndData: Hex; // bytes\n  signature: Hex; // bytes\n};\n\nexport type UserOperationV06Hexed = {\n  sender: Address;\n  nonce: Hex;\n  initCode: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymasterAndData: Hex;\n  signature: Hex;\n};\n\nexport type UserOperationV07Hexed = {\n  sender: Hex;\n  nonce: Hex;\n  factory: Hex;\n  factoryData: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n  paymaster: Hex;\n  paymasterVerificationGasLimit: Hex;\n  paymasterPostOpGasLimit: Hex;\n  paymasterData: Hex;\n  signature: Hex;\n};\n\nexport type PaymasterResult = {\n  preVerificationGas?: bigint;\n  verificationGasLimit?: bigint;\n  callGasLimit?: bigint;\n} & (\n  | {\n      // v0.6 types\n      paymasterAndData: string;\n    }\n  | {\n      // v0.7 types\n      paymaster: string;\n      paymasterData: string;\n      paymasterVerificationGasLimit?: bigint;\n      paymasterPostOpGasLimit?: bigint;\n    }\n);\n\nexport type EstimationResult = {\n  preVerificationGas: bigint;\n  verificationGas: bigint;\n  verificationGasLimit: bigint;\n  callGasLimit: bigint;\n  // v0.7 types\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n};\n\nexport type GasPriceResult = {\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n};\n\nexport type PmTransactionData = {\n  paymaster: Address;\n  paymasterInput: Hex;\n};\n\nexport type UserOperationReceipt = {\n  receipt: TransactionReceipt;\n  logs: TransactionReceipt[\"logs\"];\n  userOpHash: Hex;\n  entryPoint: Address;\n  sender: Address;\n  nonce: bigint;\n  paymaster: Address;\n  actualGasUsed: bigint;\n  actualGasCost: bigint;\n  success: boolean;\n};\n\nexport function formatUserOperationReceipt(\n  userOpReceiptRaw: UserOperationReceipt,\n) {\n  const { receipt: transactionReceipt } = userOpReceiptRaw;\n\n  const receipt = {\n    ...transactionReceipt,\n    transactionHash: transactionReceipt.transactionHash,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex,\n    status: transactionReceipt.status,\n    type: transactionReceipt.type,\n  } as TransactionReceipt;\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\n\n  const userOpReceipt = {\n    ...userOpReceiptRaw,\n    receipt,\n    userOpHash: userOpReceiptRaw.userOpHash,\n    actualGasCost: BigInt(userOpReceiptRaw.actualGasCost),\n    actualGasUsed: BigInt(userOpReceiptRaw.actualGasUsed),\n    nonce: BigInt(userOpReceiptRaw.nonce),\n  } as UserOperationReceipt;\n  return userOpReceipt;\n}\n","import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n","import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, stringToHex(accountSalt ?? \"\")],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getNonce\" function.\n */\nexport type GetNonceParams = {\n  sender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"sender\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"uint192\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x35567e1a\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"address\",\n    name: \"sender\",\n  },\n  {\n    type: \"uint192\",\n    name: \"key\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n    name: \"nonce\",\n  },\n] as const;\n\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetNonceSupported([\"0x...\"]);\n * ```\n */\nexport function isGetNonceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options: GetNonceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options: GetNonceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetNonceParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResultResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(\n  options: BaseTransactionOptions<GetNonceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.sender, options.key],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"uint256\"; name: \"callGasLimit\" },\n      { type: \"uint256\"; name: \"verificationGasLimit\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"uint256\"; name: \"maxFeePerGas\" },\n      { type: \"uint256\"; name: \"maxPriorityFeePerGas\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xa6193531\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple\",\n    name: \"userOp\",\n    components: [\n      {\n        type: \"address\",\n        name: \"sender\",\n      },\n      {\n        type: \"uint256\",\n        name: \"nonce\",\n      },\n      {\n        type: \"bytes\",\n        name: \"initCode\",\n      },\n      {\n        type: \"bytes\",\n        name: \"callData\",\n      },\n      {\n        type: \"uint256\",\n        name: \"callGasLimit\",\n      },\n      {\n        type: \"uint256\",\n        name: \"verificationGasLimit\",\n      },\n      {\n        type: \"uint256\",\n        name: \"preVerificationGas\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxFeePerGas\",\n      },\n      {\n        type: \"uint256\",\n        name: \"maxPriorityFeePerGas\",\n      },\n      {\n        type: \"bytes\",\n        name: \"paymasterAndData\",\n      },\n      {\n        type: \"bytes\",\n        name: \"signature\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"bytes32\"; name: \"accountGasLimits\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"bytes32\"; name: \"gasFees\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x22cdde4c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple\",\n    name: \"userOp\",\n    components: [\n      {\n        type: \"address\",\n        name: \"sender\",\n      },\n      {\n        type: \"uint256\",\n        name: \"nonce\",\n      },\n      {\n        type: \"bytes\",\n        name: \"initCode\",\n      },\n      {\n        type: \"bytes\",\n        name: \"callData\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"accountGasLimits\",\n      },\n      {\n        type: \"uint256\",\n        name: \"preVerificationGas\",\n      },\n      {\n        type: \"bytes32\",\n        name: \"gasFees\",\n      },\n      {\n        type: \"bytes\",\n        name: \"paymasterAndData\",\n      },\n      {\n        type: \"bytes\",\n        name: \"signature\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n","import { type Hex, concat, pad, slice, toHex } from \"viem\";\nimport type { PackedUserOperation, UserOperationV07 } from \"../types.js\";\n\nexport function getInitCode(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.factory\n    ? concat([\n        unpackedUserOperation.factory as Hex,\n        unpackedUserOperation.factoryData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nexport function getAccountGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(unpackedUserOperation.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(unpackedUserOperation.callGasLimit), { size: 16 }),\n  ]) as Hex;\n}\n\nexport function unpackAccountGasLimits(accountGasLimits: Hex) {\n  return {\n    verificationGasLimit: BigInt(slice(accountGasLimits, 0, 16)),\n    callGasLimit: BigInt(slice(accountGasLimits, 16)),\n  };\n}\n\nexport function getGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(unpackedUserOperation.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(unpackedUserOperation.maxFeePerGas), { size: 16 }),\n  ]) as Hex;\n}\n\nexport function unpackGasLimits(gasLimits: Hex) {\n  return {\n    maxPriorityFeePerGas: BigInt(slice(gasLimits, 0, 16)),\n    maxFeePerGas: BigInt(slice(gasLimits, 16)),\n  };\n}\n\nexport function getPaymasterAndData(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.paymaster\n    ? concat([\n        unpackedUserOperation.paymaster as Hex,\n        pad(\n          toHex(\n            unpackedUserOperation.paymasterVerificationGasLimit || BigInt(0),\n          ),\n          {\n            size: 16,\n          },\n        ),\n        pad(toHex(unpackedUserOperation.paymasterPostOpGasLimit || BigInt(0)), {\n          size: 16,\n        }),\n        unpackedUserOperation.paymasterData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nexport const getPackedUserOperation = (\n  userOperation: UserOperationV07,\n): PackedUserOperation => {\n  return {\n    sender: userOperation.sender,\n    nonce: userOperation.nonce,\n    initCode: getInitCode(userOperation),\n    callData: userOperation.callData,\n    accountGasLimits: getAccountGasLimits(userOperation),\n    preVerificationGas: userOperation.preVerificationGas,\n    gasFees: getGasLimits(userOperation),\n    paymasterAndData: getPaymasterAndData(userOperation),\n    signature: userOperation.signature,\n  };\n};\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type {\n  PaymasterResult,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  client: ThirdwebClient;\n  chain: Chain;\n  entrypointAddress?: string;\n  paymasterOverride?: (\n    userOp: UserOperationV06 | UserOperationV07,\n  ) => Promise<PaymasterResult>;\n}): Promise<PaymasterResult> {\n  const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n\n  if (paymasterOverride) {\n    return paymasterOverride(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n  const entrypointVersion = getEntryPointVersion(entrypoint);\n  const paymasterVersion = entrypointVersion === \"v0.6\" ? \"v1\" : \"v2\";\n  const paymasterUrl = getDefaultBundlerUrl(chain, paymasterVersion);\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n      paymaster: res.result.paymaster,\n      paymasterData: res.result.paymasterData,\n      paymasterVerificationGasLimit: res.result.paymasterVerificationGasLimit\n        ? hexToBigInt(res.result.paymasterVerificationGasLimit)\n        : undefined,\n      paymasterPostOpGasLimit: res.result.paymasterPostOpGasLimit\n        ? hexToBigInt(res.result.paymasterPostOpGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n","import { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareCreateAccount,\n  prepareExecute,\n} from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n\n  const bundlerOptions = {\n    client,\n    chain,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  const entrypointVersion = getEntryPointVersion(\n    args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  const [isDeployed, callData, gasFees, nonce] = await Promise.all([\n    isContractDeployed(accountContract),\n    encode(executeTx),\n    getGasFees({\n      executeTx,\n      bundlerOptions,\n      chain,\n      client,\n    }),\n    getAccountNonce({\n      accountContract,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      getNonceOverride: overrides?.getAccountNonce,\n    }),\n  ]);\n\n  const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;\n\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      bundlerOptions,\n      factoryContract,\n      accountContract,\n      adminAddress,\n      sponsorGas,\n      overrides,\n      isDeployed,\n      nonce,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    });\n  }\n\n  // default to v0.6\n  return populateUserOp_v0_6({\n    bundlerOptions,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    isDeployed,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  });\n}\n\nasync function getGasFees(args: {\n  executeTx: PreparedTransaction;\n  bundlerOptions: BundlerOptions;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<{\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}> {\n  const { executeTx, bundlerOptions, chain, client } = args;\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n\n  const entrypointVersion = getEntryPointVersion(\n    bundlerOptions.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n  const bundlerVersion = entrypointVersion === \"v0.6\" ? \"v1\" : \"v2\";\n  const bundlerUrl =\n    bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain, bundlerVersion);\n\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n  return { maxFeePerGas, maxPriorityFeePerGas };\n}\n\nasync function populateUserOp_v0_7(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}): Promise<UserOperationV07> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  const factory = isDeployed ? undefined : factoryContract.address;\n  const factoryData = isDeployed\n    ? \"0x\"\n    : await encode(\n        prepareCreateAccount({\n          factoryContract: factoryContract,\n          adminAddress,\n          accountSalt: overrides?.accountSalt,\n          createAccountOverride: overrides?.createAccount,\n        }),\n      );\n\n  const partialOp: UserOperationV07 = {\n    sender: accountContract.address,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    factory,\n    factoryData,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterVerificationGasLimit: 0n,\n    paymasterPostOpGasLimit: 0n,\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = (await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    })) as Extract<PaymasterResult, { paymaster: string }>;\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas &&\n      paymasterResult.paymasterPostOpGasLimit &&\n      paymasterResult.paymasterVerificationGasLimit\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = (await getPaymasterAndData({\n        userOp: partialOp,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        paymasterOverride: overrides?.paymaster,\n      })) as Extract<PaymasterResult, { paymaster: string }>;\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData as Hex;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit =\n      estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\nasync function populateUserOp_v0_6(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}): Promise<UserOperationV06> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  const initCode = isDeployed\n    ? \"0x\"\n    : await getAccountInitCode({\n        factoryContract: factoryContract,\n        adminAddress,\n        accountSalt: overrides?.accountSalt,\n        createAccountOverride: overrides?.createAccount,\n      });\n\n  const partialOp: UserOperationV06 = {\n    sender: accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n    });\n    const paymasterAndData =\n      \"paymasterAndData\" in paymasterResult\n        ? paymasterResult.paymasterAndData\n        : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options: bundlerOptions,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n        });\n        const paymasterAndData2 =\n          \"paymasterAndData\" in paymasterResult2\n            ? paymasterResult2.paymasterAndData\n            : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2 as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options: bundlerOptions,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n\n  const entrypointVersion = getEntryPointVersion(\n    entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  let userOpHash: Hex;\n\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp as UserOperationV07);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client,\n      }),\n      userOp: packedUserOp,\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client,\n      }),\n      userOp: userOp as UserOperationV06,\n    });\n  }\n\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n}) {\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address:\n      config.factoryAddress ||\n      getDefaultAccountFactory(config.overrides?.entrypointAddress),\n    chain: config.chain,\n    client: options.client,\n  });\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: options.adminAccount.address,\n    predictAddressOverride: config.overrides?.predictAddress,\n    accountSalt: config.overrides?.accountSalt,\n    accountAddress: config.overrides?.accountAddress,\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client,\n  });\n\n  let executeTx: PreparedTransaction;\n  if (options.transactions.length === 1) {\n    const tx = options.transactions[0] as PreparedTransaction;\n    const serializedTx = await toSerializableTransaction({\n      transaction: tx,\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      transaction: serializedTx,\n      executeOverride: config.overrides?.execute,\n    });\n  } else {\n    const serializedTxs = await Promise.all(\n      options.transactions.map((tx) =>\n        toSerializableTransaction({\n          transaction: tx,\n        }),\n      ),\n    );\n    executeTx = prepareBatchExecute({\n      accountContract,\n      transactions: serializedTxs,\n      executeBatchOverride: config.overrides?.executeBatch,\n    });\n  }\n\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract,\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    overrides: config.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: config.chain,\n    adminAccount: options.adminAccount,\n    entrypointAddress: config.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  return signedUserOp;\n}\n","import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n  maxUint96,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { concatHex } from \"../../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { getDefaultAccountFactory } from \"./lib/constants.js\";\nimport {\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"./types.js\";\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress =\n    options.factoryAddress ??\n    getDefaultAccountFactory(creationOptions.overrides?.entrypointAddress);\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isZkSyncChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress({\n    factoryContract,\n    adminAddress: personalAccount.address,\n    predictAddressOverride: options.overrides?.predictAddress,\n    accountSalt: options.overrides?.accountSalt,\n    accountAddress: options.overrides?.accountAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      const erc20Paymaster = options.overrides?.erc20Paymaster;\n      let paymasterOverride:\n        | undefined\n        | ((\n            userOp: UserOperationV06 | UserOperationV07,\n          ) => Promise<PaymasterResult>) = undefined;\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymasterAndData: concatHex([\n              erc20Paymaster.address as Hex,\n              erc20Paymaster?.token as Hex,\n            ]),\n            // for 0.7 compatibility\n            paymaster: erc20Paymaster.address as Hex,\n            paymasterData: \"0x\",\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      }\n      const executeTx = prepareExecute({\n        accountContract,\n        transaction,\n        executeOverride: options.overrides?.execute,\n      });\n      return _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        transactions,\n        executeBatchOverride: options.overrides?.executeBatch,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: {\n    address: string;\n    token: string;\n  };\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.token;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.address,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    contract: tokenContract,\n    spender: erc20Paymaster.address,\n    amountWei: maxUint96 - 1n,\n  });\n  const transaction = await toSerializableTransaction({\n    transaction: approveTx,\n    from: accountContract.address,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    transaction,\n    executeOverride: options.overrides?.execute,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        erc20Paymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            chain,\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          chain,\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    transaction: executeTx,\n    factoryContract: options.factoryContract,\n    accountContract: options.accountContract,\n    adminAddress: options.personalAccount.address,\n    sponsorGas: options.sponsorGas,\n    overrides: options.overrides,\n  });\n  const signedUserOp = await signUserOp({\n    client: options.client,\n    chain: options.chain,\n    adminAccount: options.personalAccount,\n    entrypointAddress: options.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  const bundlerOptions: BundlerOptions = {\n    chain: options.chain,\n    client: options.client,\n    bundlerUrl: options.overrides?.bundlerUrl,\n    entrypointAddress: options.overrides?.entrypointAddress,\n  };\n  const userOpHash = await bundleUserOp({\n    options: bundlerOptions,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    ...options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n","import type { Chain } from \"../../../chains/types.js\";\n\nexport function isZkSyncChain(chain: Chain) {\n  return (\n    chain.id === 324 ||\n    chain.id === 300 ||\n    chain.id === 302 ||\n    chain.id === 11124\n  );\n}\n","export const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<to extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: to | undefined,\n): Sha256Hash<to> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<to>\n  return toHex(bytes) as Sha256Hash<to>\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\ntype HashStructErrorType = EncodeDataErrorType | Keccak256ErrorType | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n"],"names":["async","eth_sendRawTransaction","request","signedTransaction","method","params","toBigInt","value","includes","Number","isInteger","Error","Uint8Array","BigInt","uint8ArrayToHex","maxBytecodeSize","maxUint16","BytecodeLengthExceedsMaxSizeError","BaseError","constructor","_ref","givenLength","super","name","BytecodeLengthInWordsMustBeOddError","_ref2","givenLengthInWords","BytecodeLengthMustBeDivisibleBy32Error","_ref3","gasPerPubdataDefault","getEip712Domain","transaction","message","gas","nonce","to","from","maxFeePerGas","maxPriorityFeePerGas","paymaster","paymasterInput","gasPerPubdata","data","factoryDeps","txType","gasLimit","gasPerPubdataByteLimit","map","dep","toHex","bytecode","bytecodeBytes","toBytes","length","hashStr","sha256","hash","bytecodeLengthInWords","bytecodeLength","bytecodeLengthPadded","pad","size","codeHashVersion","set","hashBytecode","transactionToMessage","domain","version","chainId","types","Transaction","type","primaryType","sendEip712Transaction","options","account","eip712Transaction","populateEip712Transaction","signEip712Transaction","chain","id","rpc","getRpcClient","transactionHash","client","eip712Domain","customSignature","signTypedData","serializedTransaction","concatHex","toRlp","serializeTransactionEIP712","Promise","all","encode","resolvePromisedValue","eip712","then","result","address","numberToHex","undefined","gas_limit","max_fee_per_gas","max_priority_fee_per_gas","gas_per_pubdata_limit","toSerializableTransaction","values","reduce","acc","x","replace","FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","toEventSelector","toSignatureHash","docsPath","decodeTopic","param","match","decodeAbiParameters","getAbiItem","parameters","abi","args","isSelector","isHex","strict","abiItems","filter","abiItem","toFunctionSelector","matchedAbiItem","inputs","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AbiItemAmbiguityError","argType","abiParameterType","isAddress","Object","components","component","test","Array","isArray","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","parseEventLogs","logs","eventName","log","topics","event","strict_","signature","argTopics","AbiEventSignatureEmptyTopicsError","find","formatAbiItem","AbiEventSignatureNotFoundError","isUnnamed","some","indexedInputs","indexed","i","topic","DecodeLogTopicsMismatch","nonIndexedInputs","decodedData","err","AbiDecodingDataSizeTooSmallError","PositionOutOfBoundsError","DecodeLogDataMismatch","decodeEventLog","matchArgs","isEqual","input","a","b","InvalidAddressError","toLowerCase","isAddressEqual","keccak256","entries","key","includesArgs","Boolean","FilterTypeNotSupportedError","encodeEventTopics","item","AbiEventNotFoundError","definition","args_","_","j","encodeArg","encodeAbiParameters","prepareEvent","resolvedSignature","parseAbiItem","abiEvent","toEventHash","filters","userOperationRevertReasonEvent","arguments","postOpRevertReasonEvent","generateRandomUint192","rand1","Math","floor","random","rand2","rand3","rand4","rand5","rand6","hexlifyUserOp","userOp","fromEntries","val","estimateUserOpGas","res","sendBundlerRequest","operation","entrypointAddress","ENTRYPOINT_ADDRESS_v0_6","preVerificationGas","hexToBigInt","verificationGas","verificationGasLimit","callGasLimit","MANAGED_ACCOUNT_GAS_BUFFER","paymasterVerificationGasLimit","paymasterPostOpGasLimit","getUserOpReceipt","userOpHash","userOpReceiptRaw","receipt","transactionReceipt","blockNumber","contractAddress","cumulativeGasUsed","effectiveGasPrice","gasUsed","transactionIndex","status","blobGasPrice","blobGasUsed","actualGasCost","actualGasUsed","formatUserOperationReceipt","getUserOpReceiptRaw","success","events","viem_parseEventLogs","e","revertReason","revertMsg","decodeErrorResult","join","DEBUG","console","debug","bundlerVersion","getEntryPointVersion","bundlerUrl","getDefaultBundlerUrl","fetchWithHeaders","getClientFetch","response","headers","body","stringify","jsonrpc","json","ok","error","statusText","JSON","code","prepareCreateAccount","adminAddress","factoryContract","createAccountOverride","createAccount","accountSalt","prepareContractCall","contract","stringToHex","prepareExecute","accountContract","executeOverride","execute","getAccountGasLimits","unpackedUserOperation","concat","getGasLimits","getPaymasterAndData","paymasterData","getPackedUserOperation","userOperation","sender","initCode","factory","factoryData","callData","accountGasLimits","gasFees","paymasterAndData","paymasterOverride","entrypoint","paymasterVersion","paymasterUrl","createUnsignedUserOp","executeTx","overrides","sponsorGas","bundlerOptions","entrypointVersion","isDeployed","isContractDeployed","getGasFees","getAccountNonce","getNonceOverride","partialOp","DUMMY_SIGNATURE","paymasterResult","estimates","paymasterResult2","populateUserOp_v0_7","deployTx","getAccountInitCode","paymasterAndData2","populateUserOp_v0_6","isThirdwebUrl","bundlerGasPrice","getUserOpGasFees","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","feeData","getDefaultGasOverrides","signUserOp","adminAccount","packedUserOp","readContract","getUserOpHashV07","getContract","ENTRYPOINT_ADDRESS_v0_7","getUserOpHashV06","signMessage","raw","hexToBytes","getNonce","isSmartWallet","wallet","personalAccountToSmartAccountMap","WeakMap","smartWalletToPersonalAccountMap","connectSmartWallet","connectionOptions","creationOptions","personalAccount","connectChain","factoryAddress","getDefaultAccountFactory","gasless","isZkSyncChain","createZkSyncAccount","accountAddress","predictAddressOverride","predictAddress","extraData","catch","cause","getAddress","sendTransaction","erc20Paymaster","tokenAddress","token","tokenContract","accountAllowance","owner","spender","allowance","approveTx","approve","amountWei","maxUint96","_sendUserOp","approveERC20","paymasterCallback","sendBatchTransaction","transactions","executeBatchOverride","executeBatch","tx","prepareBatchExecute","hashMessage","checkContractWalletSignature","_deployAccount","originalMsgHash","sig","factorySupports712","wrappedMessageHash","verifyingContract","AccountMessage","_typedData","typedData","parseTypedData","checkContractWalletSignedTypedData","hashTypedData","onTransactionRequested","createSmartAccount","disconnectSmartWallet","get","delete","prepTx","getCachedChain","serializableTransaction","pmData","getZkPaymasterData","txHash","broadcastZkTransaction","prepareTransaction","dummyTx","unsignedUserOp","signedUserOp","bundleUserOp","timeout","timeoutMs","interval","intervalMs","endtime","Date","now","userOpReceipt","resolve","setTimeout","waitForUserOpReceipt","bytes","encodable","getEncodable","cursor","createCursor","bytesToHex","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","pushBytes","getEncodableBytes","to_","noble_sha256","EIP712Domain","getTypesForEIP712Domain","validateTypedData","parts","push","hashStruct","hashDomain","encoded","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","_ref4","encodedHashType","_ref5","unsortedDeps","findTypeDependencies","deps","sort","_ref6","t","encodeType","_ref7","primaryType_","results","Set","has","add","_ref8","slice","lastIndexOf","parsedType","typeValuePairs","_ref9","_ref10","v"],"sourceRoot":""}