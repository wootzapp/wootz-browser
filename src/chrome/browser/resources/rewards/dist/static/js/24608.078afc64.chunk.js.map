{"version":3,"file":"static/js/24608.078afc64.chunk.js","mappings":"6NAkCA,MAAMA,EAAW,GAiFVC,eAAeC,EACpBC,GAEA,MAAOC,EAASC,SA/EXJ,eAAyCK,GAKf,IALgB,QAC/CC,EAAO,wBACPC,EAAuB,YACvBC,EAAW,QACXC,GAC+BJ,EAC/B,MAAMK,GAAoBC,EAAAA,EAAAA,GAAY,CACpCC,QAASH,EAAQI,wBACjBC,MAAON,EAAYM,MACnBC,OAAQP,EAAYO,SAIhBC,QAAcC,EAAAA,EAAAA,cAAa,CAC/BC,SAAUR,EACVS,OAAQ,4DACRC,OAAQ,CAACd,EAAQM,QAASb,KAGtBsB,EACJC,KAAKC,MAAMC,KAAKC,MAAQ,MAAShB,EAAQiB,iBAAmB,MAExDvB,EAAU,CACdwB,KAAMrB,EAAQM,QACdgB,GAAIrB,EAAwBqB,GAC5BC,MAAOC,EAAAA,GACPC,MAAOxB,EAAwByB,IAC/BC,cAAe,GACfC,QAASnC,EACToC,WAAYnB,EACZK,SAAUA,EACVe,KAAM7B,EAAwB6B,MAGhC,IAAKjC,EAAQyB,GACX,MAAM,IAAIS,MAAM,oDAElB,IAAKlC,EAAQ4B,MACX,MAAM,IAAIM,MAAM,mDAElB,IAAKlC,EAAQiC,KACX,MAAM,IAAIC,MAAM,oDAIlB,MAAMC,GAAUC,EAAAA,EAAAA,GACd,CACE,CAAEC,KAAM,WACR,CAAEA,KAAM,WACR,CAAEA,KAAM,WACR,CAAEA,KAAM,WACR,CAAEA,KAAM,WACR,CAAEA,KAAM,WACR,CAAEA,KAAM,WACR,CAAEA,KAAM,YAEV,CACErC,EAAQwB,KACRxB,EAAQyB,GACRzB,EAAQ0B,MACR1B,EAAQ4B,MACR5B,EAAQ8B,cACR9B,EAAQ+B,QACR/B,EAAQgC,YACRM,EAAAA,EAAAA,GAAUtC,EAAQiC,QAMtB,MAAO,CAACjC,QAFgBG,EAAQoC,YAAY,CAAEJ,YAGhD,CAQqCK,CAA2BzC,GAGxD0C,QAAiBC,MACrB,gDACA,CACE1B,OAAQ,OACR2B,MAAMC,EAAAA,EAAAA,GAAU,CACdC,MAAO9C,EAAQO,QAAQuC,MACvB5B,OAAQ,CAACjB,EAASC,GAClBuB,KAAMxB,EAAQwB,KACdC,GAAIzB,EAAQyB,GACZqB,SAAU9C,EAAQ4B,QAEpBmB,QAAS,CACP,YAAahD,EAAQO,QAAQ0C,OAC7B,eAAgB,oCAItB,IAAKP,EAASQ,GAEZ,MADAR,EAASE,MAAMO,SACT,IAAIhB,MAAM,qCAAqCO,EAASU,UAEhE,MAAMC,QAAaX,EAASW,OACtBC,EAAkBD,EAAKE,OAC7B,IAAIC,EAAAA,EAAAA,GAAMF,GACR,MAAO,CACLA,gBAAiBA,EACjB1C,MAAOZ,EAAQM,YAAYM,MAC3BC,OAAQb,EAAQM,YAAYO,QAGhC,MAAM,IAAIsB,MAAM,gCAA+BU,EAAAA,EAAAA,GAAUQ,KAC3D,C","sources":["../node_modules/thirdweb/src/transaction/actions/gasless/providers/biconomy.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport { type TransactionSerializable, encodeAbiParameters } from \"viem\";\nimport { ADDRESS_ZERO } from \"../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { isHex } from \"../../../../utils/encoding/helpers/is-hex.js\";\nimport { keccak256 } from \"../../../../utils/hashing/keccak256.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { Account } from \"../../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../../prepare-transaction.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport type { WaitForReceiptOptions } from \"../../wait-for-tx-receipt.js\";\n\n/**\n * @transaction\n */\nexport type BiconomyOptions = {\n  provider: \"biconomy\";\n  // you can find the correct forwarder for your network here: https://docs-gasless.biconomy.io/misc/contract-addresses\n  relayerForwarderAddress: Address;\n  apiId: string;\n  apiKey: string;\n  deadlineSeconds?: number; // default: 3600\n};\n\ntype SendBiconomyTransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  serializableTransaction: TransactionSerializable;\n  gasless: BiconomyOptions;\n};\n\n// we do not send multiple batches so this stays consistent\nconst BATCH_ID = 0n;\n\n/**\n * @internal - only exported for testing\n */\nexport async function prepareBiconomyTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless,\n}: SendBiconomyTransactionOptions) {\n  const forwarderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client,\n  });\n\n  // get the nonce\n  const nonce = await readContract({\n    contract: forwarderContract,\n    method: \"function getNonce(address,uint256) view returns (uint256)\",\n    params: [account.address, BATCH_ID],\n  });\n\n  const deadline =\n    Math.floor(Date.now() / 1000) + (gasless.deadlineSeconds ?? 3600);\n\n  const request = {\n    from: account.address,\n    to: serializableTransaction.to,\n    token: ADDRESS_ZERO,\n    txGas: serializableTransaction.gas,\n    tokenGasPrice: 0n,\n    batchId: BATCH_ID,\n    batchNonce: nonce,\n    deadline: deadline,\n    data: serializableTransaction.data,\n  };\n\n  if (!request.to) {\n    throw new Error(\"Cannot send a transaction without a `to` address\");\n  }\n  if (!request.txGas) {\n    throw new Error(\"Cannot send a transaction without a `gas` value\");\n  }\n  if (!request.data) {\n    throw new Error(\"Cannot send a transaction without a `data` value\");\n  }\n\n  // create the hash\n  const message = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"address\" },\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n    ],\n    [\n      request.from,\n      request.to,\n      request.token,\n      request.txGas,\n      request.tokenGasPrice,\n      request.batchId,\n      request.batchNonce,\n      keccak256(request.data),\n    ],\n  );\n\n  const signature = await account.signMessage({ message });\n\n  return [request, signature] as const;\n}\n\n/**\n * @internal\n */\nexport async function relayBiconomyTransaction(\n  options: SendBiconomyTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const [request, signature] = await prepareBiconomyTransaction(options);\n\n  // send the transaction to the biconomy api\n  const response = await fetch(\n    \"https://api.biconomy.io/api/v2/meta-tx/native\",\n    {\n      method: \"POST\",\n      body: stringify({\n        apiId: options.gasless.apiId,\n        params: [request, signature],\n        from: request.from,\n        to: request.to,\n        gasLimit: request.txGas,\n      }),\n      headers: {\n        \"x-api-key\": options.gasless.apiKey,\n        \"Content-Type\": \"application/json;charset=utf-8\",\n      },\n    },\n  );\n  if (!response.ok) {\n    response.body?.cancel();\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  const transactionHash = json.txHash;\n  if (isHex(transactionHash)) {\n    return {\n      transactionHash: transactionHash,\n      chain: options.transaction.chain,\n      client: options.transaction.client,\n    };\n  }\n  throw new Error(`Failed to send transaction: ${stringify(json)}`);\n}\n"],"names":["BATCH_ID","async","relayBiconomyTransaction","options","request","signature","_ref","account","serializableTransaction","transaction","gasless","forwarderContract","getContract","address","relayerForwarderAddress","chain","client","nonce","readContract","contract","method","params","deadline","Math","floor","Date","now","deadlineSeconds","from","to","token","ADDRESS_ZERO","txGas","gas","tokenGasPrice","batchId","batchNonce","data","Error","message","encodeAbiParameters","type","keccak256","signMessage","prepareBiconomyTransaction","response","fetch","body","stringify","apiId","gasLimit","headers","apiKey","ok","cancel","text","json","transactionHash","txHash","isHex"],"sourceRoot":""}