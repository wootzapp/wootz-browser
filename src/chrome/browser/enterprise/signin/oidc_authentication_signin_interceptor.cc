// Copyright 2024 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "chrome/browser/enterprise/signin/oidc_authentication_signin_interceptor.h"

#include <string>

#include "base/check.h"
#include "base/functional/callback.h"
#include "base/logging.h"
#include "base/strings/utf_string_conversions.h"
#include "base/uuid.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/enterprise/profile_management/profile_management_features.h"
#include "chrome/browser/enterprise/signin/oidc_authentication_signin_interceptor_factory.h"
#include "chrome/browser/enterprise/signin/oidc_managed_profile_creation_delegate.h"
#include "chrome/browser/enterprise/signin/user_policy_oidc_signin_service.h"
#include "chrome/browser/enterprise/signin/user_policy_oidc_signin_service_factory.h"
#include "chrome/browser/enterprise/util/managed_browser_utils.h"
#include "chrome/browser/new_tab_page/chrome_colors/selected_colors_info.h"
#include "chrome/browser/policy/chrome_browser_policy_connector.h"
#include "chrome/browser/profiles/profile_attributes_entry.h"
#include "chrome/browser/profiles/profile_attributes_storage.h"
#include "chrome/browser/profiles/profile_manager.h"
#include "chrome/browser/profiles/profiles_state.h"
#include "chrome/browser/signin/identity_manager_factory.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/browser_finder.h"
#include "chrome/browser/ui/browser_navigator.h"
#include "chrome/browser/ui/browser_navigator_params.h"
#include "chrome/browser/ui/profiles/profile_colors_util.h"
#include "chrome/common/themes/autogenerated_theme_util.h"
#include "chrome/common/webui_url_constants.h"
#include "components/enterprise/browser/controller/browser_dm_token_storage.h"
#include "components/policy/core/browser/browser_policy_connector.h"
#include "components/policy/core/common/cloud/cloud_policy_client_registration_helper.h"
#include "components/policy/core/common/cloud/user_cloud_policy_manager.h"
#include "components/signin/public/identity_manager/accounts_mutator.h"
#include "components/signin/public/identity_manager/primary_account_mutator.h"
#include "content/public/browser/storage_partition.h"
#include "content/public/browser/web_contents.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/base/mojom/themes.mojom.h"
#include "ui/base/ui_base_features.h"

using profile_management::features::kOidcAuthIsDasherBased;
using profile_management::features::kOidcAuthStubClientId;
using profile_management::features::kOidcAuthStubDmToken;
using profile_management::features::kOidcAuthStubUserEmail;
using profile_management::features::kOidcAuthStubUserName;

namespace {

bool IsValidOidcToken(ProfileManagementOicdTokens oidc_tokens) {
  return !oidc_tokens.auth_token.empty() && !oidc_tokens.id_token.empty();
}

}  // namespace

OidcAuthenticationSigninInterceptor::OidcAuthenticationSigninInterceptor(
    Profile* profile,
    std::unique_ptr<WebSigninInterceptor::Delegate> delegate)
    : profile_(profile), delegate_(std::move(delegate)) {
  CHECK(profile_);
  CHECK(delegate_);
}

OidcAuthenticationSigninInterceptor::~OidcAuthenticationSigninInterceptor() =
    default;

void OidcAuthenticationSigninInterceptor::MaybeInterceptOidcAuthentication(
    content::WebContents* intercepted_contents,
    ProfileManagementOicdTokens oidc_tokens,
    std::string user_email) {
  if (interception_status_ != OidcInterceptionStatus::kNoInterception) {
    DVLOG(1) << "Interception already in progress";
    return;
  }
  interception_status_ = OidcInterceptionStatus::kRegister;

  if (!IsValidOidcToken(oidc_tokens)) {
    DVLOG(1) << "Invalid tokens in the OIDC response";
    return;
  }

  if (!intercepted_contents) {
    DVLOG(1) << "Web contents no longer available, aborting interception";
    return;
  }

  web_contents_ = intercepted_contents->GetWeakPtr();
  oidc_tokens_ = oidc_tokens;
  user_email_ = user_email;

  CHECK(!switch_to_entry_);
  kOidcAuthStubDmToken.Get().empty()
      ? StartOidcRegistration(base::BindOnce(
            &OidcAuthenticationSigninInterceptor::OnClientRegistered,
            weak_factory_.GetWeakPtr()))
      : OnClientRegistered(nullptr);
}

void OidcAuthenticationSigninInterceptor::Shutdown() {
  Reset();
}

void OidcAuthenticationSigninInterceptor::Reset() {
  web_contents_ = nullptr;
  oidc_tokens_ = {};
  dm_token_.clear();
  client_id_.clear();
  user_display_name_.clear();
  user_email_.clear();
  dasher_based_ = true;
  switch_to_entry_ = nullptr;
  profile_creator_.reset();
  profile_color_ = SkColor();
  interception_status_ = OidcInterceptionStatus::kNoInterception;
  interception_bubble_handle_.reset();
  registration_helper_for_temporary_client_.reset();
}

void OidcAuthenticationSigninInterceptor::StartOidcRegistration(
    ClientRegisterCallback callback) {
  policy::DeviceManagementService* device_management_service =
      g_browser_process->browser_policy_connector()
          ->device_management_service();

  // If the DeviceManagementService is not yet initialized, start it up now.
  device_management_service->ScheduleInitialization(0);

  // TODO(xzonghan): Move profile creation prior to OIDC registration or Add
  // profile ID pre-generation.
  auto client = std::make_unique<CloudPolicyClient>(
      base::Uuid::GenerateRandomV4().AsLowercaseString(),
      device_management_service, g_browser_process->shared_url_loader_factory(),
      CloudPolicyClient::DeviceDMTokenCallback());

  registration_helper_for_temporary_client_ =
      std::make_unique<policy::CloudPolicyClientRegistrationHelper>(
          client.get(), enterprise_management::DeviceRegisterRequest::BROWSER);

  // Using a raw pointer to |this| is okay, because the service owns
  // |registration_helper_for_temporary_client_|.
  auto registration_callback =
      base::BindOnce(&OidcAuthenticationSigninInterceptor::OnClientRegistered,
                     base::Unretained(this), std::move(client));

  registration_helper_for_temporary_client_->StartRegistrationWithOidcTokens(
      oidc_tokens_.auth_token, oidc_tokens_.id_token, std::string(),
      std::move(registration_callback));
}

void OidcAuthenticationSigninInterceptor::OnClientRegistered(
    std::unique_ptr<CloudPolicyClient> client) {
  if (kOidcAuthStubDmToken.Get().empty()) {
    CHECK(client);
  }

  dm_token_ = kOidcAuthStubDmToken.Get().empty() ? client->dm_token()
                                                 : kOidcAuthStubDmToken.Get();
  client_id_ = kOidcAuthStubClientId.Get().empty()
                   ? client->client_id()
                   : kOidcAuthStubClientId.Get();
  user_display_name_ = kOidcAuthStubUserName.Get().empty()
                           ? client->oidc_user_display_name()
                           : kOidcAuthStubUserName.Get();
  user_email_ = kOidcAuthStubUserEmail.Get().empty()
                    ? client->oidc_user_email()
                    : kOidcAuthStubUserEmail.Get();

  bool is_dasherless_client =
      client->third_party_identity_type() ==
      policy::ThirdPartyIdentityType::OIDC_MANAGEMENT_DASHERLESS;

  dasher_based_ = !kOidcAuthIsDasherBased.Get() ? kOidcAuthIsDasherBased.Get()
                                                : !is_dasherless_client;

  CHECK(!dm_token_.empty());
  base::FilePath profile_path = profile_->GetPath();
  for (const auto* entry : g_browser_process->profile_manager()
                               ->GetProfileAttributesStorage()
                               .GetAllProfilesAttributes()) {
    if (!entry->GetProfileManagementOidcTokens().auth_token.empty() &&
        entry->GetProfileManagementId() == user_display_name_) {
      switch_to_entry_ = entry;
      break;
    }
  }
  // Same profile
  if (switch_to_entry_ && switch_to_entry_->GetPath() == profile_path) {
    DVLOG(1) << "Intercepted info is already in the right profile";
    Reset();
    return;
  }

  ProfileAttributesEntry* entry =
      g_browser_process->profile_manager()
          ->GetProfileAttributesStorage()
          .GetProfileAttributesWithPath(profile_->GetPath());
  profile_color_ = GenerateNewProfileColor(entry).color;

  auto* identity_manager = IdentityManagerFactory::GetForProfile(profile_);
  WebSigninInterceptor::SigninInterceptionType interception_type =
      switch_to_entry_
          ? WebSigninInterceptor::SigninInterceptionType::kProfileSwitch
          : WebSigninInterceptor::SigninInterceptionType::kEnterprise;
  WebSigninInterceptor::Delegate::BubbleParameters bubble_parameters(
      interception_type, AccountInfo(),
      identity_manager->FindExtendedAccountInfoByAccountId(
          identity_manager->GetPrimaryAccountId(signin::ConsentLevel::kSignin)),
      GetAutogeneratedThemeColors(profile_color_).frame_color,
      /*show_link_data_option=*/false, /*show_managed_disclaimer=*/true);
  interception_status_ = OidcInterceptionStatus::kConsentCollection;
  // TODO(319479018): Replace the interception bubble with unified consent
  // dialog when it's implemented.
  interception_bubble_handle_ = delegate_->ShowSigninInterceptionBubble(
      web_contents_.get(), bubble_parameters,
      base::BindOnce(
          &OidcAuthenticationSigninInterceptor::OnProfileCreationChoice,
          base::Unretained(this)));
}

void OidcAuthenticationSigninInterceptor::AddAsPrimaryAccount(
    Profile* new_profile) {
  interception_status_ = OidcInterceptionStatus::kAddAccount;

  // User account management would be included in unified consent dialog.
  chrome::enterprise_util::SetUserAcceptedAccountManagement(new_profile, true);

  auto* identity_manager = IdentityManagerFactory::GetForProfile(new_profile);
  policy::CloudPolicyManager* user_policy_manager =
      new_profile->GetUserCloudPolicyManager();
  std::string gaia_id =
      user_policy_manager->core()->store()->policy()->gaia_id();
  CoreAccountId account_id =
      identity_manager->GetAccountsMutator()->AddOrUpdateAccount(
          gaia_id, user_email_, "refresh_token",
          /*is_under_advanced_protection=*/false,
          signin_metrics::AccessPoint::ACCESS_POINT_UNKNOWN,
          signin_metrics::SourceForRefreshTokenOperation::
              kMachineLogon_CredentialProvider);

  identity_manager->GetPrimaryAccountMutator()->SetPrimaryAccount(
      account_id, signin::ConsentLevel::kSignin);

  interception_status_ = OidcInterceptionStatus::kCompleted;
  // TODO(319477219): In addition to kSignin level primary account, allow user
  // to turn on sync service and upgrade to kSync.
  Reset();
}

void OidcAuthenticationSigninInterceptor::OnProfileCreationChoice(
    SigninInterceptionResult create) {
  if (create != SigninInterceptionResult::kAccepted) {
    if (switch_to_entry_) {
      DVLOG(1) << "Profile switch refused by the user";
    } else {
      DVLOG(1) << "Profile creation refused by the user";
    }

    Reset();
    return;
  }

  CHECK(!profile_creator_);
  interception_status_ = OidcInterceptionStatus::kProfileCreation;
  if (switch_to_entry_) {
    // Unretained is fine because the profile creator is owned by this.
    profile_creator_ = std::make_unique<ManagedProfileCreator>(
        profile_, switch_to_entry_->GetPath(),
        std::make_unique<OidcManagedProfileCreationDelegate>(),
        base::BindOnce(
            &OidcAuthenticationSigninInterceptor::OnNewSignedInProfileCreated,
            base::Unretained(this)));
  } else {
    // Unretained is fine because the profile creator is owned by this.
    profile_creator_ = std::make_unique<ManagedProfileCreator>(
        profile_, user_display_name_,
        (user_display_name_.empty())
            ? base::UTF8ToUTF16(user_display_name_)
            : profiles::GetDefaultNameForNewEnterpriseProfile(),
        std::make_unique<OidcManagedProfileCreationDelegate>(
            oidc_tokens_.auth_token, oidc_tokens_.id_token, dasher_based_),
        base::BindOnce(
            &OidcAuthenticationSigninInterceptor::OnNewSignedInProfileCreated,
            base::Unretained(this)));
  }
}

void OidcAuthenticationSigninInterceptor::OnNewSignedInProfileCreated(
    base::WeakPtr<Profile> new_profile) {
  CHECK(profile_creator_);

  if (!new_profile) {
    DVLOG(1) << "Failed to create new profile";
    Reset();
    return;
  }
  // Generate a color theme for new profiles
  if (!switch_to_entry_) {
    CHECK_NE(SkColor(), profile_color_);
    if (features::IsChromeWebuiRefresh2023()) {
      ThemeServiceFactory::GetForProfile(new_profile.get())
          ->SetUserColorAndBrowserColorVariant(
              profile_color_, ui::mojom::BrowserColorVariant::kTonalSpot);
    } else {
      ThemeServiceFactory::GetForProfile(new_profile.get())
          ->BuildAutogeneratedThemeFromColor(profile_color_);
    }
  } else {
    DVLOG(1) << "Profile switched sucessfully";
  }

  // Work is done in this profile, the flow continues in the
  // OidcAuthenticationSigninInterceptor that is attached to the new profile.
  // We pass relevant parameters from this instance to the new one.
  OidcAuthenticationSigninInterceptorFactory::GetForProfile(new_profile.get())
      ->CreateBrowserAfterSigninInterception(web_contents_.get());

  policy::UserPolicyOidcSigninService* policy_service =
      policy::UserPolicyOidcSigninServiceFactory::GetForProfile(
          new_profile.get());

  interception_status_ = OidcInterceptionStatus::kPolicyFetch;
  policy_service->FetchPolicyForSignedInUser(
      AccountId(), dm_token_, client_id_,
      /*user_affiliation_ids=*/std::vector<std::string>(),
      new_profile.get()
          ->GetDefaultStoragePartition()
          ->GetURLLoaderFactoryForBrowserProcess(),
      base::BindOnce(&OidcAuthenticationSigninInterceptor::
                         OnPolicyFetchCompleteInNewProfile,
                     weak_factory_.GetWeakPtr(), new_profile.get()));
}

void OidcAuthenticationSigninInterceptor::CreateBrowserAfterSigninInterception(
    content::WebContents* intercepted_contents) {
  DCHECK(intercepted_contents);

  GURL url_to_open = GURL(chrome::kChromeUINewTabURL);
  if (intercepted_contents) {
    intercepted_contents->Close();
  }

  // Open a new browser.
  NavigateParams params(profile_, url_to_open,
                        ui::PAGE_TRANSITION_AUTO_BOOKMARK);
  Navigate(&params);
  DVLOG(1) << "New browser created";
}

void OidcAuthenticationSigninInterceptor::OnPolicyFetchCompleteInNewProfile(
    Profile* new_profile,
    bool success) {
  if (success && dasher_based_) {
    return AddAsPrimaryAccount(new_profile);
  }

  interception_status_ = success ? OidcInterceptionStatus::kCompleted
                                 : OidcInterceptionStatus::kError;
  Reset();
}
