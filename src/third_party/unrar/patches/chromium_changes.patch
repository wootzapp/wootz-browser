diff --git a/third_party/unrar/src/archive.cpp b/third_party/unrar/src/archive.cpp
index 50c591fd38f69..11158f6cc5a7b 100644
--- a/third_party/unrar/src/archive.cpp
+++ b/third_party/unrar/src/archive.cpp
@@ -330,3 +330,12 @@ int64 Archive::Tell()
 }
 #endif
 
+#if defined(CHROMIUM_UNRAR)
+void Archive::SetTempFileHandle(FileHandle hF) {
+  hTempFile = hF;
+}
+
+FileHandle Archive::GetTempFileHandle() {
+  return hTempFile;
+}
+#endif
diff --git a/third_party/unrar/src/archive.hpp b/third_party/unrar/src/archive.hpp
index c0019aef57190..40ade491c4643 100644
--- a/third_party/unrar/src/archive.hpp
+++ b/third_party/unrar/src/archive.hpp
@@ -57,6 +57,13 @@ class Archive:public File
     QuickOpen QOpen;
     bool ProhibitQOpen;
 #endif
+
+#if defined(CHROMIUM_UNRAR)
+    // A handle for a temporary file that should be used when extracting the
+    // archive. This is used to extract the contents while in a sandbox.
+    FileHandle hTempFile;
+#endif
+  
   public:
     Archive(CommandData *InitCmd=NULL);
     ~Archive();
@@ -96,6 +103,10 @@ class Archive:public File
     void QOpenUnload() {QOpen.Unload();}
     void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}
 #endif
+#if defined(CHROMIUM_UNRAR)
+    void SetTempFileHandle(FileHandle hF);
+    FileHandle GetTempFileHandle();
+#endif
 
     BaseBlock ShortBlock;
     MarkHeader MarkHead;
diff --git a/third_party/unrar/src/blake2s.hpp b/third_party/unrar/src/blake2s.hpp
index 06e396a77ba49..13969e1695a11 100644
--- a/third_party/unrar/src/blake2s.hpp
+++ b/third_party/unrar/src/blake2s.hpp
@@ -5,11 +5,8 @@
 #define BLAKE2_DIGEST_SIZE 32
 #define BLAKE2_THREADS_NUMBER 8
 
-enum blake2s_constant
-{
-  BLAKE2S_BLOCKBYTES = 64,
-  BLAKE2S_OUTBYTES   = 32
-};
+constexpr size_t BLAKE2S_BLOCKBYTES = 64;
+constexpr size_t BLAKE2S_OUTBYTES = 32;
 
 
 // Alignment to 64 improves performance of both SSE and non-SSE versions.
diff --git a/third_party/unrar/src/consio.cpp b/third_party/unrar/src/consio.cpp
index 8e5148e2ace96..be8a6a4affc2a 100644
--- a/third_party/unrar/src/consio.cpp
+++ b/third_party/unrar/src/consio.cpp
@@ -222,10 +222,11 @@ bool GetConsolePassword(UIPASSWORD_TYPE Type,const wchar *FileName,SecPassword *
   while (true)
   {
     //    if (!StdinRedirected)
-    if (Type == UIPASSWORD_GLOBAL)
+    if (Type == UIPASSWORD_GLOBAL) {
       eprintf(L"\n%s: ", St(MAskPsw));
-    else
+    } else {
       eprintf(St(MAskPswFor), FileName);
+    }
 
     wchar PlainPsw[MAXPASSWORD + 1];
     GetPasswordText(PlainPsw,ASIZE(PlainPsw));
diff --git a/third_party/unrar/src/crc.cpp b/third_party/unrar/src/crc.cpp
index b28e313bdcb50..54a0f7877468f 100644
--- a/third_party/unrar/src/crc.cpp
+++ b/third_party/unrar/src/crc.cpp
@@ -20,7 +20,8 @@
 #define USE_SLICING
 #endif
 
-static uint crc_tables[8][256]; // Tables for Slicing-by-8.
+static uint crc_tables[8][256];  // Tables for Slicing-by-8.
+static bool is_initialized = false;
 
 
 // Build the classic CRC32 lookup table.
@@ -56,12 +57,13 @@ static void InitTables()
 #endif
 }
 
-struct CallInitCRC {
-  CallInitCRC() { InitTables(); }
-} static CallInit32;
-
 uint CRC32(uint StartCRC,const void *Addr,size_t Size)
 {
+  if (!is_initialized) {
+    is_initialized = true;
+    InitTables();
+  }
+
   byte *Data=(byte *)Addr;
 
 #ifdef USE_SLICING
diff --git a/third_party/unrar/src/errhnd.cpp b/third_party/unrar/src/errhnd.cpp
index 0a4693c7ba700..0c3faa307b7a3 100644
--- a/third_party/unrar/src/errhnd.cpp
+++ b/third_party/unrar/src/errhnd.cpp
@@ -1,8 +1,12 @@
+// NOTE(vakh): The process.h file needs to be included first because "rar.hpp"
+// defines certain macros that cause symbol redefinition errors
+#if defined(UNRAR_NO_EXCEPTIONS)
+#include "base/check.h"
+#include "base/process/process.h"
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
 #include "rar.hpp"
 
-ErrorHandler::ErrorHandler() {
-  Clean();
-}
+#include <ostream>
 
 void ErrorHandler::Clean()
 {
@@ -335,7 +339,11 @@ void ErrorHandler::Throw(RAR_EXIT Code)
     mprintf(L"\n%s\n",St(MProgAborted));
 #endif
   SetErrorCode(Code);
+#if defined(UNRAR_NO_EXCEPTIONS)
+  CHECK(false) << "Failed with RAR_EXIT code: " << Code;
+#else
   throw Code;
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
 }
 
 
diff --git a/third_party/unrar/src/errhnd.hpp b/third_party/unrar/src/errhnd.hpp
index 06f4f616fd96b..3c5c54c490f7a 100644
--- a/third_party/unrar/src/errhnd.hpp
+++ b/third_party/unrar/src/errhnd.hpp
@@ -23,14 +23,13 @@ enum RAR_EXIT // RAR exit code.
 class ErrorHandler
 {
   private:
-    RAR_EXIT ExitCode;
-    uint ErrCount;
-    bool EnableBreak;
-    bool Silent;
-    bool DisableShutdown; // Shutdown is not suitable after last error.
-    bool ReadErrIgnoreAll;
+    RAR_EXIT ExitCode = RARX_SUCCESS;
+    uint ErrCount = 0;
+    bool EnableBreak = true;
+    bool Silent = false;
+    bool DisableShutdown = false; // Shutdown is not suitable after last error.
+    bool ReadErrIgnoreAll = false;
   public:
-    ErrorHandler();
     void Clean();
     void MemoryError();
     void OpenError(const wchar *FileName);
@@ -67,8 +66,8 @@ class ErrorHandler
     void SetDisableShutdown() {DisableShutdown=true;}
     bool IsShutdownEnabled() {return !DisableShutdown;}
 
-    bool UserBreak; // Ctrl+Break is pressed.
-    bool MainExit; // main() is completed.
+    bool UserBreak = false; // Ctrl+Break is pressed.
+    bool MainExit = false; // main() is completed.
 };
 
 
diff --git a/third_party/unrar/src/extract.cpp b/third_party/unrar/src/extract.cpp
index fda3750195e2f..271a8968d45a8 100644
--- a/third_party/unrar/src/extract.cpp
+++ b/third_party/unrar/src/extract.cpp
@@ -650,6 +650,11 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
     }
 
     File CurFile;
+#if defined(CHROMIUM_UNRAR)
+    // Since extraction is done in a sandbox, this must extract to the temp file
+    // handle instead of the default.
+    CurFile.SetFileHandle(Arc.GetTempFileHandle());
+#endif
 
     bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;
     if (LinkEntry && (Arc.FileHead.RedirType != FSREDIR_FILECOPY)) {
@@ -665,8 +670,9 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
       }
     } else if (Arc.IsArcDir()) {
       if (!ExtrFile || Command == 'P' || Command == 'I' || Command == 'E' ||
-          Cmd->ExclPath == EXCL_SKIPWHOLEPATH)
+          Cmd->ExclPath == EXCL_SKIPWHOLEPATH) {
         return true;
+      }
       TotalFileCount++;
       ExtrCreateDir(Arc, ArcFileName);
       // It is important to not increment MatchedArgs here, so we extract
@@ -1113,7 +1119,7 @@ void CmdExtract::ExtrPrepareName(Archive &Arc,const wchar *ArcFileName,wchar *De
        // Destination path can be without trailing slash if it come from GUI
        // shell.
        AddEndSlash(DestName, DestSize);
-    }
+     }
   }
 
 #ifndef SFX_MODULE
diff --git a/third_party/unrar/src/extract.hpp b/third_party/unrar/src/extract.hpp
index 18396c5b936c5..9e566b039864c 100644
--- a/third_party/unrar/src/extract.hpp
+++ b/third_party/unrar/src/extract.hpp
@@ -56,8 +56,8 @@ class CmdExtract
     unsigned long MatchedArgs;
     bool FirstFile;
     bool AllMatchesExact;
-    bool ReconstructDone;
-    bool UseExactVolName;
+    bool ReconstructDone=false;
+    bool UseExactVolName=false;
 
     // If any non-zero solid file was successfully unpacked before current.
     // If true and if current encrypted file is broken, obviously
@@ -90,6 +90,11 @@ class CmdExtract
     void ExtractArchiveInit(Archive &Arc);
     bool ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat);
     static void UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize);
+
+#if defined(CHROMIUM_UNRAR)
+    int64 GetCurrentFileSize() { return DataIO.CurUnpWrite; }
+    bool IsMissingNextVolume() { return DataIO.NextVolumeMissing; }
+#endif
 };
 
 #endif
diff --git a/third_party/unrar/src/file.cpp b/third_party/unrar/src/file.cpp
index eb798b8102b86..3c4552bd11ead 100644
--- a/third_party/unrar/src/file.cpp
+++ b/third_party/unrar/src/file.cpp
@@ -20,6 +20,10 @@ File::File()
   ReadErrorMode=FREM_ASK;
   TruncatedAfterReadError=false;
   CurFilePos = 0;
+
+#ifdef CHROMIUM_UNRAR
+  hOpenFile=FILE_BAD_HANDLE;
+#endif
 }
 
 
@@ -53,6 +57,11 @@ bool File::Open(const wchar *Name,uint Mode)
   bool UpdateMode=(Mode & FMF_UPDATE)!=0;
   bool WriteMode=(Mode & FMF_WRITE)!=0;
 #ifdef _WIN_ALL
+#if defined(CHROMIUM_UNRAR)
+  // Do not open a file handle since the sandbox doesn't allow it. Use the
+  // handle provided by the caller.
+  hNewFile = hOpenFile;
+#else
   uint Access=WriteMode ? GENERIC_WRITE:GENERIC_READ;
   if (UpdateMode)
     Access|=GENERIC_WRITE;
@@ -98,7 +107,14 @@ bool File::Open(const wchar *Name,uint Mode)
     FILETIME ft={0xffffffff,0xffffffff}; // This value prevents atime modification.
     SetFileTime(hNewFile,NULL,&ft,NULL);
   }
+#endif  // defined(CHROMIUM_UNRAR)
+
+#else
 
+#if defined(CHROMIUM_UNRAR)
+  // Do not open a file handle since the sandbox doesn't allow it. Use the
+  // handle provided by the caller.
+  int handle = hOpenFile;
 #else
   int flags=UpdateMode ? O_RDWR:(WriteMode ? O_WRONLY:O_RDONLY);
 #ifdef O_BINARY
@@ -116,6 +132,8 @@ bool File::Open(const wchar *Name,uint Mode)
   WideToChar(Name,NameA,ASIZE(NameA));
 
   int handle=open(NameA,flags);
+#endif  // defined(CHROMIUM_UNRAR)
+
 #ifdef LOCK_EX
 
 #ifdef _OSF_SOURCE
@@ -175,6 +193,11 @@ bool File::WOpen(const wchar *Name)
 
 bool File::Create(const wchar *Name,uint Mode)
 {
+#if defined(CHROMIUM_UNRAR)
+  // Since the Chromium sandbox does not allow the creation of files, use the
+  // provided file.
+  hFile = hOpenFile;
+#else
   // OpenIndiana based NAS and CIFS shares fail to set the file time if file
   // was created in read+write mode and some data was written and not flushed
   // before SetFileTime call. So we should use the write only mode if we plan
@@ -212,6 +235,7 @@ bool File::Create(const wchar *Name,uint Mode)
   hFile=fopen(NameA,WriteMode ? WRITEBINARY:CREATEBINARY);
 #endif
 #endif
+#endif  // defined(CHROMIUM_UNRAR)
   NewFile=true;
   HandleType=FILE_HANDLENORMAL;
   SkipClose=false;
@@ -246,6 +270,8 @@ bool File::Close()
   {
     if (!SkipClose)
     {
+#if !defined(CHROMIUM_UNRAR)
+// unrar should not close the file handle since it wasn't opened by unrar.
 #ifdef _WIN_ALL
       // We use the standard system handle for stdout in Windows
       // and it must not be closed here.
@@ -258,6 +284,7 @@ bool File::Close()
       Success=fclose(hFile)!=EOF;
 #endif
 #endif
+#endif  // defined(CHROMIUM_UNRAR)
     }
     hFile=FILE_BAD_HANDLE;
   }
@@ -866,3 +893,9 @@ int64 File::Copy(File &Dest,int64 Length)
   return CopySize;
 }
 #endif
+
+#if defined(CHROMIUM_UNRAR)
+void File::SetFileHandle(FileHandle hF) {
+  hOpenFile = hF;
+}
+#endif  // defined(CHROMIUM_UNRAR)
diff --git a/third_party/unrar/src/file.hpp b/third_party/unrar/src/file.hpp
index 5f55de960ebad..888c6ca3b9c38 100644
--- a/third_party/unrar/src/file.hpp
+++ b/third_party/unrar/src/file.hpp
@@ -87,6 +87,11 @@ class File
 
     FILE_ERRORTYPE ErrorType;
 
+#if defined(CHROMIUM_UNRAR)
+    FileHandle hOpenFile;
+#endif  // defined(CHROMIUM_UNRAR)
+
+
     byte *SeekBuf; // To read instead of seek for stdin files.
     static const size_t SeekBufSize=0x10000;
   public:
@@ -139,6 +144,14 @@ class File
     void SetExceptions(bool Allow) {AllowExceptions=Allow;}
     void SetPreserveAtime(bool Preserve) {PreserveAtime=Preserve;}
     bool IsTruncatedAfterReadError() {return TruncatedAfterReadError;}
+
+#if defined(CHROMIUM_UNRAR)
+    // Since unrar runs in a sandbox, it doesn't have the permission to open
+    // files on the filesystem. Instead, the caller opens the file and passes
+    // the file handle to unrar. This handle is then used to read the file.
+    void SetFileHandle(FileHandle file);
+#endif  // defined(CHROMIUM_UNRAR)
+  
 #ifdef _UNIX
     int GetFD()
     {
diff --git a/third_party/unrar/src/isnt.cpp b/third_party/unrar/src/isnt.cpp
index 6999236d72a8d..c914449e240d0 100644
--- a/third_party/unrar/src/isnt.cpp
+++ b/third_party/unrar/src/isnt.cpp
@@ -1,5 +1,11 @@
 #include "rar.hpp"
 
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+// GetVersionEx() is deprecated, and the suggested replacement are
+// the IsWindows*OrGreater() functions in VersionHelpers.h. We can't
+// use that because there is no IsWindows11OrGreater() function yet.
+
 DWORD WinNT()
 {
   static int dwPlatformId = -1;
@@ -108,3 +114,5 @@ bool IsWindows11OrGreater() {
   }
   return IsWin11;
 }
+
+#pragma clang diagnostic pop
diff --git a/third_party/unrar/src/model.cpp b/third_party/unrar/src/model.cpp
index aad6f8ad4e467..7d4324b77a141 100644
--- a/third_party/unrar/src/model.cpp
+++ b/third_party/unrar/src/model.cpp
@@ -43,13 +43,27 @@ void ModelPPM::RestartModelRare()
   InitRL=-(MaxOrder < 12 ? MaxOrder:12)-1;
   MinContext = MaxContext = (RARPPM_CONTEXT*) SubAlloc.AllocContext();
   if (MinContext == NULL)
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(0);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
+
   MinContext->Suffix=NULL;
   OrderFall=MaxOrder;
   MinContext->U.SummFreq=(MinContext->NumStats=256)+1;
   FoundState=MinContext->U.Stats=(RARPPM_STATE*)SubAlloc.AllocUnits(256/2);
   if (FoundState == NULL)
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(0);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
+
   for (RunLength=InitRL, PrevSuccess=i=0;i < 256;i++) 
   {
     MinContext->U.Stats[i].Symbol=i;      
@@ -539,7 +553,7 @@ inline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)
     { 
       if (pps>=ps+ASIZE(ps)) // Extra safety check.
         return false;
-      Model->CharMask[(*pps)->Symbol]=Model->EscCount;
+      Model->CharMask[(*pps)->Symbol] = Model->EscCount;
       pps++;
     } while ( --i );
     psee2c->Summ += Model->Coder.SubRange.scale;
diff --git a/third_party/unrar/src/os.hpp b/third_party/unrar/src/os.hpp
index 4b21e49d768e3..f6b4345ec2d21 100644
--- a/third_party/unrar/src/os.hpp
+++ b/third_party/unrar/src/os.hpp
@@ -34,6 +34,7 @@
 #define STRICT 1
 #endif
 
+#if !defined(CHROMIUM_UNRAR)
 // 'ifndef' check here is needed for unrar.dll header to avoid macro
 // re-definition warnings in third party projects.
 #ifndef UNICODE
@@ -50,12 +51,16 @@
 #define WINVER _WIN32_WINNT_WINXP
 #define _WIN32_WINNT _WIN32_WINNT_WINXP
 #endif
+#endif  // !defined(CHROMIUM_UNRAR)
 
-#if !defined(ZIPSFX)
+
+#if !defined(ZIPSFX) && !defined(CHROMIUM_UNRAR)
 #define RAR_SMP
 #endif
 
+#if !defined(CHROMIUM_UNRAR)
 #define WIN32_LEAN_AND_MEAN
+#endif  // CHROMIUM_UNRAR
 
 #include <windows.h>
 #include <prsht.h>
@@ -84,11 +89,13 @@
   #include <direct.h>
   #include <intrin.h>
 
+#if !defined(CHROMIUM_UNRAR)
   // Use SSE only for x86/x64, not ARM Windows.
   #if defined(_M_IX86) || defined(_M_X64)
     #define USE_SSE
     #define SSE_ALIGNMENT 16
   #endif
+#endif  // CHROMIUM_UNRAR
 #else
   #include <dirent.h>
 #endif // _MSC_VER
@@ -269,9 +276,16 @@
   #endif
 #endif
 
+// Disable this optimization in Chromium. Although the underlying architecture
+// may allow unaligned access, C and C++ themselves do not allow this. Rather,
+// unaligned loads should be written with either memcpy, or by endian-agnostic
+// reassembling of values with shifts and ORs. Modern compilers recognize these
+// patterns and generate the unaligned load anyway.
+#if !defined(CHROMIUM_UNRAR)
 #if !defined(BIG_ENDIAN) && defined(_WIN_ALL) || defined(__i386__) || defined(__x86_64__)
 // Allow not aligned integer access, increases speed in some operations.
 #define ALLOW_MISALIGNED
 #endif
+#endif
 
 #endif // _RAR_OS_
diff --git a/third_party/unrar/src/pathfn.cpp b/third_party/unrar/src/pathfn.cpp
index 1f7ce76149a06..20a6bcc77d0cf 100644
--- a/third_party/unrar/src/pathfn.cpp
+++ b/third_party/unrar/src/pathfn.cpp
@@ -787,16 +787,16 @@ static void GenArcName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,u
 
   char Field[10][11];
 
-  sprintf(Field[0], "%04u", rlt.Year);
-  sprintf(Field[1], "%02u", rlt.Month);
-  sprintf(Field[2], "%02u", rlt.Day);
-  sprintf(Field[3], "%02u", rlt.Hour);
-  sprintf(Field[4], "%02u", rlt.Minute);
-  sprintf(Field[5], "%02u", rlt.Second);
-  sprintf(Field[6], "%02u", (uint)CurWeek);
-  sprintf(Field[7], "%u", (uint)WeekDay + 1);
-  sprintf(Field[8], "%03u", rlt.yDay + 1);
-  sprintf(Field[9], "%05u", ArcNumber);
+  snprintf(Field[0], sizeof(Field[0]), "%04u", rlt.Year);
+  snprintf(Field[1], sizeof(Field[1]), "%02u", rlt.Month);
+  snprintf(Field[2], sizeof(Field[2]), "%02u", rlt.Day);
+  snprintf(Field[3], sizeof(Field[3]), "%02u", rlt.Hour);
+  snprintf(Field[4], sizeof(Field[4]), "%02u", rlt.Minute);
+  snprintf(Field[5], sizeof(Field[5]), "%02u", rlt.Second);
+  snprintf(Field[6], sizeof(Field[6]), "%02u", (uint)CurWeek);
+  snprintf(Field[7], sizeof(Field[7]), "%u", (uint)WeekDay + 1);
+  snprintf(Field[8], sizeof(Field[8]), "%03u", rlt.yDay + 1);
+  snprintf(Field[9], sizeof(Field[9]), "%05u", ArcNumber);
 
   const wchar *MaskChars=L"YMDHISWAEN";
 
diff --git a/third_party/unrar/src/secpassword.cpp b/third_party/unrar/src/secpassword.cpp
index 35270ba8659dc..53b65dd537628 100644
--- a/third_party/unrar/src/secpassword.cpp
+++ b/third_party/unrar/src/secpassword.cpp
@@ -25,6 +25,7 @@ class CryptLoader
     }
     ~CryptLoader()
     {
+      // We need to call FreeLibrary when RAR is exiting.
       if (hCrypt!=NULL)
         FreeLibrary(hCrypt);
       hCrypt=NULL;
@@ -46,12 +47,14 @@ class CryptLoader
       }
     }
 
+    static CryptLoader& GetInstance() {
+      static CryptLoader cryptLoader;
+      return cryptLoader;
+    }
+
     CRYPTPROTECTMEMORY pCryptProtectMemory;
     CRYPTUNPROTECTMEMORY pCryptUnprotectMemory;
 };
-
-// We need to call FreeLibrary when RAR is exiting.
-static CryptLoader GlobalCryptLoader;
 #endif
 
 SecPassword::SecPassword()
@@ -170,15 +173,16 @@ void SecHideData(void *Data,size_t DataSize,bool Encode,bool CrossProcess)
   // increases data size not allowing in place conversion.
 #if defined(_WIN_ALL)
   // Try to utilize the secure Crypt[Un]ProtectMemory if possible.
-  if (GlobalCryptLoader.pCryptProtectMemory == NULL) {
-    GlobalCryptLoader.Load();
+  if (CryptLoader::GetInstance().pCryptProtectMemory == NULL) {
+    CryptLoader::GetInstance().Load();
   }
   size_t Aligned=DataSize-DataSize%CRYPTPROTECTMEMORY_BLOCK_SIZE;
   DWORD Flags=CrossProcess ? CRYPTPROTECTMEMORY_CROSS_PROCESS : CRYPTPROTECTMEMORY_SAME_PROCESS;
   if (Encode)
   {
-    if (GlobalCryptLoader.pCryptProtectMemory != NULL) {
-      if (!GlobalCryptLoader.pCryptProtectMemory(Data, DWORD(Aligned), Flags)) {
+    if (CryptLoader::GetInstance().pCryptProtectMemory != NULL) {
+      if (!CryptLoader::GetInstance().pCryptProtectMemory(Data, DWORD(Aligned),
+                                                          Flags)) {
         ErrHandler.GeneralErrMsg(L"CryptProtectMemory failed");
         ErrHandler.SysErrMsg();
         ErrHandler.Exit(RARX_FATAL);
@@ -188,9 +192,9 @@ void SecHideData(void *Data,size_t DataSize,bool Encode,bool CrossProcess)
   }
   else
   {
-    if (GlobalCryptLoader.pCryptUnprotectMemory != NULL) {
-      if (!GlobalCryptLoader.pCryptUnprotectMemory(Data, DWORD(Aligned),
-                                                   Flags)) {
+    if (CryptLoader::GetInstance().pCryptUnprotectMemory != NULL) {
+      if (!CryptLoader::GetInstance().pCryptUnprotectMemory(
+              Data, DWORD(Aligned), Flags)) {
         ErrHandler.GeneralErrMsg(L"CryptUnprotectMemory failed");
         ErrHandler.SysErrMsg();
         ErrHandler.Exit(RARX_FATAL);
diff --git a/third_party/unrar/src/strfn.cpp b/third_party/unrar/src/strfn.cpp
index fcccb45c43a1c..27340418c363d 100644
--- a/third_party/unrar/src/strfn.cpp
+++ b/third_party/unrar/src/strfn.cpp
@@ -356,8 +356,8 @@ void fmtitoa(int64 n, wchar* Str, size_t MaxSize) {
   static wchar ThSep = 0;  // Thousands separator.
 #ifdef _WIN_ALL
   wchar Info[10];
-  if (!ThSep != 0 && GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, Info,
-                                   ASIZE(Info)) > 0) {
+  if ((!ThSep) != 0 && GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND,
+                                     Info, ASIZE(Info)) > 0) {
     ThSep = *Info;
   }
 #elif defined(_UNIX)
diff --git a/third_party/unrar/src/unicode.cpp b/third_party/unrar/src/unicode.cpp
index 9e1b9a2b9f13b..255fa742af4c1 100644
--- a/third_party/unrar/src/unicode.cpp
+++ b/third_party/unrar/src/unicode.cpp
@@ -573,7 +573,6 @@ int64 atoilw(const wchar *s)
 
 
 #ifdef DBCS_SUPPORTED
-SupportDBCS gdbcs;
 
 SupportDBCS::SupportDBCS()
 {
@@ -590,6 +589,11 @@ void SupportDBCS::Init()
     IsLeadByte[I]=IsDBCSLeadByte(I)!=0;
 }
 
+// static
+SupportDBCS& SupportDBCS::GetInstance() {
+  static SupportDBCS supportDBCS;
+  return supportDBCS;
+}
 
 char* SupportDBCS::charnext(const char *s)
 {
diff --git a/third_party/unrar/src/unicode.hpp b/third_party/unrar/src/unicode.hpp
index 9bfd9c5dcd2b6..67689a7c6826c 100644
--- a/third_party/unrar/src/unicode.hpp
+++ b/third_party/unrar/src/unicode.hpp
@@ -34,14 +34,14 @@ class SupportDBCS
     SupportDBCS();
     void Init();
     char* charnext(const char *s);
+  static SupportDBCS& GetInstance();
 
     bool IsLeadByte[256];
     bool DBCSMode;
 };
-extern SupportDBCS gdbcs;
 
-inline char* charnext(const char *s) {return (char *)(gdbcs.DBCSMode ? gdbcs.charnext(s):s+1);}
-inline bool IsDBCSMode() {return gdbcs.DBCSMode;}
+inline char* charnext(const char *s) {return (char *)(SupportDBCS::GetInstance().DBCSMode ? SupportDBCS::GetInstance().charnext(s):s+1);}
+inline bool IsDBCSMode() {return SupportDBCS::GetInstance().DBCSMode;}
 
 #else
 #define charnext(s) ((s)+1)
diff --git a/third_party/unrar/src/unpack.cpp b/third_party/unrar/src/unpack.cpp
index 872b228faa3c8..985a3ea3a465c 100644
--- a/third_party/unrar/src/unpack.cpp
+++ b/third_party/unrar/src/unpack.cpp
@@ -1,3 +1,9 @@
+// NOTE(vakh): The process.h file needs to be included first because "rar.hpp"
+// defines certain macros that cause symbol redefinition errors
+#if defined(UNRAR_NO_EXCEPTIONS)
+#include "base/process/memory.h"
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+
 #include "rar.hpp"
 
 #include "coder.cpp"
@@ -100,16 +106,27 @@ void Unpack::Init(size_t WinSize,bool Solid)
 
   // We do not handle growth for existing fragmented window.
   if (Grow && Fragmented)
+  {
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(0);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
+  }
 
   byte *NewWindow=Fragmented ? NULL : (byte *)malloc(WinSize);
 
   if (NewWindow==NULL)
+  {
     if (Grow || WinSize<0x1000000)
     {
       // We do not support growth for new fragmented window.
       // Also exclude RAR4 and small dictionaries.
+#if defined(UNRAR_NO_EXCEPTIONS)
+      base::TerminateBecauseOutOfMemory(WinSize);
+#else
       throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
     }
     else
     {
@@ -121,6 +138,7 @@ void Unpack::Init(size_t WinSize,bool Solid)
       FragWindow.Init(WinSize);
       Fragmented=true;
     }
+  }
 
   if (!Fragmented)
   {
diff --git a/third_party/unrar/src/unpack50frag.cpp b/third_party/unrar/src/unpack50frag.cpp
index 7430a643e402f..4353071577f3f 100644
--- a/third_party/unrar/src/unpack50frag.cpp
+++ b/third_party/unrar/src/unpack50frag.cpp
@@ -1,3 +1,4 @@
+#include "base/process/memory.h"
 FragmentedWindow::FragmentedWindow()
 {
   memset(Mem,0,sizeof(Mem));
@@ -47,7 +48,11 @@ void FragmentedWindow::Init(size_t WinSize)
       Size-=Size/32;
     }
     if (NewMem == NULL) {
+#if defined(UNRAR_NO_EXCEPTIONS)
+      base::TerminateBecauseOutOfMemory(Size);
+#else
       throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
     }
 
     // Clean the window to generate the same output when unpacking corrupt
@@ -60,7 +65,11 @@ void FragmentedWindow::Init(size_t WinSize)
     BlockNum++;
   }
   if (TotalSize < WinSize) {  // Not found enough free blocks.
+#if defined(UNRAR_NO_EXCEPTIONS)
+    base::TerminateBecauseOutOfMemory(WinSize);
+#else
     throw std::bad_alloc();
+#endif  // defined(UNRAR_NO_EXCEPTIONS)
   }
 }
 
